; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	d:\-=SVN=-\svplayer\src\subtitles\Rasterizer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	d:\-=SVN=-\svplayer\src\subtitles\libssf\Rasterizer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_R4Rasterizer@@6B@				; Rasterizer::`RTTI Complete Object Locator'
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_GRasterizer@@UAEPAXI@Z			; Rasterizer::`scalar deleting destructor'
PUBLIC	??0CPoint@@QAE@UtagPOINT@@@Z			; CPoint::CPoint
PUBLIC	??9CPoint@@QBEHUtagPOINT@@@Z			; CPoint::operator!=
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
PUBLIC	??$?0H@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><int>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<int> >::_Container_base_aux_alloc_real<std::allocator<int> >
PUBLIC	??0?$allocator@H@std@@QAE@ABV01@@Z		; std::allocator<int>::allocator<int>
PUBLIC	??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
PUBLIC	?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ; std::vector<int,std::allocator<int> >::_Buy
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@H@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<int> >::~_Container_base_aux_alloc_real<std::allocator<int> >
PUBLIC	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	?deallocate@?$allocator@H@std@@QAEXPAHI@Z	; std::allocator<int>::deallocate
PUBLIC	??$_Allocate@H@std@@YAPAHIPAH@Z			; std::_Allocate<int>
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
PUBLIC	?max_size@?$allocator@H@std@@QBEIXZ		; std::allocator<int>::max_size
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
PUBLIC	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
PUBLIC	??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<int *,int *,std::allocator<int> >
PUBLIC	??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
PUBLIC	??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
PUBLIC	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
PUBLIC	??$_Fill@PAHH@std@@YAXPAH0ABH@Z			; std::_Fill<int *,int>
PUBLIC	??$fill@PAHH@std@@YAXPAH0ABH@Z			; std::fill<int *,int>
PUBLIC	??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ; std::_Move_cat<int *>
PUBLIC	??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::_Unchecked_move_backward<int *,int *>
PUBLIC	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n
PUBLIC	??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
PUBLIC	??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
PUBLIC	??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator+
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
PUBLIC	??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ; std::_Iter_cat<int *>
PUBLIC	??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int>
PUBLIC	??$_Fill_n@PAHIH@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<int *,unsigned int,int>
PUBLIC	??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z	; stdext::unchecked_fill_n<int *,unsigned int,int>
PUBLIC	??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
PUBLIC	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::push_back
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@HHPBHABHV_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@HHPBHABH@std@@QAE@XZ		; std::_Ranit<int,int,int const *,int const &>::_Ranit<int,int,int const *,int const &>
PUBLIC	??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAHPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
PUBLIC	??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAHPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
PUBLIC	?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z ; std::vector<int,std::allocator<int> >::_Make_iter
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<int> >
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
PUBLIC	??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z	; stdext::unchecked_copy<int *,int *>
PUBLIC	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase
PUBLIC	?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::clear
PUBLIC	??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==
PUBLIC	??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=
PUBLIC	??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*
PUBLIC	??D?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ ; std::_Vector_iterator<int,std::allocator<int> >::operator*
PUBLIC	??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++
PUBLIC	??E?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<int,std::allocator<int> >::operator++
PUBLIC	??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
PUBLIC	??G?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEHABV?$_Vector_const_iterator@HV?$allocator@H@std@@@1@@Z ; std::_Vector_iterator<int,std::allocator<int> >::operator-
PUBLIC	?_Checked_iterator_base@?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEPAHXZ ; std::_Vector_iterator<int,std::allocator<int> >::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAHAAV?$_Vector_iterator@HV?$allocator@H@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_iterator<int,std::allocator<int> >,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAPAHAAV?$_Vector_iterator@HV?$allocator@H@std@@@0@@Z ; std::_Checked_base<std::_Vector_iterator<int,std::allocator<int> > >
PUBLIC	??0?$pair@PAHPAH@std@@QAE@ABQAH0@Z		; std::pair<int *,int *>::pair<int *,int *>
PUBLIC	??$_Med3@PAH@std@@YAXPAH00@Z			; std::_Med3<int *>
PUBLIC	??$_Median@PAH@std@@YAXPAH00@Z			; std::_Median<int *>
PUBLIC	??$swap@H@std@@YAXAAH0@Z			; std::swap<int>
PUBLIC	??$iter_swap@PAHPAH@std@@YAXPAH0@Z		; std::iter_swap<int *,int *>
PUBLIC	??$_Unguarded_partition@PAH@std@@YA?AU?$pair@PAHPAH@0@PAH0@Z ; std::_Unguarded_partition<int *>
PUBLIC	??$_Make_heap@PAHHH@std@@YAXPAH000@Z		; std::_Make_heap<int *,int,int>
PUBLIC	??$make_heap@PAH@std@@YAXPAH0@Z			; std::make_heap<int *>
PUBLIC	??$_Dist_type@PAH@std@@YAPAHPAH@Z		; std::_Dist_type<int *>
PUBLIC	??$_Push_heap@PAHHH@std@@YAXPAHHHH@Z		; std::_Push_heap<int *,int,int>
PUBLIC	??$_Adjust_heap@PAHHH@std@@YAXPAHHHH@Z		; std::_Adjust_heap<int *,int,int>
PUBLIC	??$_Pop_heap@PAHHH@std@@YAXPAH00H0@Z		; std::_Pop_heap<int *,int,int>
PUBLIC	??$_Pop_heap_0@PAHH@std@@YAXPAH00@Z		; std::_Pop_heap_0<int *,int>
PUBLIC	??$pop_heap@PAH@std@@YAXPAH0@Z			; std::pop_heap<int *>
PUBLIC	??$_Sort_heap@PAH@std@@YAXPAH0@Z		; std::_Sort_heap<int *>
PUBLIC	??$sort_heap@PAH@std@@YAXPAH0@Z			; std::sort_heap<int *>
PUBLIC	??$_Val_type@PAH@std@@YAPAHPAH@Z		; std::_Val_type<int *>
PUBLIC	??$_Checked_base@PAH@std@@YAPAHAAPAHU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<int *>
PUBLIC	??$_Checked_base@PAH@std@@YAPAHAAPAH@Z		; std::_Checked_base<int *>
PUBLIC	??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ; std::_Iter_random<int *,int *>
PUBLIC	??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ; std::_Ptr_cat<int *,int *>
PUBLIC	??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
PUBLIC	??$unchecked_copy_backward@PAHPAH@stdext@@YAPAHPAH00@Z ; stdext::unchecked_copy_backward<int *,int *>
PUBLIC	??$_Insertion_sort1@PAHH@std@@YAXPAH00@Z	; std::_Insertion_sort1<int *,int>
PUBLIC	??$_Insertion_sort@PAH@std@@YAXPAH0@Z		; std::_Insertion_sort<int *>
PUBLIC	??$_Sort@PAHH@std@@YAXPAH0H@Z			; std::_Sort<int *,int>
PUBLIC	??$sort@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ; std::sort<std::_Vector_iterator<int,std::allocator<int> > >
PUBLIC	??0?$pair@_J_J@std@@QAE@AB_J0@Z			; std::pair<__int64,__int64>::pair<__int64,__int64>
PUBLIC	??$?0_J_J@?$pair@_K_K@std@@QAE@ABU?$pair@_J_J@1@@Z ; std::pair<unsigned __int64,unsigned __int64>::pair<unsigned __int64,unsigned __int64><__int64,__int64>
PUBLIC	??0?$allocator@U?$pair@_K_K@std@@@std@@QAE@XZ	; std::allocator<std::pair<unsigned __int64,unsigned __int64> >::allocator<std::pair<unsigned __int64,unsigned __int64> >
PUBLIC	??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
PUBLIC	?_Checked_iterator_base@?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEPAU?$pair@_K_K@2@XZ ; std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAU?$pair@_K_K@0@AAV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@@std@@YAPAU?$pair@_K_K@0@AAV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@0@@Z ; std::_Checked_base<std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > > >
PUBLIC	??$_Unchecked_uninitialized_move@V?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@PAU?$pair@_K_K@2@V?$allocator@U?$pair@_K_K@std@@@2@@stdext@@YAPAU?$pair@_K_K@std@@V?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@0PAU12@AAV?$allocator@U?$pair@_K_K@std@@@2@@Z ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
PUBLIC	??$_Umove@V?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEPAU?$pair@_K_K@1@V?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@1@0PAU21@@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Umove<std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > > >
PUBLIC	?reserve@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXI@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::reserve
PUBLIC	??$_Uninit_move@PAU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@U_Undefined_move_tag@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00AAV?$allocator@U?$pair@_K_K@std@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> >,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_uninitialized_move@PAU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@stdext@@YAPAU?$pair@_K_K@std@@PAU12@00AAV?$allocator@U?$pair@_K_K@std@@@2@@Z ; stdext::_Unchecked_uninitialized_move<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
PUBLIC	??$_Umove@PAU?$pair@_K_K@std@@@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEPAU?$pair@_K_K@1@PAU21@00@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Umove<std::pair<unsigned __int64,unsigned __int64> *>
PUBLIC	??$_Fill@PAU?$pair@_K_K@std@@U12@@std@@YAXPAU?$pair@_K_K@0@0ABU10@@Z ; std::_Fill<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> >
PUBLIC	??$fill@PAU?$pair@_K_K@std@@U12@@std@@YAXPAU?$pair@_K_K@0@0ABU10@@Z ; std::fill<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> >
PUBLIC	??$_Move_cat@PAU?$pair@_K_K@std@@@std@@YA?AU_Undefined_move_tag@0@ABQAU?$pair@_K_K@0@@Z ; std::_Move_cat<std::pair<unsigned __int64,unsigned __int64> *>
PUBLIC	??$_Copy_backward_opt@PAU?$pair@_K_K@std@@PAU12@Uforward_iterator_tag@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::forward_iterator_tag>
PUBLIC	??$_Copy_backward_opt@PAU?$pair@_K_K@std@@PAU12@@std@@YAPAU?$pair@_K_K@0@PAU10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *>
PUBLIC	??$_Move_backward_opt@PAU?$pair@_K_K@std@@PAU12@Urandom_access_iterator_tag@2@U_Undefined_move_tag@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Unchecked_move_backward@PAU?$pair@_K_K@std@@PAU12@@stdext@@YAPAU?$pair@_K_K@std@@PAU12@00@Z ; stdext::_Unchecked_move_backward<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *>
PUBLIC	?_Insert_n@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@IABU?$pair@_K_K@2@@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Insert_n
PUBLIC	??G?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator-
PUBLIC	??Y?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator+=
PUBLIC	??Y?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator+=
PUBLIC	??H?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator+
PUBLIC	?insert@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@ABU?$pair@_K_K@2@@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::insert
PUBLIC	??$_Uninit_fill_n@PAU?$pair@_K_K@std@@IU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAXPAU?$pair@_K_K@0@IABU10@AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<unsigned __int64,unsigned __int64> *,unsigned int,std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
PUBLIC	??$unchecked_uninitialized_fill_n@PAU?$pair@_K_K@std@@IU12@V?$allocator@U?$pair@_K_K@std@@@2@@stdext@@YAXPAU?$pair@_K_K@std@@IABU12@AAV?$allocator@U?$pair@_K_K@std@@@2@@Z ; stdext::unchecked_uninitialized_fill_n<std::pair<unsigned __int64,unsigned __int64> *,unsigned int,std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
PUBLIC	?_Ufill@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEPAU?$pair@_K_K@2@PAU32@IABU32@@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Ufill
PUBLIC	?push_back@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXABU?$pair@_K_K@2@@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::push_back
PUBLIC	??$swap@PAV_Aux_cont@std@@@std@@YAXAAPAV_Aux_cont@0@0@Z ; std::swap<std::_Aux_cont *>
PUBLIC	??$swap@V_Aux_cont@std@@@std@@YAXAAV_Aux_cont@0@0@Z ; std::swap<std::_Aux_cont>
PUBLIC	?_Swap_aux@_Container_base_aux@std@@QAEXAAV12@@Z ; std::_Container_base_aux::_Swap_aux
PUBLIC	??$?0U?$pair@_K_K@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@_K_K@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned __int64,unsigned __int64> >
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@_K_K@std@@@std@@@std@@IAE@V?$allocator@U?$pair@_K_K@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
PUBLIC	??0?$allocator@U?$pair@_K_K@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned __int64,unsigned __int64> >::allocator<std::pair<unsigned __int64,unsigned __int64> >
PUBLIC	??0?$_Vector_val@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAE@V?$allocator@U?$pair@_K_K@std@@@1@@Z ; std::_Vector_val<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Vector_val<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
PUBLIC	?begin@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@XZ ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::begin
PUBLIC	?end@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@XZ ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::end
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEPBU?$pair@_K_K@2@XZ ; std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBU?$pair@_K_K@0@AAV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@@std@@YAPBU?$pair@_K_K@0@AAV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@PAU?$pair@_K_K@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@0@AAPAU?$pair@_K_K@0@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >,std::pair<unsigned __int64,unsigned __int64> *>
PUBLIC	??$_Uninit_copy@PBU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAPAU?$pair@_K_K@0@PBU10@0PAU10@AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned __int64,unsigned __int64> const *,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@PAU?$pair@_K_K@2@V?$allocator@U?$pair@_K_K@std@@@2@@stdext@@YAPAU?$pair@_K_K@std@@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@0PAU12@AAV?$allocator@U?$pair@_K_K@std@@@2@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEPAU?$pair@_K_K@1@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@1@0PAU21@@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Ucopy<std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > > >
PUBLIC	??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@_K_K@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
PUBLIC	??1?$_Vector_val@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ ; std::_Vector_val<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::~_Vector_val<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
PUBLIC	?_Tidy@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Tidy
PUBLIC	??1?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::~vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
PUBLIC	?deallocate@?$allocator@U?$pair@_K_K@std@@@std@@QAEXPAU?$pair@_K_K@2@I@Z ; std::allocator<std::pair<unsigned __int64,unsigned __int64> >::deallocate
PUBLIC	?capacity@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::capacity
PUBLIC	??$_Allocate@U?$pair@_K_K@std@@@std@@YAPAU?$pair@_K_K@0@IPAU10@@Z ; std::_Allocate<std::pair<unsigned __int64,unsigned __int64> >
PUBLIC	?allocate@?$allocator@U?$pair@_K_K@std@@@std@@QAEPAU?$pair@_K_K@2@I@Z ; std::allocator<std::pair<unsigned __int64,unsigned __int64> >::allocate
PUBLIC	?max_size@?$allocator@U?$pair@_K_K@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned __int64,unsigned __int64> >::max_size
PUBLIC	?max_size@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::max_size
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	?_Xlen@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@KAXXZ ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Xlen
PUBLIC	?_Buy@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAE_NI@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Buy
PUBLIC	??$_Construct@U?$pair@_K_K@std@@U12@@std@@YAXPAU?$pair@_K_K@0@ABU10@@Z ; std::_Construct<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >
PUBLIC	?construct@?$allocator@U?$pair@_K_K@std@@@std@@QAEXPAU?$pair@_K_K@2@ABU32@@Z ; std::allocator<std::pair<unsigned __int64,unsigned __int64> >::construct
PUBLIC	??$_Uninit_copy@PAU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
PUBLIC	??$unchecked_uninitialized_copy@PAU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@stdext@@YAPAU?$pair@_K_K@std@@PAU12@00AAV?$allocator@U?$pair@_K_K@std@@@2@@Z ; stdext::unchecked_uninitialized_copy<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
PUBLIC	??$_Ucopy@PAU?$pair@_K_K@std@@@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEPAU?$pair@_K_K@1@PAU21@00@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Ucopy<std::pair<unsigned __int64,unsigned __int64> *>
PUBLIC	??4?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEAAV01@ABV01@@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator=
PUBLIC	??$?8U?$pair@_K_K@std@@U01@@std@@YA_NABV?$allocator@U?$pair@_K_K@std@@@0@0@Z ; std::operator==<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >
PUBLIC	??$swap@PAU?$pair@_K_K@std@@@std@@YAXAAPAU?$pair@_K_K@0@0@Z ; std::swap<std::pair<unsigned __int64,unsigned __int64> *>
PUBLIC	?swap@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXAAV12@@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::swap
PUBLIC	??0?$pair@_K_K@std@@QAE@AB_K0@Z			; std::pair<unsigned __int64,unsigned __int64>::pair<unsigned __int64,unsigned __int64>
PUBLIC	??E?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator++
PUBLIC	??$max@_K@std@@YAAB_KAB_K0@Z			; std::max<unsigned __int64>
PUBLIC	?_Make_iter@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBE?AV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Make_iter
PUBLIC	??$_Destroy@U?$pair@_K_K@std@@@std@@YAXPAU?$pair@_K_K@0@@Z ; std::_Destroy<std::pair<unsigned __int64,unsigned __int64> >
PUBLIC	?destroy@?$allocator@U?$pair@_K_K@std@@@std@@QAEXPAU?$pair@_K_K@2@@Z ; std::allocator<std::pair<unsigned __int64,unsigned __int64> >::destroy
PUBLIC	??$_Destroy_range@V?$allocator@U?$pair@_K_K@std@@@std@@@std@@YAXPAU?$pair@_K_K@0@0AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
PUBLIC	??$_Destroy_range@V?$allocator@U?$pair@_K_K@std@@@std@@@std@@YAXPAU?$pair@_K_K@0@0AAV?$allocator@U?$pair@_K_K@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
PUBLIC	?_Destroy@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXPAU?$pair@_K_K@2@0@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Destroy
PUBLIC	??$_Iter_random@PAU?$pair@_K_K@std@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU?$pair@_K_K@0@0@Z ; std::_Iter_random<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *>
PUBLIC	??$_Ptr_cat@PAU?$pair@_K_K@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@_K_K@0@0@Z ; std::_Ptr_cat<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *>
PUBLIC	??$_Checked_base@PAU?$pair@_K_K@std@@@std@@YAPAU?$pair@_K_K@0@AAPAU10@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::pair<unsigned __int64,unsigned __int64> *>
PUBLIC	??$_Checked_base@PAU?$pair@_K_K@std@@@std@@YAPAU?$pair@_K_K@0@AAPAU10@@Z ; std::_Checked_base<std::pair<unsigned __int64,unsigned __int64> *>
PUBLIC	??$_Copy_opt@PAU?$pair@_K_K@std@@PAU12@Uforward_iterator_tag@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::forward_iterator_tag>
PUBLIC	??$_Copy_opt@PAU?$pair@_K_K@std@@PAU12@@std@@YAPAU?$pair@_K_K@0@PAU10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *>
PUBLIC	??$unchecked_copy@PAU?$pair@_K_K@std@@PAU12@@stdext@@YAPAU?$pair@_K_K@std@@PAU12@00@Z ; stdext::unchecked_copy<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *>
PUBLIC	?erase@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@0@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::erase
PUBLIC	?clear@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXXZ ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::clear
PUBLIC	?begin@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@XZ ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::begin
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U?$pair@_K_K@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,std::pair<unsigned __int64,unsigned __int64>,int,std::pair<unsigned __int64,unsigned __int64> const *,std::pair<unsigned __int64,unsigned __int64> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,std::pair<unsigned __int64,unsigned __int64>,int,std::pair<unsigned __int64,unsigned __int64> const *,std::pair<unsigned __int64,unsigned __int64> const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@U?$pair@_K_K@std@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Ranit<std::pair<unsigned __int64,unsigned __int64>,int,std::pair<unsigned __int64,unsigned __int64> const *,std::pair<unsigned __int64,unsigned __int64> const &>::_Ranit<std::pair<unsigned __int64,unsigned __int64>,int,std::pair<unsigned __int64,unsigned __int64> const *,std::pair<unsigned __int64,unsigned __int64> const &>
PUBLIC	??0?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@PAU?$pair@_K_K@1@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
PUBLIC	??0?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@PAU?$pair@_K_K@1@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
PUBLIC	?end@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@XZ ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::end
PUBLIC	?size@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEIXZ ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::size
PUBLIC	?empty@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBE_NXZ ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::empty
PUBLIC	??0GaussianKernel@@QAE@N@Z			; GaussianKernel::GaussianKernel
PUBLIC	??1GaussianKernel@@QAE@XZ			; GaussianKernel::~GaussianKernel
PUBLIC	??8?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator!=
PUBLIC	??D?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEABU?$pair@_K_K@1@XZ ; std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator*
PUBLIC	??D?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEAAU?$pair@_K_K@1@XZ ; std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator++
PUBLIC	??E?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator++
PUBLIC	??$SeparableFilterX@$01@@YAXPAE0HHHPAHHH@Z	; SeparableFilterX<2>
PUBLIC	??$SeparableFilterY@$01@@YAXPAE0HHHPAHHH@Z	; SeparableFilterY<2>
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7Rasterizer@@6B@				; Rasterizer::`vftable'
EXTRN	??_ERasterizer@@UAEPAXI@Z:PROC			; Rasterizer::`vector deleting destructor'
EXTRN	__imp__BeginPath@4:PROC
EXTRN	__imp__DebugBreak@0:PROC
EXTRN	__imp__AbortPath@4:PROC
EXTRN	__imp__CloseFigure@4:PROC
EXTRN	__imp__EndPath@4:PROC
EXTRN	__imp__GetPath@16:PROC
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
PUBLIC	??_R4?$Array@TSpan@Rasterizer@ssf@@@ssf@@6B@	; ssf::Array<ssf::Rasterizer::Span>::`RTTI Complete Object Locator'
PUBLIC	??_R3?$Array@TSpan@Rasterizer@ssf@@@ssf@@8	; ssf::Array<ssf::Rasterizer::Span>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$Array@TSpan@Rasterizer@ssf@@@ssf@@8	; ssf::Array<ssf::Rasterizer::Span>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$Array@TSpan@Rasterizer@ssf@@@ssf@@8 ; ssf::Array<ssf::Rasterizer::Span>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$Array@TSpan@Rasterizer@ssf@@@ssf@@@8	; ssf::Array<ssf::Rasterizer::Span> `RTTI Type Descriptor'
PUBLIC	??_R4Rasterizer@ssf@@6B@			; ssf::Rasterizer::`RTTI Complete Object Locator'
PUBLIC	??_R3Rasterizer@ssf@@8				; ssf::Rasterizer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Rasterizer@ssf@@8				; ssf::Rasterizer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Rasterizer@ssf@@8			; ssf::Rasterizer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVRasterizer@ssf@@@8			; ssf::Rasterizer `RTTI Type Descriptor'
PUBLIC	??0?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAE@XZ	; ssf::Array<ssf::Rasterizer::Span>::Array<ssf::Rasterizer::Span>
PUBLIC	??_G?$Array@TSpan@Rasterizer@ssf@@@ssf@@UAEPAXI@Z ; ssf::Array<ssf::Rasterizer::Span>::`scalar deleting destructor'
PUBLIC	??1?$Array@TSpan@Rasterizer@ssf@@@ssf@@UAE@XZ	; ssf::Array<ssf::Rasterizer::Span>::~Array<ssf::Rasterizer::Span>
PUBLIC	??_GRasterizer@ssf@@UAEPAXI@Z			; ssf::Rasterizer::`scalar deleting destructor'
PUBLIC	?RemoveAll@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEXXZ ; ssf::Array<ssf::Rasterizer::Span>::RemoveAll
PUBLIC	??0Span@Rasterizer@ssf@@QAE@XZ			; ssf::Rasterizer::Span::Span
PUBLIC	??0Span@Rasterizer@ssf@@QAE@HHHH@Z		; ssf::Rasterizer::Span::Span
PUBLIC	??0Span@Rasterizer@ssf@@QAE@_K0@Z		; ssf::Rasterizer::Span::Span
PUBLIC	?Add@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEXABTSpan@Rasterizer@2@@Z ; ssf::Array<ssf::Rasterizer::Span>::Add
PUBLIC	?Append@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEXPBTSpan@Rasterizer@2@II@Z ; ssf::Array<ssf::Rasterizer::Span>::Append
PUBLIC	??$mymax@_K@ssf@@YA_K_K0@Z			; ssf::mymax<unsigned __int64>
PUBLIC	?GetCount@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QBEIXZ ; ssf::Array<ssf::Rasterizer::Span>::GetCount
PUBLIC	?IsEmpty@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QBE_NXZ ; ssf::Array<ssf::Rasterizer::Span>::IsEmpty
PUBLIC	?GetData@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEPATSpan@Rasterizer@2@XZ ; ssf::Array<ssf::Rasterizer::Span>::GetData
PUBLIC	?SetCount@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEXII@Z ; ssf::Array<ssf::Rasterizer::Span>::SetCount
PUBLIC	?Swap@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEXAAV12@@Z ; ssf::Array<ssf::Rasterizer::Span>::Swap
PUBLIC	?Move@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEXAAV12@@Z ; ssf::Array<ssf::Rasterizer::Span>::Move
PUBLIC	??_7Rasterizer@ssf@@6B@				; ssf::Rasterizer::`vftable'
PUBLIC	??_7?$Array@TSpan@Rasterizer@ssf@@@ssf@@6B@	; ssf::Array<ssf::Rasterizer::Span>::`vftable'
EXTRN	__aligned_free:PROC
EXTRN	??_E?$Array@TSpan@Rasterizer@ssf@@@ssf@@UAEPAXI@Z:PROC ; ssf::Array<ssf::Rasterizer::Span>::`vector deleting destructor'
EXTRN	??_ERasterizer@ssf@@UAEPAXI@Z:PROC		; ssf::Rasterizer::`vector deleting destructor'
EXTRN	__aligned_malloc:PROC
EXTRN	__aligned_realloc:PROC
;	COMDAT ??_7Rasterizer@@6B@
CONST	SEGMENT
??_7Rasterizer@@6B@ DD FLAT:??_R4Rasterizer@@6B@	; Rasterizer::`vftable'
	DD	FLAT:??_ERasterizer@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4Rasterizer@@6B@
rdata$r	SEGMENT
??_R4Rasterizer@@6B@ DD 00H				; Rasterizer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRasterizer@@@8
	DD	FLAT:??_R3Rasterizer@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
;	COMDAT ??_7?$Array@TSpan@Rasterizer@ssf@@@ssf@@6B@
CONST	SEGMENT
??_7?$Array@TSpan@Rasterizer@ssf@@@ssf@@6B@ DD FLAT:??_R4?$Array@TSpan@Rasterizer@ssf@@@ssf@@6B@ ; ssf::Array<ssf::Rasterizer::Span>::`vftable'
	DD	FLAT:??_E?$Array@TSpan@Rasterizer@ssf@@@ssf@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4?$Array@TSpan@Rasterizer@ssf@@@ssf@@6B@
rdata$r	SEGMENT
??_R4?$Array@TSpan@Rasterizer@ssf@@@ssf@@6B@ DD 00H	; ssf::Array<ssf::Rasterizer::Span>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$Array@TSpan@Rasterizer@ssf@@@ssf@@@8
	DD	FLAT:??_R3?$Array@TSpan@Rasterizer@ssf@@@ssf@@8
rdata$r	ENDS
;	COMDAT ??_R3?$Array@TSpan@Rasterizer@ssf@@@ssf@@8
rdata$r	SEGMENT
??_R3?$Array@TSpan@Rasterizer@ssf@@@ssf@@8 DD 00H	; ssf::Array<ssf::Rasterizer::Span>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$Array@TSpan@Rasterizer@ssf@@@ssf@@8
rdata$r	ENDS
;	COMDAT ??_R2?$Array@TSpan@Rasterizer@ssf@@@ssf@@8
rdata$r	SEGMENT
??_R2?$Array@TSpan@Rasterizer@ssf@@@ssf@@8 DD FLAT:??_R1A@?0A@EA@?$Array@TSpan@Rasterizer@ssf@@@ssf@@8 ; ssf::Array<ssf::Rasterizer::Span>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$Array@TSpan@Rasterizer@ssf@@@ssf@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$Array@TSpan@Rasterizer@ssf@@@ssf@@8 DD FLAT:??_R0?AV?$Array@TSpan@Rasterizer@ssf@@@ssf@@@8 ; ssf::Array<ssf::Rasterizer::Span>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$Array@TSpan@Rasterizer@ssf@@@ssf@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$Array@TSpan@Rasterizer@ssf@@@ssf@@@8
_DATA	SEGMENT
??_R0?AV?$Array@TSpan@Rasterizer@ssf@@@ssf@@@8 DD FLAT:??_7type_info@@6B@ ; ssf::Array<ssf::Rasterizer::Span> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$Array@TSpan@Rasterizer@ssf@@@ssf@@', 00H
_DATA	ENDS
;	COMDAT ??_7Rasterizer@ssf@@6B@
CONST	SEGMENT
??_7Rasterizer@ssf@@6B@ DD FLAT:??_R4Rasterizer@ssf@@6B@ ; ssf::Rasterizer::`vftable'
	DD	FLAT:??_ERasterizer@ssf@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4Rasterizer@ssf@@6B@
rdata$r	SEGMENT
??_R4Rasterizer@ssf@@6B@ DD 00H				; ssf::Rasterizer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRasterizer@ssf@@@8
	DD	FLAT:??_R3Rasterizer@ssf@@8
rdata$r	ENDS
;	COMDAT ??_R3Rasterizer@ssf@@8
rdata$r	SEGMENT
??_R3Rasterizer@ssf@@8 DD 00H				; ssf::Rasterizer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Rasterizer@ssf@@8
rdata$r	ENDS
;	COMDAT ??_R2Rasterizer@ssf@@8
rdata$r	SEGMENT
??_R2Rasterizer@ssf@@8 DD FLAT:??_R1A@?0A@EA@Rasterizer@ssf@@8 ; ssf::Rasterizer::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Rasterizer@ssf@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Rasterizer@ssf@@8 DD FLAT:??_R0?AVRasterizer@ssf@@@8 ; ssf::Rasterizer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Rasterizer@ssf@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRasterizer@ssf@@@8
_DATA	SEGMENT
??_R0?AVRasterizer@ssf@@@8 DD FLAT:??_7type_info@@6B@	; ssf::Rasterizer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRasterizer@ssf@@', 00H
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
	ORG $+12
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
; Function compile flags: /Ogtpy
; File d:\-=svn=-\svplayer\src\subtitles\libssf\rasterizer.cpp
;	COMDAT ??$mymax@_K@ssf@@YA_K_K0@Z
_TEXT	SEGMENT
_a$ = 8							; size = 8
_b$ = 16						; size = 8
??$mymax@_K@ssf@@YA_K_K0@Z PROC				; ssf::mymax<unsigned __int64>, COMDAT

; 37   : 	template<class T> T mymax(T a, T b) {return a > b ? a : b;}

	mov	ecx, DWORD PTR _a$[esp]
	mov	edx, DWORD PTR _b$[esp]
	push	esi
	mov	esi, DWORD PTR _b$[esp]
	cmp	ecx, edx
	jb	SHORT $LN3@mymax
	mov	eax, DWORD PTR _a$[esp]
	ja	SHORT $LN5@mymax
	cmp	eax, esi
	jbe	SHORT $LN3@mymax
$LN5@mymax:
	mov	edx, ecx
	pop	esi
	ret	0
$LN3@mymax:
	mov	eax, esi
	pop	esi
	ret	0
??$mymax@_K@ssf@@YA_K_K0@Z ENDP				; ssf::mymax<unsigned __int64>
; Function compile flags: /Ogtpy
; File d:\-=svn=-\svplayer\src\subtitles\libssf\array.h
_TEXT	ENDS
;	COMDAT ?Swap@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEXAAV12@@Z
_TEXT	SEGMENT
?Swap@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEXAAV12@@Z PROC ; ssf::Array<ssf::Rasterizer::Span>::Swap, COMDAT
; _this$ = ecx
; _v$ = eax

; 102  : 			T* pData = m_pData; m_pData = v.m_pData; v.m_pData = pData;

	mov	edx, DWORD PTR [ecx+4]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], esi

; 103  : 			size_t nSize = m_nSize; m_nSize = v.m_nSize; v.m_nSize = nSize;

	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx+8], esi

; 104  : 			size_t nMaxSize = m_nMaxSize; m_nMaxSize = v.m_nMaxSize; v.m_nMaxSize = nMaxSize;

	mov	esi, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx+12], esi

; 105  : 			size_t nGrowBy = m_nGrowBy; m_nGrowBy = v.m_nGrowBy; v.m_nGrowBy = nGrowBy;

	mov	esi, DWORD PTR [eax+16]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [ecx+16], esi
	mov	DWORD PTR [eax+16], edx
	pop	esi

; 106  : 		}

	ret	0
?Swap@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEXAAV12@@Z ENDP ; ssf::Array<ssf::Rasterizer::Span>::Swap
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetData@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEPATSpan@Rasterizer@2@XZ
_TEXT	SEGMENT
?GetData@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEPATSpan@Rasterizer@2@XZ PROC ; ssf::Array<ssf::Rasterizer::Span>::GetData, COMDAT
; _this$ = eax

; 63   : 		T* GetData() {return m_pData;}

	mov	eax, DWORD PTR [eax+4]
	ret	0
?GetData@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEPATSpan@Rasterizer@2@XZ ENDP ; ssf::Array<ssf::Rasterizer::Span>::GetData
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?IsEmpty@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QBE_NXZ
_TEXT	SEGMENT
?IsEmpty@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QBE_NXZ PROC ; ssf::Array<ssf::Rasterizer::Span>::IsEmpty, COMDAT
; _this$ = ecx

; 61   : 		bool IsEmpty() const {return m_nSize == 0;}

	xor	eax, eax
	cmp	DWORD PTR [ecx+8], eax
	sete	al
	ret	0
?IsEmpty@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QBE_NXZ ENDP ; ssf::Array<ssf::Rasterizer::Span>::IsEmpty
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?RemoveAll@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEXXZ
_TEXT	SEGMENT
?RemoveAll@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEXXZ PROC ; ssf::Array<ssf::Rasterizer::Span>::RemoveAll, COMDAT
; _this$ = eax

; 60   : 		void RemoveAll() {m_nSize = 0;}

	mov	DWORD PTR [eax+8], 0
	ret	0
?RemoveAll@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEXXZ ENDP ; ssf::Array<ssf::Rasterizer::Span>::RemoveAll
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?GetCount@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QBEIXZ
_TEXT	SEGMENT
?GetCount@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QBEIXZ PROC ; ssf::Array<ssf::Rasterizer::Span>::GetCount, COMDAT
; _this$ = eax

; 58   : 		size_t GetCount() const {return m_nSize;}

	mov	eax, DWORD PTR [eax+8]
	ret	0
?GetCount@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QBEIXZ ENDP ; ssf::Array<ssf::Rasterizer::Span>::GetCount
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?SetCount@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEXII@Z
_TEXT	SEGMENT
?SetCount@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEXII@Z PROC ; ssf::Array<ssf::Rasterizer::Span>::SetCount, COMDAT
; _this$ = esi
; _nSize$ = edi
; _nGrowBy$ = eax

; 43   : 			if(nGrowBy > 0)

	test	eax, eax
	jbe	SHORT $LN2@SetCount

; 44   : 			{
; 45   : 				m_nGrowBy = nGrowBy;

	mov	DWORD PTR [esi+16], eax
$LN2@SetCount:

; 46   : 			}
; 47   : 
; 48   : 			if(nSize > m_nMaxSize)

	cmp	edi, DWORD PTR [esi+12]
	jbe	SHORT $LN9@SetCount

; 49   : 			{
; 50   : 				m_nMaxSize = nSize + max(m_nGrowBy, m_nSize);

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [esi+8]
	cmp	eax, ecx
	ja	SHORT $LN6@SetCount
	mov	eax, ecx
$LN6@SetCount:

; 51   : 				size_t nBytes = m_nMaxSize * sizeof(T);
; 52   : 				m_pData = m_pData ? (T*)_aligned_realloc(m_pData, nBytes, 16) : (T*)_aligned_malloc(nBytes, 16);

	mov	ecx, DWORD PTR [esi+4]
	add	eax, edi
	mov	DWORD PTR [esi+12], eax
	shl	eax, 4
	push	16					; 00000010H
	push	eax
	test	ecx, ecx
	je	SHORT $LN7@SetCount
	push	ecx
	call	__aligned_realloc
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi+4], eax

; 53   : 			}
; 54   : 
; 55   : 			m_nSize = nSize;

	mov	DWORD PTR [esi+8], edi

; 56   : 		}

	ret	0
$LN7@SetCount:

; 51   : 				size_t nBytes = m_nMaxSize * sizeof(T);
; 52   : 				m_pData = m_pData ? (T*)_aligned_realloc(m_pData, nBytes, 16) : (T*)_aligned_malloc(nBytes, 16);

	call	__aligned_malloc
	add	esp, 8
	mov	DWORD PTR [esi+4], eax
$LN9@SetCount:

; 53   : 			}
; 54   : 
; 55   : 			m_nSize = nSize;

	mov	DWORD PTR [esi+8], edi

; 56   : 		}

	ret	0
?SetCount@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEXII@Z ENDP ; ssf::Array<ssf::Rasterizer::Span>::SetCount
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$Array@TSpan@Rasterizer@ssf@@@ssf@@UAE@XZ
_TEXT	SEGMENT
??1?$Array@TSpan@Rasterizer@ssf@@@ssf@@UAE@XZ PROC	; ssf::Array<ssf::Rasterizer::Span>::~Array<ssf::Rasterizer::Span>, COMDAT
; _this$ = ecx

; 39   : 		virtual ~Array() {if(m_pData) _aligned_free(m_pData);}

	mov	DWORD PTR [ecx], OFFSET ??_7?$Array@TSpan@Rasterizer@ssf@@@ssf@@6B@
	mov	ecx, DWORD PTR [ecx+4]
	test	ecx, ecx
	je	SHORT $LN1@Array
	push	ecx
	call	__aligned_free
	pop	ecx
$LN1@Array:
	ret	0
??1?$Array@TSpan@Rasterizer@ssf@@@ssf@@UAE@XZ ENDP	; ssf::Array<ssf::Rasterizer::Span>::~Array<ssf::Rasterizer::Span>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAE@XZ
_TEXT	SEGMENT
??0?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAE@XZ PROC	; ssf::Array<ssf::Rasterizer::Span>::Array<ssf::Rasterizer::Span>, COMDAT
; _this$ = eax

; 38   : 		Array() {m_pData = NULL; m_nSize = m_nMaxSize = 0; m_nGrowBy = 4096;}

	xor	ecx, ecx
	mov	DWORD PTR [eax], OFFSET ??_7?$Array@TSpan@Rasterizer@ssf@@@ssf@@6B@
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+16], 4096		; 00001000H
	ret	0
??0?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAE@XZ ENDP	; ssf::Array<ssf::Rasterizer::Span>::Array<ssf::Rasterizer::Span>
; Function compile flags: /Ogtpy
; File d:\-=svn=-\svplayer\src\subtitles\libssf\rasterizer.cpp
_TEXT	ENDS
;	COMDAT ?pixmix_sse2@ssf@@YAXPAKKK@Z
_TEXT	SEGMENT
_alpha$ = 8						; size = 4
?pixmix_sse2@ssf@@YAXPAKKK@Z PROC			; ssf::pixmix_sse2, COMDAT
; _dst$ = edx
; _color$ = ecx

; 620  : 	{

	push	ebp
	mov	ebp, esp
	and	esp, -16				; fffffff0H

; 621  : 		alpha = ((alpha * (color>>24)) >> 6) & 0xff;

	mov	eax, ecx
	shr	eax, 24					; 00000018H
	imul	eax, DWORD PTR _alpha$[ebp]

; 622  : 		color &= 0xffffff;

	and	ecx, 16777215				; 00ffffffH
	shr	eax, 6

; 623  : 
; 624  : 		__m128i zero = _mm_setzero_si128();
; 625  : 		__m128i a = _mm_set1_epi32((alpha << 16) | (0xff - alpha));
; 626  : 		__m128i d = _mm_unpacklo_epi8(_mm_cvtsi32_si128(*dst), zero);
; 627  : 		__m128i s = _mm_unpacklo_epi8(_mm_cvtsi32_si128(color), zero);

	movd	xmm2, ecx
	and	eax, 255				; 000000ffH
	sub	esp, 12					; 0000000cH
	mov	ecx, 255				; 000000ffH
	sub	ecx, eax
	push	esi
	mov	esi, DWORD PTR [edx]
	pxor	xmm1, xmm1
	shl	eax, 16					; 00000010H
	movd	xmm0, esi
	punpcklbw xmm0, xmm1
	punpcklbw xmm2, xmm1
	or	ecx, eax

; 628  : 		__m128i r = _mm_unpacklo_epi16(d, s);

	punpcklwd xmm0, xmm2
	movd	xmm1, ecx
	pshufd	xmm1, xmm1, 0

; 629  : 
; 630  : 		r = _mm_madd_epi16(r, a);

	pmaddwd	xmm0, xmm1

; 631  : 		r = _mm_srli_epi32(r, 8);

	psrld	xmm0, 8

; 632  : 		r = _mm_packs_epi32(r, r);

	packssdw xmm0, xmm0

; 633  : 		r = _mm_packus_epi16(r, r);

	packuswb xmm0, xmm0

; 634  : 
; 635  : 		*dst = (DWORD)_mm_cvtsi128_si32(r);

	movd	eax, xmm0
	mov	DWORD PTR [edx], eax

; 636  : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?pixmix_sse2@ssf@@YAXPAKKK@Z ENDP			; ssf::pixmix_sse2
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?pixmix_c@ssf@@YAXPAKKK@Z
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_alpha$ = 12						; size = 4
?pixmix_c@ssf@@YAXPAKKK@Z PROC				; ssf::pixmix_c, COMDAT
; _color$ = edx

; 612  : 		int a = ((alpha * (color>>24)) >> 6) & 0xff;
; 613  : 		int ia = 0xff - a;
; 614  : 
; 615  : 		*dst = ((((*dst & 0x00ff00ff)*ia + (color & 0x00ff00ff)*a) & 0xff00ff00) >> 8)
; 616  : 			| ((((*dst>>8) & 0x00ff00ff)*ia + ((color>>8) & 0x000000ff)*a) & 0xff00ff00);

	mov	ecx, DWORD PTR _dst$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	push	ebx
	mov	eax, edx
	shr	eax, 24					; 00000018H
	imul	eax, DWORD PTR _alpha$[esp]
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx
	shr	edi, 8
	mov	ebx, edx
	shr	ebx, 8
	and	ebx, 255				; 000000ffH
	and	edi, -65281				; ffff00ffH
	shr	eax, 6
	and	eax, 255				; 000000ffH
	imul	ebx, eax
	mov	esi, 255				; 000000ffH
	sub	esi, eax
	imul	edi, esi
	add	edi, ebx
	mov	ebx, ecx
	mov	ebp, edx
	and	ebx, 16711935				; 00ff00ffH
	imul	ebx, esi
	and	ebp, 16711935				; 00ff00ffH
	imul	ebp, eax
	shr	ecx, 8
	shr	edx, 8
	and	ecx, 16711935				; 00ff00ffH
	and	edx, 255				; 000000ffH
	imul	ecx, esi
	imul	edx, eax
	add	ebx, ebp
	shr	ebx, 8
	xor	edi, ebx
	and	edi, 16711935				; 00ff00ffH
	add	ecx, edx
	mov	edx, DWORD PTR _dst$[esp+12]
	xor	edi, ecx
	mov	DWORD PTR [edx], edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 617  : 	}

	ret	0
?pixmix_c@ssf@@YAXPAKKK@Z ENDP				; ssf::pixmix_c
_TEXT	ENDS
PUBLIC	__real@0000000000000000
PUBLIC	__real@00000000
PUBLIC	?Blur@Rasterizer@ssf@@QAEXMH@Z			; ssf::Rasterizer::Blur
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Blur@Rasterizer@ssf@@QAEXMH@Z
_TEXT	SEGMENT
_pass$134303 = -24					; size = 4
tv327 = -20						; size = 4
tv302 = -16						; size = 4
tv871 = -12						; size = 4
_q0$ = -8						; size = 4
_yq$134325 = -4						; size = 4
_this$ = 8						; size = 4
tv680 = 12						; size = 4
tv139 = 12						; size = 4
_n$ = 12						; size = 4
_plane$ = 16						; size = 4
?Blur@Rasterizer@ssf@@QAEXMH@Z PROC			; ssf::Rasterizer::Blur, COMDAT

; 559  : 		if(n <= 0 || !mOverlayWidth || !mOverlayHeight || !mpOverlayBuffer)

	fldz
	sub	esp, 24					; 00000018H
	fcomp	DWORD PTR _n$[esp+20]
	fnstsw	ax
	test	ah, 1
	je	$LN16@Blur
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+24]
	push	esi
	mov	esi, DWORD PTR [ebx+116]
	test	esi, esi
	je	$LN30@Blur
	mov	eax, DWORD PTR [ebx+120]
	mov	DWORD PTR tv327[esp+32], eax
	test	eax, eax
	je	$LN30@Blur
	cmp	DWORD PTR [ebx+112], 0
	je	$LN30@Blur

; 560  : 			return;
; 561  : 
; 562  : 		int w = mOverlayWidth;
; 563  : 		int h = mOverlayHeight;
; 564  : 		int pitch = w*4;
; 565  : 		BYTE* q0 = new BYTE[w*h];

	imul	eax, esi
	push	ebp
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ebp, eax

; 566  : 
; 567  : 		for(int pass = 0, limit = (int)(n + 0.5); pass < n; pass++)

	fld	DWORD PTR _n$[esp+36]
	add	esp, 4
	fcom	QWORD PTR __real@0000000000000000
	mov	DWORD PTR _q0$[esp+36], ebp
	mov	DWORD PTR _pass$134303[esp+36], 0
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	$LN33@Blur
	push	edi
$LN15@Blur:

; 568  : 		{
; 569  : 			BYTE* p = mpOverlayBuffer + plane;

	mov	edi, DWORD PTR [ebx+112]

; 570  : 			BYTE* q = q0;
; 571  : 
; 572  : 			for(int y = 0; y < h; y++, p += pitch, q += w)

	mov	eax, DWORD PTR tv327[esp+40]
	add	edi, DWORD PTR _plane$[esp+36]
	test	eax, eax
	jle	SHORT $LN10@Blur
	lea	edx, DWORD PTR [esi-1]
	mov	DWORD PTR tv139[esp+36], eax
$LN12@Blur:

; 573  : 			{
; 574  : 				q[0] = (2*p[0] + p[4]) >> 2;

	movzx	eax, BYTE PTR [edi]
	movzx	ecx, BYTE PTR [edi+4]
	lea	eax, DWORD PTR [ecx+eax*2]
	sar	eax, 2
	mov	BYTE PTR [ebp], al

; 575  : 				int x = 0;
; 576  : 				for(x = 1; x < w-1; x++)

	mov	eax, 1
	cmp	edx, eax
	jle	SHORT $LN7@Blur

; 570  : 			BYTE* q = q0;
; 571  : 
; 572  : 			for(int y = 0; y < h; y++, p += pitch, q += w)

	lea	ecx, DWORD PTR [edi+8]
$LN9@Blur:

; 577  : 					q[x] = (p[(x-1)*4] + 2*p[x*4] + p[(x+1)*4]) >> 2;

	movzx	ebx, BYTE PTR [ecx-8]
	movzx	edx, BYTE PTR [ecx-4]
	lea	edx, DWORD PTR [ebx+edx*2]
	movzx	ebx, BYTE PTR [ecx]
	add	edx, ebx
	sar	edx, 2
	mov	BYTE PTR [eax+ebp], dl
	inc	eax
	lea	edx, DWORD PTR [esi-1]
	add	ecx, 4
	cmp	eax, edx
	jl	SHORT $LN9@Blur
$LN7@Blur:

; 578  : 				q[x] = (p[(x-1)*4] + 2*p[x*4]) >> 2;

	movzx	ecx, BYTE PTR [edi+eax*4]
	movzx	ebx, BYTE PTR [edi+eax*4-4]
	lea	ecx, DWORD PTR [ebx+ecx*2]
	sar	ecx, 2
	mov	BYTE PTR [eax+ebp], cl
	lea	eax, DWORD PTR [esi*4]
	add	edi, eax
	add	ebp, esi
	sub	DWORD PTR tv139[esp+36], 1
	jne	SHORT $LN12@Blur
	mov	ebx, DWORD PTR _this$[esp+36]
	mov	ebp, DWORD PTR _q0$[esp+40]
$LN10@Blur:

; 579  : 			}
; 580  : 
; 581  : 			p = mpOverlayBuffer + plane;

	mov	ecx, DWORD PTR [ebx+112]
	add	ecx, DWORD PTR _plane$[esp+36]

; 582  : 			q = q0;
; 583  : 
; 584  : 			for(int x = 0; x < w; x++, p += 4, q++)

	test	esi, esi
	jle	$LN14@Blur

; 579  : 			}
; 580  : 
; 581  : 			p = mpOverlayBuffer + plane;

	mov	DWORD PTR tv871[esp+40], esi
$LN6@Blur:

; 585  : 			{
; 586  : 				p[0] = (2*q[0] + q[w]) >> 2;

	movzx	eax, BYTE PTR [esi+ebp]
	movzx	edx, BYTE PTR [ebp]
	lea	ebx, DWORD PTR [esi+ebp]
	lea	edx, DWORD PTR [eax+edx*2]
	sar	edx, 2
	mov	BYTE PTR [ecx], dl

; 587  : 				int y = 0, yp, yq;
; 588  : 				for(y = 1, yp = y*pitch, yq = y*w; y < h-1; y++, yp += pitch, yq += w)

	mov	edx, DWORD PTR tv327[esp+40]
	dec	edx
	cmp	edx, 1
	lea	edi, DWORD PTR [esi*4]
	mov	eax, esi
	jle	SHORT $LN1@Blur
	dec	edx
	mov	DWORD PTR tv302[esp+40], edx
	inc	edx
	imul	edx, esi
	mov	eax, ebx
	mov	DWORD PTR tv680[esp+36], ebp
	mov	DWORD PTR _yq$134325[esp+40], edx
$LN3@Blur:

; 589  : 					p[yp] = (q[yq-w] + 2*q[yq] + q[yq+w]) >> 2;

	mov	ebx, DWORD PTR tv680[esp+36]
	movzx	edx, BYTE PTR [eax]
	movzx	ebx, BYTE PTR [ebx]
	add	DWORD PTR tv680[esp+36], esi
	lea	edx, DWORD PTR [ebx+edx*2]
	movzx	ebx, BYTE PTR [eax+esi]
	add	edx, ebx
	sar	edx, 2
	mov	BYTE PTR [edi+ecx], dl
	lea	edx, DWORD PTR [esi*4]
	add	edi, edx
	add	eax, esi
	sub	DWORD PTR tv302[esp+40], 1
	jne	SHORT $LN3@Blur

; 587  : 				int y = 0, yp, yq;
; 588  : 				for(y = 1, yp = y*pitch, yq = y*w; y < h-1; y++, yp += pitch, yq += w)

	mov	eax, DWORD PTR _yq$134325[esp+40]
$LN1@Blur:

; 590  : 				p[yp] = (q[yq-w] + 2*q[yq]) >> 2;

	mov	edx, eax
	movzx	eax, BYTE PTR [eax+ebp]
	sub	edx, esi
	movzx	edx, BYTE PTR [edx+ebp]
	lea	edx, DWORD PTR [edx+eax*2]
	sar	edx, 2
	mov	BYTE PTR [edi+ecx], dl
	add	ecx, 4
	inc	ebp
	sub	DWORD PTR tv871[esp+40], 1
	jne	$LN6@Blur
	mov	ebx, DWORD PTR _this$[esp+36]
	mov	ebp, DWORD PTR _q0$[esp+40]
$LN14@Blur:
	inc	DWORD PTR _pass$134303[esp+40]
	fild	DWORD PTR _pass$134303[esp+40]
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 5
	jnp	$LN15@Blur
	pop	edi
$LN33@Blur:

; 591  : 			}
; 592  : 		}
; 593  : 
; 594  : 		delete [] q0;

	push	ebp
	fstp	ST(0)
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	pop	ebp
$LN30@Blur:
	pop	esi
	pop	ebx
$LN16@Blur:

; 595  : 	}

	add	esp, 24					; 00000018H
	ret	12					; 0000000cH
?Blur@Rasterizer@ssf@@QAEXMH@Z ENDP			; ssf::Rasterizer::Blur
_TEXT	ENDS
PUBLIC	?_ReallocEdgeBuffer@Rasterizer@ssf@@AAEXH@Z	; ssf::Rasterizer::_ReallocEdgeBuffer
; Function compile flags: /Ogtpy
;	COMDAT ?_ReallocEdgeBuffer@Rasterizer@ssf@@AAEXH@Z
_TEXT	SEGMENT
?_ReallocEdgeBuffer@Rasterizer@ssf@@AAEXH@Z PROC	; ssf::Rasterizer::_ReallocEdgeBuffer, COMDAT
; _this$ = esi
; _edges$ = eax

; 61   : 		mEdgeHeapSize = edges;
; 62   : 		mpEdgeBuffer = (Edge*)realloc(mpEdgeBuffer, sizeof(Edge)*edges);

	mov	ecx, DWORD PTR [esi+96]
	mov	DWORD PTR [esi+100], eax
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR [esi+96], eax

; 63   : 	}

	ret	0
?_ReallocEdgeBuffer@Rasterizer@ssf@@AAEXH@Z ENDP	; ssf::Rasterizer::_ReallocEdgeBuffer
_TEXT	ENDS
PUBLIC	?_TrashOverlay@Rasterizer@ssf@@AAEXXZ		; ssf::Rasterizer::_TrashOverlay
; Function compile flags: /Ogtpy
;	COMDAT ?_TrashOverlay@Rasterizer@ssf@@AAEXXZ
_TEXT	SEGMENT
?_TrashOverlay@Rasterizer@ssf@@AAEXXZ PROC		; ssf::Rasterizer::_TrashOverlay, COMDAT
; _this$ = esi

; 55   : 		if(mpOverlayBuffer) delete [] mpOverlayBuffer;

	mov	eax, DWORD PTR [esi+112]
	test	eax, eax
	je	SHORT $LN4@TrashOverl
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN4@TrashOverl:

; 56   : 		mpOverlayBuffer = NULL;

	mov	DWORD PTR [esi+112], 0

; 57   : 	}

	ret	0
?_TrashOverlay@Rasterizer@ssf@@AAEXXZ ENDP		; ssf::Rasterizer::_TrashOverlay
_TEXT	ENDS
PUBLIC	??1Rasterizer@ssf@@UAE@XZ			; ssf::Rasterizer::~Rasterizer
;	COMDAT xdata$x
; File d:\-=svn=-\svplayer\src\subtitles\libssf\array.h
xdata$x	SEGMENT
__unwindtable$??1Rasterizer@ssf@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1Rasterizer@ssf@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1Rasterizer@ssf@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1Rasterizer@ssf@@UAE@XZ$2
__ehfuncinfo$??1Rasterizer@ssf@@UAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1Rasterizer@ssf@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File d:\-=svn=-\svplayer\src\subtitles\libssf\rasterizer.cpp
xdata$x	ENDS
;	COMDAT ??1Rasterizer@ssf@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1Rasterizer@ssf@@UAE@XZ PROC				; ssf::Rasterizer::~Rasterizer, COMDAT
; _this$ = ecx

; 49   : 	{

	push	-1
	push	__ehhandler$??1Rasterizer@ssf@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	mov	DWORD PTR [esi], OFFSET ??_7Rasterizer@ssf@@6B@
	mov	DWORD PTR __$EHRec$[esp+28], 2

; 50   : 		_TrashOverlay();

	mov	eax, DWORD PTR [esi+112]
	test	eax, eax
	je	SHORT $LN6@Rasterizer
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@Rasterizer:
	mov	DWORD PTR [esi+112], 0

; 51   : 	}

	mov	eax, DWORD PTR [esi+76]
	mov	DWORD PTR [esi+72], OFFSET ??_7?$Array@TSpan@Rasterizer@ssf@@@ssf@@6B@
	test	eax, eax
	je	SHORT $LN9@Rasterizer
	push	eax
	call	__aligned_free
	add	esp, 4
$LN9@Rasterizer:
	mov	eax, DWORD PTR [esi+56]
	mov	DWORD PTR [esi+52], OFFSET ??_7?$Array@TSpan@Rasterizer@ssf@@@ssf@@6B@
	test	eax, eax
	je	SHORT $LN12@Rasterizer
	push	eax
	call	__aligned_free
	add	esp, 4
$LN12@Rasterizer:
	mov	DWORD PTR [esi+32], OFFSET ??_7?$Array@TSpan@Rasterizer@ssf@@@ssf@@6B@
	mov	esi, DWORD PTR [esi+36]
	test	esi, esi
	je	SHORT $LN15@Rasterizer
	push	esi
	call	__aligned_free
	add	esp, 4
$LN15@Rasterizer:
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	pop	esi
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1Rasterizer@ssf@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	jmp	??1?$Array@TSpan@Rasterizer@ssf@@@ssf@@UAE@XZ ; ssf::Array<ssf::Rasterizer::Span>::~Array<ssf::Rasterizer::Span>
__unwindfunclet$??1Rasterizer@ssf@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	jmp	??1?$Array@TSpan@Rasterizer@ssf@@@ssf@@UAE@XZ ; ssf::Array<ssf::Rasterizer::Span>::~Array<ssf::Rasterizer::Span>
__unwindfunclet$??1Rasterizer@ssf@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1?$Array@TSpan@Rasterizer@ssf@@@ssf@@UAE@XZ ; ssf::Array<ssf::Rasterizer::Span>::~Array<ssf::Rasterizer::Span>
__ehhandler$??1Rasterizer@ssf@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1Rasterizer@ssf@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1Rasterizer@ssf@@UAE@XZ ENDP				; ssf::Rasterizer::~Rasterizer
; Function compile flags: /Ogtpy
;	COMDAT ??_GRasterizer@ssf@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GRasterizer@ssf@@UAEPAXI@Z PROC			; ssf::Rasterizer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1Rasterizer@ssf@@UAE@XZ		; ssf::Rasterizer::~Rasterizer
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar:
	mov	eax, esi
	pop	esi
	ret	4
??_GRasterizer@ssf@@UAEPAXI@Z ENDP			; ssf::Rasterizer::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File d:\-=svn=-\svplayer\src\subtitles\libssf\rasterizer.h
_TEXT	ENDS
;	COMDAT ??0Span@Rasterizer@ssf@@QAE@_K0@Z
_TEXT	SEGMENT
__first$ = 8						; size = 8
__second$ = 16						; size = 8
??0Span@Rasterizer@ssf@@QAE@_K0@Z PROC			; ssf::Rasterizer::Span::Span, COMDAT
; _this$ = eax

; 46   : 			union Span(unsigned __int64 _first, unsigned __int64 _second) {first = _first; second = _second;}

	mov	ecx, DWORD PTR __first$[esp-4]
	mov	edx, DWORD PTR __first$[esp]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __second$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __second$[esp]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	ret	16					; 00000010H
??0Span@Rasterizer@ssf@@QAE@_K0@Z ENDP			; ssf::Rasterizer::Span::Span
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0Span@Rasterizer@ssf@@QAE@HHHH@Z
_TEXT	SEGMENT
__y1$ = 8						; size = 4
__x2$ = 12						; size = 4
__y2$ = 16						; size = 4
??0Span@Rasterizer@ssf@@QAE@HHHH@Z PROC			; ssf::Rasterizer::Span::Span, COMDAT
; _this$ = eax
; __x1$ = ecx

; 45   : 			union Span(int _x1, int _y1, int _x2, int _y2) {x1 = _x1; y1 = _y1; x2 = _x2; y2 = _y2;}

	mov	edx, DWORD PTR __y1$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR __x2$[esp-4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR __y2$[esp-4]
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], edx
	ret	12					; 0000000cH
??0Span@Rasterizer@ssf@@QAE@HHHH@Z ENDP			; ssf::Rasterizer::Span::Span
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0Span@Rasterizer@ssf@@QAE@XZ
_TEXT	SEGMENT
??0Span@Rasterizer@ssf@@QAE@XZ PROC			; ssf::Rasterizer::Span::Span, COMDAT
; _this$ = eax

; 44   : 			union Span() {}

	ret	0
??0Span@Rasterizer@ssf@@QAE@XZ ENDP			; ssf::Rasterizer::Span::Span
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Push_heap@PAHHH@std@@YAXPAHHHH@Z
_TEXT	SEGMENT
__Top$ = 8						; size = 4
??$_Push_heap@PAHHH@std@@YAXPAHHHH@Z PROC		; std::_Push_heap<int *,int,int>, COMDAT
; __First$ = esi
; __Hole$ = ecx
; __Val$ = edi

; 1971 : 	for (_Diff _Idx = (_Hole - 1) / 2;

	lea	eax, DWORD PTR [ecx-1]
	cdq
	sub	eax, edx
	push	ebx
	mov	ebx, DWORD PTR __Top$[esp]
	sar	eax, 1

; 1972 : 		_Top < _Hole && _DEBUG_LT(*(_First + _Idx), _Val);
; 1973 : 		_Idx = (_Hole - 1) / 2)

	cmp	ebx, ecx
	jge	SHORT $LN9@Push_heap
$LL3@Push_heap:
	mov	edx, DWORD PTR [esi+eax*4]
	cmp	edx, edi
	jge	SHORT $LN9@Push_heap

; 1974 : 		{	// move _Hole up to parent
; 1975 : 		*(_First + _Hole) = *(_First + _Idx);

	mov	DWORD PTR [esi+ecx*4], edx

; 1976 : 		_Hole = _Idx;

	mov	ecx, eax
	dec	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	ebx, ecx
	jl	SHORT $LL3@Push_heap
$LN9@Push_heap:

; 1977 : 		}
; 1978 : 
; 1979 : 	*(_First + _Hole) = _Val;	// drop _Val into final hole

	mov	DWORD PTR [esi+ecx*4], edi
	pop	ebx

; 1980 : 	}

	ret	0
??$_Push_heap@PAHHH@std@@YAXPAHHHH@Z ENDP		; std::_Push_heap<int *,int,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<int *,int *,std::allocator<int> >, COMDAT
; __First$ = ecx
; __Count$ = eax

; 144  : 	_DEBUG_RANGE(_First, _Last);
; 145  : 	_DEBUG_POINTER(_Dest);
; 146  : 	size_t _Count = (size_t)(_Last - _First);
; 147  : 	_FwdIt _Result = _Dest + _Count;
; 148  : 	if (_Count > 0)
; 149  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 150  : 	return _Result;

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 151  : 	}

	ret	0
??$_Uninit_copy@PAHPAHV?$allocator@H@std@@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3170 : 	{	// copy _Val _Count times through [_First, ...)

	mov	ecx, DWORD PTR __First$[esp-4]

; 3171 : 	for (; 0 < _Count; --_Count, ++_First)

	test	eax, eax
	jbe	SHORT $LN1@Fill_n
	push	esi
	npad	7
$LL3@Fill_n:

; 3172 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL3@Fill_n
	pop	esi
$LN1@Fill_n:

; 3173 : 	}

	ret	0
??$_Fill_n@PAHIH@std@@YAXPAHIABHU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$_Adjust_heap@PAHHH@std@@YAXPAHHHH@Z
_TEXT	SEGMENT
__Hole$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Adjust_heap@PAHHH@std@@YAXPAHHHH@Z PROC		; std::_Adjust_heap<int *,int,int>, COMDAT
; __First$ = ecx
; __Bottom$ = edx

; 2053 : 	{	// percolate _Hole to _Bottom, then push _Val, using operator<

	push	ebx
	mov	ebx, DWORD PTR __Val$[esp]
	push	esi
	mov	esi, DWORD PTR __Hole$[esp+4]

; 2054 : 	_Diff _Top = _Hole;
; 2055 : 	_Diff _Idx = 2 * _Hole + 2;

	lea	eax, DWORD PTR [esi+esi+2]

; 2056 : 
; 2057 : 	for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)

	cmp	eax, edx
	push	edi
	mov	edi, esi
	jge	SHORT $LN19@Adjust_hea
	push	ebp
$LL5@Adjust_hea:

; 2058 : 		{	// move _Hole down to larger child
; 2059 : 		if (_DEBUG_LT(*(_First + _Idx), *(_First + (_Idx - 1))))

	mov	ebp, DWORD PTR [ecx+eax*4]
	cmp	ebp, DWORD PTR [ecx+eax*4-4]
	jge	SHORT $LN2@Adjust_hea

; 2060 : 			--_Idx;

	dec	eax
$LN2@Adjust_hea:

; 2061 : 		*(_First + _Hole) = *(_First + _Idx), _Hole = _Idx;

	mov	ebp, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [ecx+esi*4], ebp
	mov	esi, eax
	lea	eax, DWORD PTR [eax+eax+2]
	cmp	eax, edx
	jl	SHORT $LL5@Adjust_hea
	pop	ebp
$LN19@Adjust_hea:

; 2062 : 		}
; 2063 : 
; 2064 : 	if (_Idx == _Bottom)

	jne	SHORT $LN1@Adjust_hea

; 2065 : 		{	// only child at bottom, move _Hole down to it
; 2066 : 		*(_First + _Hole) = *(_First + (_Bottom - 1));

	mov	eax, DWORD PTR [ecx+edx*4-4]
	mov	DWORD PTR [ecx+esi*4], eax

; 2067 : 		_Hole = _Bottom - 1;

	lea	esi, DWORD PTR [edx-1]
$LN1@Adjust_hea:

; 2068 : 		}
; 2069 : 	std::_Push_heap(_First, _Hole, _Top, _Val);

	lea	eax, DWORD PTR [esi-1]
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	edi, esi
	jge	SHORT $LN18@Adjust_hea
	npad	7
$LL10@Adjust_hea:
	mov	edx, DWORD PTR [ecx+eax*4]
	cmp	edx, ebx
	jge	SHORT $LN18@Adjust_hea
	mov	DWORD PTR [ecx+esi*4], edx
	mov	esi, eax
	dec	eax
	cdq
	sub	eax, edx
	sar	eax, 1
	cmp	edi, esi
	jl	SHORT $LL10@Adjust_hea
$LN18@Adjust_hea:
	pop	edi
	mov	DWORD PTR [ecx+esi*4], ebx
	pop	esi
	pop	ebx

; 2070 : 	}

	ret	0
??$_Adjust_heap@PAHHH@std@@YAXPAHHHH@Z ENDP		; std::_Adjust_heap<int *,int,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$swap@H@std@@YAXAAH0@Z
_TEXT	SEGMENT
??$swap@H@std@@YAXAAH0@Z PROC				; std::swap<int>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 18   : 	if (&_Left != &_Right)

	cmp	ecx, eax
	je	SHORT $LN1@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [ecx]
	push	esi

; 21   : 
; 22   : 		_Left = _Right;

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], esi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [eax], edx
	pop	esi
$LN1@swap:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@H@std@@YAXAAH0@Z ENDP				; std::swap<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEPBU?$pair@_K_K@2@XZ
_TEXT	SEGMENT
?_Checked_iterator_base@?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEPBU?$pair@_K_K@2@XZ PROC ; std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Checked_iterator_base, COMDAT
; _this$ = eax

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEPBU?$pair@_K_K@2@XZ ENDP ; std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Checked_iterator_base
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEPAU?$pair@_K_K@2@XZ
_TEXT	SEGMENT
?_Checked_iterator_base@?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEPAU?$pair@_K_K@2@XZ PROC ; std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Checked_iterator_base, COMDAT
; _this$ = eax

; 305  : 		return this->_Myptr;

	mov	eax, DWORD PTR [eax+4]

; 306  : 	}

	ret	0
?_Checked_iterator_base@?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEPAU?$pair@_K_K@2@XZ ENDP ; std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Checked_iterator_base
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAU?$pair@_K_K@std@@PAU12@Uforward_iterator_tag@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Copy_backward_opt@PAU?$pair@_K_K@std@@PAU12@Uforward_iterator_tag@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::forward_iterator_tag>, COMDAT
; __Last$ = ecx
; __Dest$ = eax

; 2647 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	mov	edx, DWORD PTR __First$[esp-4]

; 2648 : 	_DEBUG_RANGE(_First, _Last);
; 2649 : 	while (_First != _Last)

	cmp	edx, ecx
	je	SHORT $LN1@Copy_backw
	push	esi
	npad	7
$LL2@Copy_backw:

; 2650 : 		*--_Dest = *--_Last;

	mov	esi, DWORD PTR [ecx-16]
	sub	ecx, 16					; 00000010H
	sub	eax, 16					; 00000010H
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	cmp	ecx, edx
	jne	SHORT $LL2@Copy_backw
	pop	esi
$LN1@Copy_backw:

; 2651 : 	return (_Dest);
; 2652 : 	}

	ret	0
??$_Copy_backward_opt@PAU?$pair@_K_K@std@@PAU12@Uforward_iterator_tag@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z
_TEXT	SEGMENT
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z PROC ; std::_Iter_cat<int *>, COMDAT
; ___$ReturnUdt$ = eax

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);
; 955  : 	}

	ret	0
??$_Iter_cat@PAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH@Z ENDP ; std::_Iter_cat<int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBU?$pair@_K_K@0@AAV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBU?$pair@_K_K@0@AAV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >,std::_Different_checked_iterator_base_type_tag>, COMDAT
; __It$ = eax

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR [eax+4]

; 1140 : 	}

	ret	0
??$_Checked_base@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBU?$pair@_K_K@0@AAV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAU?$pair@_K_K@0@AAV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@V?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAU?$pair@_K_K@0@AAV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >,std::_Different_checked_iterator_base_type_tag>, COMDAT
; __It$ = eax

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR [eax+4]

; 1140 : 	}

	ret	0
??$_Checked_base@V?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAU?$pair@_K_K@0@AAV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$_Make_heap@PAHHH@std@@YAXPAH000@Z
_TEXT	SEGMENT
??$_Make_heap@PAHHH@std@@YAXPAH000@Z PROC		; std::_Make_heap<int *,int,int>, COMDAT
; __First$ = edi
; __Last$ = eax

; 2163 : 	_Diff _Bottom = _Last - _First;

	sub	eax, edi
	sar	eax, 2
	push	ebx
	mov	ebx, eax

; 2164 : 
; 2165 : 	for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )

	cdq
	sub	eax, edx
	push	esi
	mov	esi, eax
	sar	esi, 1
	test	esi, esi
	jle	SHORT $LN1@Make_heap
$LL2@Make_heap:

; 2166 : 		{	// reheap top half, bottom to top
; 2167 : 		--_Hole;
; 2168 : 		std::_Adjust_heap(_First, _Hole, _Bottom,
; 2169 : 			_Ty(*(_First + _Hole)));

	mov	eax, DWORD PTR [edi+esi*4-4]
	dec	esi
	push	eax
	push	esi
	mov	edx, ebx
	mov	ecx, edi
	call	??$_Adjust_heap@PAHHH@std@@YAXPAHHHH@Z	; std::_Adjust_heap<int *,int,int>
	add	esp, 8
	test	esi, esi
	jg	SHORT $LL2@Make_heap
$LN1@Make_heap:
	pop	esi
	pop	ebx

; 2170 : 		}
; 2171 : 	}

	ret	0
??$_Make_heap@PAHHH@std@@YAXPAH000@Z ENDP		; std::_Make_heap<int *,int,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Val_type@PAH@std@@YAPAHPAH@Z
_TEXT	SEGMENT
??$_Val_type@PAH@std@@YAPAHPAH@Z PROC			; std::_Val_type<int *>, COMDAT

; 1740 : 	return (0);

	xor	eax, eax

; 1741 : 	}

	ret	0
??$_Val_type@PAH@std@@YAPAHPAH@Z ENDP			; std::_Val_type<int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Dist_type@PAH@std@@YAPAHPAH@Z
_TEXT	SEGMENT
??$_Dist_type@PAH@std@@YAPAHPAH@Z PROC			; std::_Dist_type<int *>, COMDAT

; 1805 : 	return (0);

	xor	eax, eax

; 1806 : 	}

	ret	0
??$_Dist_type@PAH@std@@YAPAHPAH@Z ENDP			; std::_Dist_type<int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$iter_swap@PAHPAH@std@@YAXPAH0@Z
_TEXT	SEGMENT
??$iter_swap@PAHPAH@std@@YAXPAH0@Z PROC			; std::iter_swap<int *,int *>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 592  : 	std::swap(*_Left, *_Right);

	cmp	ecx, eax
	je	SHORT $LN3@iter_swap
	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [eax], edx
	pop	esi
$LN3@iter_swap:

; 593  : 	}

	ret	0
??$iter_swap@PAHPAH@std@@YAXPAH0@Z ENDP			; std::iter_swap<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@PAHPAH@std@@QAE@ABQAH0@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@PAHPAH@std@@QAE@ABQAH0@Z PROC			; std::pair<int *,int *>::pair<int *,int *>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 42   : 		{	// construct from specified values

	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 43   : 		}

	ret	4
??0?$pair@PAHPAH@std@@QAE@ABQAH0@Z ENDP			; std::pair<int *,int *>::pair<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEPAHXZ
_TEXT	SEGMENT
?_Checked_iterator_base@?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEPAHXZ PROC ; std::_Vector_iterator<int,std::allocator<int> >::_Checked_iterator_base, COMDAT
; _this$ = eax

; 305  : 		return this->_Myptr;

	mov	eax, DWORD PTR [eax+4]

; 306  : 	}

	ret	0
?_Checked_iterator_base@?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEPAHXZ ENDP ; std::_Vector_iterator<int,std::allocator<int> >::_Checked_iterator_base
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@U?$pair@_K_K@std@@@std@@YAXPAU?$pair@_K_K@0@@Z
_TEXT	SEGMENT
??$_Destroy@U?$pair@_K_K@std@@@std@@YAXPAU?$pair@_K_K@0@@Z PROC ; std::_Destroy<std::pair<unsigned __int64,unsigned __int64> >, COMDAT

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	ret	0
??$_Destroy@U?$pair@_K_K@std@@@std@@YAXPAU?$pair@_K_K@0@@Z ENDP ; std::_Destroy<std::pair<unsigned __int64,unsigned __int64> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Off$ = eax
; __Result$ = esi

; 2673 : 
; 2674 :  #if _HAS_ITERATOR_DEBUGGING
; 2675 : 	_DEBUG_RANGE(_First, _Last);
; 2676 : 	if (_First != _Last)
; 2677 : 		_DEBUG_POINTER(_Dest);
; 2678 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2679 : 
; 2680 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2681 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2682 : 	 * the memmove
; 2683 : 	 */
; 2684 : 	_OutIt _Result = _Dest - _Off;
; 2685 : 	if (_Off > 0)
; 2686 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H

; 2687 : 	return _Result;

	mov	eax, esi

; 2688 : 	}

	ret	0
??$_Copy_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<int *,int *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAH@std@@YAPAHAAPAHU_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAH@std@@YAPAHAAPAHU_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<int *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	ret	0
??$_Checked_base@PAH@std@@YAPAHAAPAHU_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAU?$pair@_K_K@std@@PAU12@Uforward_iterator_tag@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Copy_opt@PAU?$pair@_K_K@std@@PAU12@Uforward_iterator_tag@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::forward_iterator_tag>, COMDAT
; __Last$ = edx
; __Dest$ = eax

; 2443 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	mov	ecx, DWORD PTR __First$[esp-4]

; 2444 : 	_DEBUG_RANGE(_First, _Last);
; 2445 : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	ecx, edx
	je	SHORT $LN1@Copy_opt
	push	esi
	npad	7
$LL3@Copy_opt:

; 2446 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	add	ecx, 16					; 00000010H
	add	eax, 16					; 00000010H
	cmp	ecx, edx
	jne	SHORT $LL3@Copy_opt
	pop	esi
$LN1@Copy_opt:

; 2447 : 	return (_Dest);
; 2448 : 	}

	ret	0
??$_Copy_opt@PAU?$pair@_K_K@std@@PAU12@Uforward_iterator_tag@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::forward_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAU?$pair@_K_K@std@@@std@@YAPAU?$pair@_K_K@0@AAPAU10@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@PAU?$pair@_K_K@std@@@std@@YAPAU?$pair@_K_K@0@AAPAU10@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::pair<unsigned __int64,unsigned __int64> *>, COMDAT
; __It$ = eax

; 1147 : 		return _It;

	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	ret	0
??$_Checked_base@PAU?$pair@_K_K@std@@@std@@YAPAU?$pair@_K_K@0@AAPAU10@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::pair<unsigned __int64,unsigned __int64> *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@PAU?$pair@_K_K@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@0@AAPAU?$pair@_K_K@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@PAU?$pair@_K_K@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@0@AAPAU?$pair@_K_K@0@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >,std::pair<unsigned __int64,unsigned __int64> *>, COMDAT

; 1483 : 	{

	push	ecx

; 1484 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1485 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1486 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@PAU?$pair@_K_K@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@0@AAPAU?$pair@_K_K@0@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >,std::pair<unsigned __int64,unsigned __int64> *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@@std@@YAPBU?$pair@_K_K@0@AAV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@0@@Z
_TEXT	SEGMENT
??$_Checked_base@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@@std@@YAPBU?$pair@_K_K@0@AAV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > > >, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax+4]

; 1166 : 	}

	ret	0
??$_Checked_base@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@@std@@YAPBU?$pair@_K_K@0@AAV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@@std@@YAPAU?$pair@_K_K@0@AAV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@0@@Z
_TEXT	SEGMENT
??$_Checked_base@V?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@@std@@YAPAU?$pair@_K_K@0@AAV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@0@@Z PROC ; std::_Checked_base<std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > > >, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax+4]

; 1166 : 	}

	ret	0
??$_Checked_base@V?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@@std@@YAPAU?$pair@_K_K@0@AAV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@0@@Z ENDP ; std::_Checked_base<std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAHAAV?$_Vector_iterator@HV?$allocator@H@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Checked_base@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAHAAV?$_Vector_iterator@HV?$allocator@H@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_iterator<int,std::allocator<int> >,std::_Different_checked_iterator_base_type_tag>, COMDAT
; __It$ = eax

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR [eax+4]

; 1140 : 	}

	ret	0
??$_Checked_base@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPAHAAV?$_Vector_iterator@HV?$allocator@H@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_iterator<int,std::allocator<int> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U?$pair@_K_K@std@@@std@@QAEXPAU?$pair@_K_K@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@U?$pair@_K_K@std@@@std@@QAEXPAU?$pair@_K_K@2@@Z PROC ; std::allocator<std::pair<unsigned __int64,unsigned __int64> >::destroy, COMDAT

; 160  : 		_Destroy(_Ptr);
; 161  : 		}

	ret	0
?destroy@?$allocator@U?$pair@_K_K@std@@@std@@QAEXPAU?$pair@_K_K@2@@Z ENDP ; std::allocator<std::pair<unsigned __int64,unsigned __int64> >::destroy
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z PROC ; std::_Move_cat<int *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAH@std@@YA?AU_Undefined_move_tag@0@ABQAH@Z ENDP ; std::_Move_cat<int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::_Fill<int *,int>, COMDAT
; __First$ = eax
; __Last$ = edx

; 3131 : 	_DEBUG_RANGE(_First, _Last);
; 3132 : 	for (; _First != _Last; ++_First)

	cmp	eax, edx
	je	SHORT $LN1@Fill
	mov	ecx, DWORD PTR __Val$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	npad	6
$LL3@Fill:

; 3133 : 		*_First = _Val;

	mov	DWORD PTR [eax], ecx
	add	eax, 4
	cmp	eax, edx
	jne	SHORT $LL3@Fill
$LN1@Fill:

; 3134 : 	}

	ret	0
??$_Fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::_Fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 242  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAU?$pair@_K_K@std@@@std@@YA?AU_Undefined_move_tag@0@ABQAU?$pair@_K_K@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Move_cat@PAU?$pair@_K_K@std@@@std@@YA?AU_Undefined_move_tag@0@ABQAU?$pair@_K_K@0@@Z PROC ; std::_Move_cat<std::pair<unsigned __int64,unsigned __int64> *>, COMDAT

; 1200 : 	{

	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1203 : 	}

	pop	ecx
	ret	0
??$_Move_cat@PAU?$pair@_K_K@std@@@std@@YA?AU_Undefined_move_tag@0@ABQAU?$pair@_K_K@0@@Z ENDP ; std::_Move_cat<std::pair<unsigned __int64,unsigned __int64> *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Fill@PAU?$pair@_K_K@std@@U12@@std@@YAXPAU?$pair@_K_K@0@0ABU10@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$_Fill@PAU?$pair@_K_K@std@@U12@@std@@YAXPAU?$pair@_K_K@0@0ABU10@@Z PROC ; std::_Fill<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> >, COMDAT
; __Last$ = edx
; __Val$ = ecx

; 3130 : 	{	// copy _Val through [_First, _Last)

	mov	eax, DWORD PTR __First$[esp-4]

; 3131 : 	_DEBUG_RANGE(_First, _Last);
; 3132 : 	for (; _First != _Last; ++_First)

	cmp	eax, edx
	je	SHORT $LN1@Fill@2
	push	esi
	npad	7
$LL3@Fill@2:

; 3133 : 		*_First = _Val;

	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	add	eax, 16					; 00000010H
	cmp	eax, edx
	jne	SHORT $LL3@Fill@2
	pop	esi
$LN1@Fill@2:

; 3134 : 	}

	ret	0
??$_Fill@PAU?$pair@_K_K@std@@U12@@std@@YAXPAU?$pair@_K_K@0@0ABU10@@Z ENDP ; std::_Fill<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Result$ = 12						; size = 4
??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>, COMDAT
; __First$ = ecx
; __Off$ = eax

; 2469 : 
; 2470 :  #if _HAS_ITERATOR_DEBUGGING
; 2471 : 	_DEBUG_RANGE(_First, _Last);
; 2472 : 	if (_First != _Last)
; 2473 : 		_DEBUG_POINTER(_Dest);
; 2474 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2475 : 
; 2476 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move
; 2477 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2478 : 	_OutIt _Result = _Dest + _Off;
; 2479 : 	if (_Off > 0)
; 2480 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	edx, DWORD PTR __Dest$[esp-4]
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	push	eax
	push	edx
	call	_memmove_s

; 2481 : 	return _Result;

	mov	eax, DWORD PTR __Result$[esp+12]
	add	esp, 16					; 00000010H

; 2482 : 	}

	ret	0
??$_Copy_opt@PAHPAHUrandom_access_iterator_tag@std@@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<int *,int *,std::random_access_iterator_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z PROC ; std::_Ptr_cat<int *,int *>, COMDAT

; 1483 : 	{

	push	ecx

; 1484 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1485 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1486 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAHPAH@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAH0@Z ENDP ; std::_Ptr_cat<int *,int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z
_TEXT	SEGMENT
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z PROC ; std::_Iter_random<int *,int *>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@PAHPAH@std@@YA?AUrandom_access_iterator_tag@0@ABQAH0@Z ENDP ; std::_Iter_random<int *,int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAH@std@@YAPAHAAPAH@Z
_TEXT	SEGMENT
??$_Checked_base@PAH@std@@YAPAHAAPAH@Z PROC		; std::_Checked_base<int *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax]

; 1166 : 	}

	ret	0
??$_Checked_base@PAH@std@@YAPAHAAPAH@Z ENDP		; std::_Checked_base<int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@U?$pair@_K_K@std@@@std@@@std@@YAXPAU?$pair@_K_K@0@0AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$allocator@U?$pair@_K_K@std@@@std@@@std@@YAXPAU?$pair@_K_K@0@0AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<std::pair<unsigned __int64,unsigned __int64> > >, COMDAT

; 233  : 	for (; _First != _Last; ++_First)
; 234  : 		_Al.destroy(_First);
; 235  : 	}

	ret	0
??$_Destroy_range@V?$allocator@U?$pair@_K_K@std@@@std@@@std@@YAXPAU?$pair@_K_K@0@0AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU?$pair@_K_K@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@_K_K@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAU?$pair@_K_K@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@_K_K@0@0@Z PROC ; std::_Ptr_cat<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *>, COMDAT

; 1483 : 	{

	push	ecx

; 1484 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1485 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 1486 : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAU?$pair@_K_K@std@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU?$pair@_K_K@0@0@Z ENDP ; std::_Ptr_cat<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAU?$pair@_K_K@std@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU?$pair@_K_K@0@0@Z
_TEXT	SEGMENT
??$_Iter_random@PAU?$pair@_K_K@std@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU?$pair@_K_K@0@0@Z PROC ; std::_Iter_random<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *>, COMDAT
; ___$ReturnUdt$ = eax

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);
; 998  : 	}

	ret	0
??$_Iter_random@PAU?$pair@_K_K@std@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU?$pair@_K_K@0@0@Z ENDP ; std::_Iter_random<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAU?$pair@_K_K@std@@@std@@YAPAU?$pair@_K_K@0@AAPAU10@@Z
_TEXT	SEGMENT
??$_Checked_base@PAU?$pair@_K_K@std@@@std@@YAPAU?$pair@_K_K@0@AAPAU10@@Z PROC ; std::_Checked_base<std::pair<unsigned __int64,unsigned __int64> *>, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax]

; 1166 : 	}

	ret	0
??$_Checked_base@PAU?$pair@_K_K@std@@@std@@YAPAU?$pair@_K_K@0@AAPAU10@@Z ENDP ; std::_Checked_base<std::pair<unsigned __int64,unsigned __int64> *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAPAHAAV?$_Vector_iterator@HV?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
??$_Checked_base@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAPAHAAV?$_Vector_iterator@HV?$allocator@H@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_iterator<int,std::allocator<int> > >, COMDAT
; __It$ = eax

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	mov	eax, DWORD PTR [eax+4]

; 1166 : 	}

	ret	0
??$_Checked_base@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAPAHAAV?$_Vector_iterator@HV?$allocator@H@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_iterator<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0H@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
??$?0H@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@H@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><int>, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0H@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@H@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$fill@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$fill@PAHH@std@@YAXPAH0ABH@Z PROC			; std::fill<int *,int>, COMDAT
; __First$ = eax
; __Last$ = ecx

; 3161 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	cmp	eax, ecx
	je	SHORT $LN11@fill
	mov	edx, DWORD PTR __Val$[esp-4]
	mov	edx, DWORD PTR [edx]
	npad	6
$LL13@fill:
	mov	DWORD PTR [eax], edx
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL13@fill
$LN11@fill:

; 3162 : 	}

	ret	0
??$fill@PAHH@std@@YAXPAH0ABH@Z ENDP			; std::fill<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@_K_K@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@_K_K@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@_K_K@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@_K_K@std@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned __int64,unsigned __int64> >, COMDAT
; _this$ = eax

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	ret	0
??$?0U?$pair@_K_K@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@_K_K@std@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned __int64,unsigned __int64> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$fill@PAU?$pair@_K_K@std@@U12@@std@@YAXPAU?$pair@_K_K@0@0ABU10@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$fill@PAU?$pair@_K_K@std@@U12@@std@@YAXPAU?$pair@_K_K@0@0ABU10@@Z PROC ; std::fill<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> >, COMDAT
; __Last$ = edx
; __Val$ = ecx

; 3160 : 	{	// copy _Val through [_First, _Last)

	mov	eax, DWORD PTR __First$[esp-4]

; 3161 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	cmp	eax, edx
	je	SHORT $LN11@fill@2
	push	esi
	npad	7
$LL13@fill@2:
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
	add	eax, 16					; 00000010H
	cmp	eax, edx
	jne	SHORT $LL13@fill@2
	pop	esi
$LN11@fill@2:

; 3162 : 	}

	ret	0
??$fill@PAU?$pair@_K_K@std@@U12@@std@@YAXPAU?$pair@_K_K@0@0ABU10@@Z ENDP ; std::fill<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z PROC	; stdext::unchecked_copy<int *,int *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 3579 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3580 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN18@unchecked_
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@unchecked_:
	mov	eax, esi
	pop	esi

; 3581 : 	}

	ret	0
??$unchecked_copy@PAHPAH@stdext@@YAPAHPAH00@Z ENDP	; stdext::unchecked_copy<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@U?$pair@_K_K@std@@@std@@@std@@YAXPAU?$pair@_K_K@0@0AAV?$allocator@U?$pair@_K_K@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@V?$allocator@U?$pair@_K_K@std@@@std@@@std@@YAXPAU?$pair@_K_K@0@0AAV?$allocator@U?$pair@_K_K@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::pair<unsigned __int64,unsigned __int64> > >, COMDAT

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 226  : 	}

	ret	0
??$_Destroy_range@V?$allocator@U?$pair@_K_K@std@@@std@@@std@@YAXPAU?$pair@_K_K@0@0AAV?$allocator@U?$pair@_K_K@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$swap@PAU?$pair@_K_K@std@@@std@@YAXAAPAU?$pair@_K_K@0@0@Z
_TEXT	SEGMENT
??$swap@PAU?$pair@_K_K@std@@@std@@YAXAAPAU?$pair@_K_K@0@0@Z PROC ; std::swap<std::pair<unsigned __int64,unsigned __int64> *>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 18   : 	if (&_Left != &_Right)

	cmp	ecx, eax
	je	SHORT $LN1@swap@2

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [ecx]
	push	esi

; 21   : 
; 22   : 		_Left = _Right;

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], esi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [eax], edx
	pop	esi
$LN1@swap@2:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@PAU?$pair@_K_K@std@@@std@@YAXAAPAU?$pair@_K_K@0@0@Z ENDP ; std::swap<std::pair<unsigned __int64,unsigned __int64> *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?8U?$pair@_K_K@std@@U01@@std@@YA_NABV?$allocator@U?$pair@_K_K@std@@@0@0@Z
_TEXT	SEGMENT
??$?8U?$pair@_K_K@std@@U01@@std@@YA_NABV?$allocator@U?$pair@_K_K@std@@@0@0@Z PROC ; std::operator==<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >, COMDAT

; 175  : 	return (true);

	mov	al, 1

; 176  : 	}

	ret	0
??$?8U?$pair@_K_K@std@@U01@@std@@YA_NABV?$allocator@U?$pair@_K_K@std@@@0@0@Z ENDP ; std::operator==<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >
; Function compile flags: /Ogtpy
; File d:\-=svn=-\svplayer\src\subtitles\separablefilter.h
_TEXT	ENDS
;	COMDAT ??$SeparableFilterY@$01@@YAXPAE0HHHPAHHH@Z
_TEXT	SEGMENT
_y$133079 = -32						; size = 4
tv233 = -28						; size = 4
_accum$133083 = -24					; size = 4
_in$133077 = -20					; size = 4
tv434 = -16						; size = 4
tv286 = -12						; size = 4
tv496 = -8						; size = 4
tv441 = -4						; size = 4
_dst$ = 8						; size = 4
_height$ = 12						; size = 4
_stride$ = 16						; size = 4
_kernel$ = 20						; size = 4
_kernel_size$ = 24					; size = 4
_divisor$ = 28						; size = 4
??$SeparableFilterY@$01@@YAXPAE0HHHPAHHH@Z PROC		; SeparableFilterY<2>, COMDAT
; _src$ = edx
; _width$ = eax

; 66   : {

	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, DWORD PTR _stride$[esp+32]
	push	ebp
	mov	ebp, DWORD PTR _kernel_size$[esp+36]
	push	esi

; 67   : #pragma omp parallel for
; 68   : 	width *= PixelDist;

	add	eax, eax

; 69   : 	for (int  x = 0; x < width; x+=PixelDist) {

	xor	esi, esi
	cmp	eax, esi
	jle	$LN11@SeparableF
	mov	ecx, DWORD PTR _dst$[esp+40]
	dec	eax
	sub	ecx, edx
	shr	eax, 1
	inc	eax
	mov	DWORD PTR tv434[esp+44], edx
	mov	DWORD PTR tv441[esp+44], ecx
	mov	DWORD PTR tv496[esp+44], eax
	push	edi
$LL13@SeparableF:

; 70   : 		unsigned char *in = src + x;
; 71   : 		unsigned char *out = dst + x;
; 72   : 		for (int y = 0; y < height; y++) {

	mov	edi, DWORD PTR _height$[esp+44]
	cmp	edi, esi
	mov	edx, DWORD PTR tv434[esp+48]
	mov	DWORD PTR _in$133077[esp+48], edx
	mov	DWORD PTR _y$133079[esp+48], esi
	jle	$LN12@SeparableF
	npad	7
$LL10@SeparableF:

; 73   : 			int accum = 0;
; 74   : 			for (int k = 0; k < kernel_size; k++) {

	cmp	ebp, esi
	mov	DWORD PTR _accum$133083[esp+48], esi
	jle	SHORT $LN5@SeparableF
	mov	eax, ebp
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	ecx, eax
	mov	eax, edi
	imul	eax, ebx
	mov	DWORD PTR tv286[esp+48], eax
	mov	eax, ebp
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _y$133079[esp+48]
	sar	eax, 1
	neg	ecx
	mov	DWORD PTR tv233[esp+48], ecx
	sub	edi, eax
	sub	edx, eax
	imul	ecx, ebx
$LL22@SeparableF:

; 75   : 				int yofs = k - kernel_size/2;

	mov	ebx, DWORD PTR tv233[esp+48]
	mov	eax, ecx

; 76   : 				if (y+yofs < 0) yofs += height;

	test	edx, edx
	jge	SHORT $LN4@SeparableF
	add	eax, DWORD PTR tv286[esp+48]
	mov	ebx, edi
$LN4@SeparableF:

; 77   : 				if (y+yofs >= height) yofs -= height;

	mov	ebp, DWORD PTR _y$133079[esp+48]
	add	ebx, ebp
	cmp	ebx, DWORD PTR _height$[esp+44]
	jl	SHORT $LN23@SeparableF
	sub	eax, DWORD PTR tv286[esp+48]
$LN23@SeparableF:

; 78   : 				accum += (int)(in[yofs*stride] * kernel[k]);

	mov	ebx, DWORD PTR _in$133077[esp+48]
	movzx	eax, BYTE PTR [eax+ebx]
	mov	ebx, DWORD PTR _kernel$[esp+44]
	imul	eax, DWORD PTR [ebx+esi*4]
	mov	ebx, DWORD PTR _stride$[esp+44]
	mov	ebp, DWORD PTR _kernel_size$[esp+44]
	add	DWORD PTR _accum$133083[esp+48], eax
	inc	DWORD PTR tv233[esp+48]
	inc	esi
	add	ecx, ebx
	inc	edx
	inc	edi
	cmp	esi, ebp
	jl	SHORT $LL22@SeparableF
	mov	ecx, DWORD PTR tv441[esp+48]
	mov	edi, DWORD PTR _height$[esp+44]
	xor	esi, esi
$LN5@SeparableF:

; 79   : 			}
; 80   : 			accum /= divisor;

	mov	eax, DWORD PTR _accum$133083[esp+48]
	cdq
	idiv	DWORD PTR _divisor$[esp+44]

; 81   : 			if (accum > 255) accum = 255;

	cmp	eax, 255				; 000000ffH
	jle	SHORT $LN2@SeparableF
	mov	eax, 255				; 000000ffH

; 82   : 			if (accum < 0) accum = 0;

	jmp	SHORT $LN1@SeparableF
$LN2@SeparableF:
	cmp	eax, esi
	jge	SHORT $LN1@SeparableF
	xor	eax, eax
$LN1@SeparableF:

; 83   : 			*out = (unsigned char)accum;

	mov	edx, DWORD PTR _in$133077[esp+48]
	mov	BYTE PTR [ecx+edx], al
	mov	eax, DWORD PTR _y$133079[esp+48]
	inc	eax

; 84   : 			in += stride;

	add	edx, ebx
	cmp	eax, edi
	mov	DWORD PTR _in$133077[esp+48], edx
	mov	DWORD PTR _y$133079[esp+48], eax
	jl	$LL10@SeparableF

; 70   : 		unsigned char *in = src + x;
; 71   : 		unsigned char *out = dst + x;
; 72   : 		for (int y = 0; y < height; y++) {

	mov	eax, DWORD PTR tv496[esp+48]
$LN12@SeparableF:

; 69   : 	for (int  x = 0; x < width; x+=PixelDist) {

	add	DWORD PTR tv434[esp+48], 2
	sub	eax, 1
	mov	DWORD PTR tv496[esp+48], eax
	jne	$LL13@SeparableF
	pop	edi
$LN11@SeparableF:
	pop	esi
	pop	ebp
	pop	ebx

; 85   : 			out += stride;
; 86   : 		}
; 87   : 	}
; 88   : }

	add	esp, 32					; 00000020H
	ret	0
??$SeparableFilterY@$01@@YAXPAE0HHHPAHHH@Z ENDP		; SeparableFilterY<2>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$SeparableFilterX@$01@@YAXPAE0HHHPAHHH@Z
_TEXT	SEGMENT
tv232 = -28						; size = 4
_accum$133060 = -24					; size = 4
_x$133056 = -20						; size = 4
_in$133054 = -16					; size = 4
tv437 = -12						; size = 4
tv488 = -8						; size = 4
tv446 = -4						; size = 4
_dst$ = 8						; size = 4
_width$ = 12						; size = 4
_stride$ = 16						; size = 4
_kernel$ = 20						; size = 4
_kernel_size$ = 24					; size = 4
_divisor$ = 28						; size = 4
??$SeparableFilterX@$01@@YAXPAE0HHHPAHHH@Z PROC		; SeparableFilterX<2>, COMDAT
; _src$ = ecx
; _height$ = eax

; 36   : {

	sub	esp, 28					; 0000001cH
	push	ebx
	mov	ebx, DWORD PTR _kernel_size$[esp+28]

; 37   : #pragma omp parallel for
; 38   : 	for (int y = 0; y < height; y++) {

	test	eax, eax
	jle	$LN11@SeparableF@2
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR _dst$[esp+40]
	mov	ebp, ecx
	sub	edi, ecx
	mov	DWORD PTR tv437[esp+44], ebp
	mov	DWORD PTR tv446[esp+44], edi
	mov	DWORD PTR tv488[esp+44], eax
	npad	9
$LL24@SeparableF@2:

; 39   : 		unsigned char *in = src + y*stride;
; 40   : 		unsigned char *out = dst + y*stride;
; 41   : 		for (int x = 0; x < width; x++) {

	xor	ecx, ecx
	cmp	DWORD PTR _width$[esp+40], ecx
	mov	DWORD PTR _in$133054[esp+44], ebp
	mov	DWORD PTR _x$133056[esp+44], ecx
	jle	$LN12@SeparableF@2
$LL23@SeparableF@2:

; 42   : 			int accum = 0;

	xor	esi, esi

; 43   : 			for (int k = 0; k < kernel_size; k++) {

	cmp	ebx, esi
	mov	DWORD PTR _accum$133060[esp+44], esi
	jle	SHORT $LN5@SeparableF@2
	mov	eax, ebx
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	edi, eax
	mov	eax, ebx
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR _width$[esp+40]
	sar	eax, 1
	neg	edi
	mov	DWORD PTR tv232[esp+44], edi
	sub	edx, eax
	sub	ecx, eax
	add	edi, edi
	npad	2
$LL22@SeparableF@2:

; 44   : 				int xofs = k - kernel_size/2;

	mov	ebx, DWORD PTR tv232[esp+44]
	mov	eax, edi

; 45   : 				if (x+xofs < 0) xofs += width;

	test	ecx, ecx
	jge	SHORT $LN4@SeparableF@2
	mov	ebp, DWORD PTR _width$[esp+40]
	add	ebp, ebp
	mov	ebx, edx
	add	eax, ebp
$LN4@SeparableF@2:

; 46   : 				if (x+xofs >= width) xofs -= width;

	mov	ebp, DWORD PTR _x$133056[esp+44]
	add	ebp, ebx
	mov	ebx, DWORD PTR _width$[esp+40]
	cmp	ebp, ebx
	jl	SHORT $LN3@SeparableF@2
	add	ebx, ebx
	sub	eax, ebx
$LN3@SeparableF@2:

; 47   : 				accum += (int)(in[xofs*PixelDist] * kernel[k]);

	mov	ebp, DWORD PTR _in$133054[esp+44]
	movzx	eax, BYTE PTR [eax+ebp]
	mov	ebx, DWORD PTR _kernel$[esp+40]
	imul	eax, DWORD PTR [ebx+esi*4]
	mov	ebx, DWORD PTR _kernel_size$[esp+40]
	add	DWORD PTR _accum$133060[esp+44], eax
	inc	DWORD PTR tv232[esp+44]
	inc	esi
	add	edi, 2
	inc	ecx
	inc	edx
	cmp	esi, ebx
	jl	SHORT $LL22@SeparableF@2
	mov	edi, DWORD PTR tv446[esp+44]
	mov	ecx, DWORD PTR _x$133056[esp+44]
$LN5@SeparableF@2:

; 48   : 			}
; 49   : 			accum /= divisor;

	mov	eax, DWORD PTR _accum$133060[esp+44]
	cdq
	idiv	DWORD PTR _divisor$[esp+40]

; 50   : 			if (accum > 255) accum = 255;

	cmp	eax, 255				; 000000ffH
	jle	SHORT $LN2@SeparableF@2
	mov	eax, 255				; 000000ffH

; 51   : 			if (accum < 0) accum = 0;

	jmp	SHORT $LN1@SeparableF@2
$LN2@SeparableF@2:
	test	eax, eax
	jge	SHORT $LN1@SeparableF@2
	xor	eax, eax
$LN1@SeparableF@2:

; 39   : 		unsigned char *in = src + y*stride;
; 40   : 		unsigned char *out = dst + y*stride;
; 41   : 		for (int x = 0; x < width; x++) {

	inc	ecx

; 52   : 			*out = (unsigned char)accum;

	mov	BYTE PTR [edi+ebp], al

; 53   : 			in+=PixelDist;

	add	ebp, 2
	cmp	ecx, DWORD PTR _width$[esp+40]
	mov	DWORD PTR _in$133054[esp+44], ebp
	mov	DWORD PTR _x$133056[esp+44], ecx
	jl	$LL23@SeparableF@2

; 39   : 		unsigned char *in = src + y*stride;
; 40   : 		unsigned char *out = dst + y*stride;
; 41   : 		for (int x = 0; x < width; x++) {

	mov	ebp, DWORD PTR tv437[esp+44]
$LN12@SeparableF@2:

; 37   : #pragma omp parallel for
; 38   : 	for (int y = 0; y < height; y++) {

	add	ebp, DWORD PTR _stride$[esp+40]
	sub	DWORD PTR tv488[esp+44], 1
	mov	DWORD PTR tv437[esp+44], ebp
	jne	$LL24@SeparableF@2
	pop	edi
	pop	esi
	pop	ebp
$LN11@SeparableF@2:
	pop	ebx

; 54   : 			out+=PixelDist;
; 55   : 		}
; 56   : 	}
; 57   : }

	add	esp, 28					; 0000001cH
	ret	0
??$SeparableFilterX@$01@@YAXPAE0HHHPAHHH@Z ENDP		; SeparableFilterX<2>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$max@_K@std@@YAAB_KAB_K0@Z
_TEXT	SEGMENT
??$max@_K@std@@YAAB_KAB_K0@Z PROC			; std::max<unsigned __int64>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 3358 : 	return (_DEBUG_LT(_Left, _Right) ? _Right : _Left);

	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+4]
	ja	SHORT $LN3@max
	jb	SHORT $LN4@max
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jb	SHORT $LN4@max
$LN3@max:
	mov	eax, ecx
$LN4@max:

; 3359 : 	}

	ret	0
??$max@_K@std@@YAAB_KAB_K0@Z ENDP			; std::max<unsigned __int64>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$?0_J_J@?$pair@_K_K@std@@QAE@ABU?$pair@_J_J@1@@Z
_TEXT	SEGMENT
??$?0_J_J@?$pair@_K_K@std@@QAE@ABU?$pair@_J_J@1@@Z PROC	; std::pair<unsigned __int64,unsigned __int64>::pair<unsigned __int64,unsigned __int64><__int64,__int64>, COMDAT
; _this$ = eax
; __Right$ = ecx

; 49   : 		{	// construct from compatible pair

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx

; 50   : 		}

	ret	0
??$?0_J_J@?$pair@_K_K@std@@QAE@ABU?$pair@_J_J@1@@Z ENDP	; std::pair<unsigned __int64,unsigned __int64>::pair<unsigned __int64,unsigned __int64><__int64,__int64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$swap@V_Aux_cont@std@@@std@@YAXAAV_Aux_cont@0@0@Z
_TEXT	SEGMENT
??$swap@V_Aux_cont@std@@@std@@YAXAAV_Aux_cont@0@0@Z PROC ; std::swap<std::_Aux_cont>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 18   : 	if (&_Left != &_Right)

	cmp	ecx, eax
	je	SHORT $LN1@swap@3

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [ecx]
	push	esi

; 21   : 
; 22   : 		_Left = _Right;

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], esi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [eax], edx
	pop	esi
$LN1@swap@3:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@V_Aux_cont@std@@@std@@YAXAAV_Aux_cont@0@0@Z ENDP ; std::swap<std::_Aux_cont>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$swap@PAV_Aux_cont@std@@@std@@YAXAAPAV_Aux_cont@0@0@Z
_TEXT	SEGMENT
??$swap@PAV_Aux_cont@std@@@std@@YAXAAPAV_Aux_cont@0@0@Z PROC ; std::swap<std::_Aux_cont *>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 18   : 	if (&_Left != &_Right)

	cmp	ecx, eax
	je	SHORT $LN1@swap@4

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [ecx]
	push	esi

; 21   : 
; 22   : 		_Left = _Right;

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], esi

; 23   : 		_Right = _Tmp;

	mov	DWORD PTR [eax], edx
	pop	esi
$LN1@swap@4:

; 24   : 		}
; 25   : 	}

	ret	0
??$swap@PAV_Aux_cont@std@@@std@@YAXAAPAV_Aux_cont@0@0@Z ENDP ; std::swap<std::_Aux_cont *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@H@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@H@std@@QBEIXZ PROC		; std::allocator<int>::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@H@std@@QBEIXZ ENDP		; std::allocator<int>::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXPAHI@Z
_TEXT	SEGMENT
?deallocate@?$allocator@H@std@@QAEXPAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@H@std@@QAEXPAHI@Z ENDP		; std::allocator<int>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@ABV01@@Z PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@H@std@@QAE@ABV01@@Z ENDP			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT

; 1124 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1125 : 		}

	ret	0
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@IAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@_K_K@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@_K_K@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<unsigned __int64,unsigned __int64> >::max_size, COMDAT

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 166  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 268435455				; 0fffffffH

; 167  : 		}

	ret	0
?max_size@?$allocator@U?$pair@_K_K@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned __int64,unsigned __int64> >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@_K_K@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@U?$pair@_K_K@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<unsigned __int64,unsigned __int64> >::allocator<std::pair<unsigned __int64,unsigned __int64> >, COMDAT
; _this$ = eax

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	ret	0
??0?$allocator@U?$pair@_K_K@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned __int64,unsigned __int64> >::allocator<std::pair<unsigned __int64,unsigned __int64> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = esi

; 1129 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN4@Tidy

; 1130 : 			{	// something to free, destroy and deallocate it
; 1131 : 
; 1132 :  #if _HAS_ITERATOR_DEBUGGING
; 1133 : 			this->_Orphan_all();
; 1134 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1135 : 
; 1136 : 			_Destroy(_Myfirst, _Mylast);
; 1137 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy:

; 1138 : 			}
; 1139 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0

; 1140 : 		}

	ret	0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@IAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	ret	0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = eax

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN3@capacity
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [eax+20]
	sub	eax, ecx
	sar	eax, 2

; 636  : 		}

	ret	0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U?$pair@_K_K@std@@@std@@QAEXPAU?$pair@_K_K@2@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@U?$pair@_K_K@std@@@std@@QAEXPAU?$pair@_K_K@2@I@Z PROC ; std::allocator<std::pair<unsigned __int64,unsigned __int64> >::deallocate, COMDAT
; __Ptr$ = eax

; 140  : 		::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 141  : 		}

	ret	0
?deallocate@?$allocator@U?$pair@_K_K@std@@@std@@QAEXPAU?$pair@_K_K@2@I@Z ENDP ; std::allocator<std::pair<unsigned __int64,unsigned __int64> >::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@_K_K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@_K_K@std@@@std@@QAE@XZ PROC	; std::allocator<std::pair<unsigned __int64,unsigned __int64> >::allocator<std::pair<unsigned __int64,unsigned __int64> >, COMDAT
; _this$ = eax

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	ret	0
??0?$allocator@U?$pair@_K_K@std@@@std@@QAE@XZ ENDP	; std::allocator<std::pair<unsigned __int64,unsigned __int64> >::allocator<std::pair<unsigned __int64,unsigned __int64> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXPAU?$pair@_K_K@2@0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXPAU?$pair@_K_K@2@0@Z PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Destroy, COMDAT

; 1124 : 		_Destroy_range(_First, _Last, this->_Alval);
; 1125 : 		}

	ret	0
?_Destroy@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXPAU?$pair@_K_K@2@0@Z ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::max_size, COMDAT

; 731  : 		return (this->_Alval.max_size());

	mov	eax, 268435455				; 0fffffffH

; 732  : 		}

	ret	0
?max_size@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::capacity, COMDAT
; _this$ = eax

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [eax+12]
	test	ecx, ecx
	jne	SHORT $LN3@capacity@2
	xor	eax, eax

; 636  : 		}

	ret	0
$LN3@capacity@2:

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [eax+20]
	sub	eax, ecx
	sar	eax, 4

; 636  : 		}

	ret	0
?capacity@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::capacity
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@_K_K@std@@QAE@AB_K0@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
??0?$pair@_K_K@std@@QAE@AB_K0@Z PROC			; std::pair<unsigned __int64,unsigned __int64>::pair<unsigned __int64,unsigned __int64>, COMDAT
; __Val1$ = edx
; __Val2$ = ecx

; 42   : 		{	// construct from specified values

	mov	eax, DWORD PTR _this$[esp-4]
	push	esi
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+12], ecx
	pop	esi

; 43   : 		}

	ret	4
??0?$pair@_K_K@std@@QAE@AB_K0@Z ENDP			; std::pair<unsigned __int64,unsigned __int64>::pair<unsigned __int64,unsigned __int64>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$pair@_J_J@std@@QAE@AB_J0@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
??0?$pair@_J_J@std@@QAE@AB_J0@Z PROC			; std::pair<__int64,__int64>::pair<__int64,__int64>, COMDAT
; __Val1$ = edx
; __Val2$ = ecx

; 42   : 		{	// construct from specified values

	mov	eax, DWORD PTR _this$[esp-4]
	push	esi
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+12], ecx
	pop	esi

; 43   : 		}

	ret	4
??0?$pair@_J_J@std@@QAE@AB_J0@Z ENDP			; std::pair<__int64,__int64>::pair<__int64,__int64>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?size@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::size, COMDAT
; _this$ = ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 4

; 727  : 		}

	ret	0
?size@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::size
; Function compile flags: /Ogtpy
; File d:\-=svn=-\svplayer\src\subtitles\rasterizer.cpp
_TEXT	ENDS
;	COMDAT ?safe_subtract@@YAKKK@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
_b$ = 12						; size = 4
?safe_subtract@@YAKKK@Z PROC				; safe_subtract, COMDAT

; 903  : {

	push	ebp
	mov	ebp, esp

; 904  : 	__m64 ap = _mm_cvtsi32_si64(a);
; 905  : 	__m64 bp = _mm_cvtsi32_si64(b);

	movd	mm1, DWORD PTR _b$[ebp]
	movd	mm0, DWORD PTR _a$[ebp]

; 906  : 	__m64 rp = _mm_subs_pu16(ap, bp);

	psubusw	mm0, mm1

; 907  : 	DWORD r = (DWORD)_mm_cvtsi64_si32(rp);

	movd	eax, mm0

; 908  : 	_mm_empty();

	emms

; 909  : 	return r;
; 910  : 	//return (b > a) ? 0 : a - b;
; 911  : }

	pop	ebp
	ret	0
?safe_subtract@@YAKKK@Z ENDP				; safe_subtract
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?pixmix2_sse2@@YAXPAKKKK@Z
_TEXT	SEGMENT
_shapealpha$ = 8					; size = 4
_clipalpha$ = 12					; size = 4
?pixmix2_sse2@@YAXPAKKKK@Z PROC				; pixmix2_sse2, COMDAT
; _dst$ = edx
; _color$ = ecx

; 881  : {

	push	ebp
	mov	ebp, esp
	and	esp, -16				; fffffff0H

; 882  : 	int alpha = (((shapealpha)*(clipalpha)*(color>>24))>>12)&0xff;

	mov	eax, ecx
	shr	eax, 24					; 00000018H
	imul	eax, DWORD PTR _shapealpha$[ebp]
	imul	eax, DWORD PTR _clipalpha$[ebp]
	sub	esp, 12					; 0000000cH
	push	esi

; 883  : 	color &= 0xffffff;
; 884  : 
; 885  : 	__m128i zero = _mm_setzero_si128();
; 886  : 	__m128i a = _mm_set1_epi32(((alpha+1) << 16) | (0x100 - alpha));
; 887  : 	__m128i d = _mm_unpacklo_epi8(_mm_cvtsi32_si128(*dst), zero);

	mov	esi, DWORD PTR [edx]
	shr	eax, 12					; 0000000cH
	and	ecx, 16777215				; 00ffffffH
	and	eax, 255				; 000000ffH
	movd	xmm0, esi

; 888  : 	__m128i s = _mm_unpacklo_epi8(_mm_cvtsi32_si128(color), zero);

	movd	xmm2, ecx

; 889  : 	__m128i r = _mm_unpacklo_epi16(d, s);
; 890  : 
; 891  : 	r = _mm_madd_epi16(r, a);
; 892  : 	r = _mm_srli_epi32(r, 8);

	lea	ecx, DWORD PTR [eax+1]
	mov	esi, 256				; 00000100H
	sub	esi, eax
	pxor	xmm1, xmm1
	punpcklbw xmm0, xmm1
	shl	ecx, 16					; 00000010H
	punpcklbw xmm2, xmm1
	or	ecx, esi
	punpcklwd xmm0, xmm2
	movd	xmm1, ecx
	pshufd	xmm1, xmm1, 0
	pmaddwd	xmm0, xmm1
	psrld	xmm0, 8

; 893  : 	r = _mm_packs_epi32(r, r);

	packssdw xmm0, xmm0

; 894  : 	r = _mm_packus_epi16(r, r);

	packuswb xmm0, xmm0

; 895  : 
; 896  : 	*dst = (DWORD)_mm_cvtsi128_si32(r);

	movd	eax, xmm0
	mov	DWORD PTR [edx], eax

; 897  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?pixmix2_sse2@@YAXPAKKKK@Z ENDP				; pixmix2_sse2
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?pixmix_sse2@@YAXPAKKK@Z
_TEXT	SEGMENT
_alpha$ = 8						; size = 4
?pixmix_sse2@@YAXPAKKK@Z PROC				; pixmix_sse2, COMDAT
; _dst$ = edx
; _color$ = ecx

; 862  : {

	push	ebp
	mov	ebp, esp
	and	esp, -16				; fffffff0H

; 863  : 	alpha = (((alpha) * (color>>24)) >> 6) & 0xff;

	mov	eax, ecx
	shr	eax, 24					; 00000018H
	imul	eax, DWORD PTR _alpha$[ebp]
	sub	esp, 12					; 0000000cH
	push	esi

; 864  : 	color &= 0xffffff;
; 865  : 
; 866  : 	__m128i zero = _mm_setzero_si128();
; 867  : 	__m128i a = _mm_set1_epi32(((alpha+1) << 16) | (0x100 - alpha));
; 868  : 	__m128i d = _mm_unpacklo_epi8(_mm_cvtsi32_si128(*dst), zero);

	mov	esi, DWORD PTR [edx]
	shr	eax, 6
	and	ecx, 16777215				; 00ffffffH
	and	eax, 255				; 000000ffH
	movd	xmm0, esi

; 869  : 	__m128i s = _mm_unpacklo_epi8(_mm_cvtsi32_si128(color), zero);

	movd	xmm2, ecx

; 870  : 	__m128i r = _mm_unpacklo_epi16(d, s);
; 871  : 
; 872  : 	r = _mm_madd_epi16(r, a);
; 873  : 	r = _mm_srli_epi32(r, 8);

	lea	ecx, DWORD PTR [eax+1]
	mov	esi, 256				; 00000100H
	sub	esi, eax
	pxor	xmm1, xmm1
	punpcklbw xmm0, xmm1
	shl	ecx, 16					; 00000010H
	punpcklbw xmm2, xmm1
	or	ecx, esi
	punpcklwd xmm0, xmm2
	movd	xmm1, ecx
	pshufd	xmm1, xmm1, 0
	pmaddwd	xmm0, xmm1
	psrld	xmm0, 8

; 874  : 	r = _mm_packs_epi32(r, r);

	packssdw xmm0, xmm0

; 875  : 	r = _mm_packus_epi16(r, r);

	packuswb xmm0, xmm0

; 876  : 
; 877  : 	*dst = (DWORD)_mm_cvtsi128_si32(r);

	movd	eax, xmm0
	mov	DWORD PTR [edx], eax

; 878  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?pixmix_sse2@@YAXPAKKK@Z ENDP				; pixmix_sse2
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?pixmix2@@YAXPAKKKK@Z
_TEXT	SEGMENT
_dst$ = 8						; size = 4
_shapealpha$ = 12					; size = 4
_clipalpha$ = 16					; size = 4
?pixmix2@@YAXPAKKKK@Z PROC				; pixmix2, COMDAT
; _color$ = edx

; 849  : 	int a = (((shapealpha)*(clipalpha)*(color>>24))>>12)&0xff;
; 850  : 	int ia = 256-a;
; 851  : 	a+=1;
; 852  : 
; 853  : 	*dst = ((((*dst&0x00ff00ff)*ia + (color&0x00ff00ff)*a)&0xff00ff00)>>8)
; 854  : 			| ((((*dst&0x0000ff00)*ia + (color&0x0000ff00)*a)&0x00ff0000)>>8)
; 855  : 			| ((((*dst>>8)&0x00ff0000)*ia)&0xff000000);

	mov	ecx, DWORD PTR _dst$[esp-4]
	mov	ecx, DWORD PTR [ecx]
	mov	eax, edx
	shr	eax, 24					; 00000018H
	imul	eax, DWORD PTR _shapealpha$[esp-4]
	imul	eax, DWORD PTR _clipalpha$[esp-4]
	push	ebx
	push	ebp
	push	esi
	push	edi
	shr	eax, 12					; 0000000cH
	mov	edi, ecx
	and	edi, -65281				; ffff00ffH
	mov	ebx, edx
	and	ebx, -65281				; ffff00ffH
	and	eax, 255				; 000000ffH
	mov	esi, 256				; 00000100H
	sub	esi, eax
	imul	edi, esi
	inc	eax
	imul	ebx, eax
	add	edi, ebx
	mov	ebx, ecx
	and	ebx, 65280				; 0000ff00H
	mov	ebp, edx
	imul	ebx, esi
	and	ebp, 65280				; 0000ff00H
	imul	ebp, eax
	add	ebx, ebp
	xor	edi, ebx
	mov	ebx, ecx
	and	ebx, 16711935				; 00ff00ffH
	and	edx, 16711935				; 00ff00ffH
	imul	ebx, esi
	shr	ecx, 8
	imul	edx, eax
	and	ecx, 16711680				; 00ff0000H
	imul	ecx, esi
	and	edi, 16711680				; 00ff0000H
	add	ebx, edx
	mov	edx, DWORD PTR _dst$[esp+12]
	xor	edi, ebx
	shr	edi, 8
	and	ecx, -16777216				; ff000000H
	or	edi, ecx
	mov	DWORD PTR [edx], edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 856  : }

	ret	0
?pixmix2@@YAXPAKKKK@Z ENDP				; pixmix2
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?pixmix@@YAXPAKKK@Z
_TEXT	SEGMENT
_ia$ = 8						; size = 4
_alpha$ = 8						; size = 4
?pixmix@@YAXPAKKK@Z PROC				; pixmix, COMDAT
; _dst$ = edi
; _color$ = edx

; 837  : 	int a = (((alpha)*(color>>24))>>6)&0xff;
; 838  : 	// Make sure both a and ia are in range 1..256 for the >>8 operations below to be correct
; 839  : 	int ia = 256-a;
; 840  : 	a+=1;
; 841  : 
; 842  : 	*dst = ((((*dst&0x00ff00ff)*ia + (color&0x00ff00ff)*a)&0xff00ff00)>>8)
; 843  : 			| ((((*dst&0x0000ff00)*ia + (color&0x0000ff00)*a)&0x00ff0000)>>8)
; 844  : 			| ((((*dst>>8)&0x00ff0000)*ia)&0xff000000);

	mov	ecx, DWORD PTR [edi]
	mov	eax, edx
	push	ebx
	shr	eax, 24					; 00000018H
	imul	eax, DWORD PTR _alpha$[esp]
	push	ebp
	push	esi
	shr	eax, 6
	mov	ebp, ecx
	and	ebp, 65280				; 0000ff00H
	and	eax, 255				; 000000ffH
	mov	ebx, edx
	and	ebx, 65280				; 0000ff00H
	mov	esi, 256				; 00000100H
	sub	esi, eax
	imul	ebp, esi
	inc	eax
	imul	ebx, eax
	add	ebx, ebp
	mov	DWORD PTR _ia$[esp+8], esi
	mov	ebp, ecx
	and	ebp, -65281				; ffff00ffH
	imul	ebp, DWORD PTR _ia$[esp+8]
	mov	esi, edx
	and	esi, -65281				; ffff00ffH
	imul	esi, eax
	add	esi, ebp
	xor	ebx, esi
	mov	esi, DWORD PTR _ia$[esp+8]
	mov	ebp, ecx
	and	ebp, 16711935				; 00ff00ffH
	imul	ebp, esi
	and	edx, 16711935				; 00ff00ffH
	shr	ecx, 8
	imul	edx, eax
	and	ecx, 16711680				; 00ff0000H
	imul	ecx, esi
	and	ebx, 16711680				; 00ff0000H
	add	ebp, edx
	xor	ebx, ebp
	shr	ebx, 8
	and	ecx, -16777216				; ff000000H
	pop	esi
	or	ebx, ecx
	pop	ebp
	mov	DWORD PTR [edi], ebx
	pop	ebx

; 845  : }

	ret	0
?pixmix@@YAXPAKKK@Z ENDP				; pixmix
_TEXT	ENDS
PUBLIC	?PartialEndPath@Rasterizer@@QAE_NPAUHDC__@@JJ@Z	; Rasterizer::PartialEndPath
; Function compile flags: /Ogtpy
;	COMDAT ?PartialEndPath@Rasterizer@@QAE_NPAUHDC__@@JJ@Z
_TEXT	SEGMENT
_hdc$ = -16						; size = 4
_pNewTypes$128755 = -12					; size = 4
_pNewPoints$128756 = -8					; size = 4
_pTypes$128764 = -4					; size = 4
_dx$ = 8						; size = 4
?PartialEndPath@Rasterizer@@QAE_NPAUHDC__@@JJ@Z PROC	; Rasterizer::PartialEndPath, COMDAT
; _this$ = esi

; 296  : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	edi

; 323  : 		{
; 324  : 			for(int i = 0; i < nPoints; ++i)

	mov	edi, DWORD PTR _g_hDC
	push	edi

; 336  : 		}
; 337  : 		else
; 338  : 			DebugBreak();

	mov	DWORD PTR _hdc$[esp+32], edi
	call	DWORD PTR __imp__CloseFigure@4
	push	edi
	call	DWORD PTR __imp__EndPath@4
	test	eax, eax
	je	$LN9@PartialEnd
	push	0
	push	0
	push	0
	push	edi
	call	DWORD PTR __imp__GetPath@16
	mov	edi, eax
	test	edi, edi
	je	$LN15@PartialEnd
	mov	eax, DWORD PTR [esi+32]
	mov	ecx, DWORD PTR [esi+24]
	add	eax, edi
	push	eax
	push	ecx
	call	_realloc
	mov	edx, DWORD PTR [esi+32]
	add	edx, edi
	add	edx, edx
	add	edx, edx
	mov	ebx, eax
	mov	eax, DWORD PTR [esi+28]
	add	edx, edx
	push	edx
	push	eax
	mov	DWORD PTR _pNewTypes$128755[esp+44], ebx
	call	_realloc
	add	esp, 16					; 00000010H
	mov	DWORD PTR _pNewPoints$128756[esp+28], eax
	test	ebx, ebx
	je	SHORT $LN7@PartialEnd

; 297  : 	::CloseFigure(hdc);
; 298  : 
; 299  : 	if(::EndPath(hdc))
; 300  : 	{
; 301  : 		int nPoints;
; 302  : 		BYTE* pNewTypes;
; 303  : 		POINT* pNewPoints;
; 304  : 
; 305  : 		nPoints = GetPath(hdc, NULL, NULL, 0);
; 306  : 
; 307  : 		if(!nPoints)
; 308  : 			return true;
; 309  : 
; 310  : 		pNewTypes = (BYTE*)realloc(mpPathTypes, (mPathPoints + nPoints) * sizeof(BYTE));
; 311  : 		pNewPoints = (POINT*)realloc(mpPathPoints, (mPathPoints + nPoints) * sizeof(POINT));
; 312  : 
; 313  : 		if(pNewTypes)
; 314  : 			mpPathTypes = pNewTypes;

	mov	DWORD PTR [esi+24], ebx
$LN7@PartialEnd:

; 315  : 
; 316  : 		if(pNewPoints)

	test	eax, eax
	je	SHORT $LN6@PartialEnd

; 317  : 			mpPathPoints = pNewPoints;

	mov	DWORD PTR [esi+28], eax
$LN6@PartialEnd:

; 318  : 
; 319  : 		BYTE* pTypes = new BYTE[nPoints];

	push	edi
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ebp, eax

; 320  : 		POINT* pPoints = new POINT[nPoints];

	xor	ecx, ecx
	mov	eax, edi
	mov	edx, 8
	mul	edx
	seto	cl
	mov	DWORD PTR _pTypes$128764[esp+32], ebp
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 8

; 321  : 
; 322  : 		if(pNewTypes && pNewPoints && nPoints == GetPath(hdc, pPoints, pTypes, nPoints))

	cmp	DWORD PTR _pNewTypes$128755[esp+28], 0
	mov	ebx, eax
	je	SHORT $LN5@PartialEnd
	cmp	DWORD PTR _pNewPoints$128756[esp+28], 0
	je	SHORT $LN5@PartialEnd
	mov	eax, DWORD PTR _hdc$[esp+28]
	push	edi
	push	ebp
	push	ebx
	push	eax
	call	DWORD PTR __imp__GetPath@16
	cmp	edi, eax
	jne	SHORT $LN5@PartialEnd

; 323  : 		{
; 324  : 			for(int i = 0; i < nPoints; ++i)

	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN2@PartialEnd
	npad	5
$LL14@PartialEnd:

; 325  : 			{
; 326  : 				mpPathPoints[mPathPoints + i].x = pPoints[i].x + dx;

	mov	ecx, DWORD PTR [ebx+eax*8]
	add	ecx, DWORD PTR _dx$[esp+24]
	mov	edx, DWORD PTR [esi+32]
	mov	ebp, DWORD PTR [esi+28]
	add	edx, eax
	mov	DWORD PTR [ebp+edx*8], ecx

; 327  : 				mpPathPoints[mPathPoints + i].y = pPoints[i].y + dy;

	mov	ecx, DWORD PTR [esi+32]
	mov	ebp, DWORD PTR [ebx+eax*8+4]
	mov	edx, DWORD PTR [esi+28]
	add	ecx, eax
	mov	DWORD PTR [edx+ecx*8+4], ebp

; 328  : 				mpPathTypes[mPathPoints + i] = pTypes[i];

	mov	ecx, DWORD PTR [esi+32]
	add	ecx, DWORD PTR [esi+24]
	mov	ebp, DWORD PTR _pTypes$128764[esp+28]
	mov	dl, BYTE PTR [eax+ebp]
	mov	BYTE PTR [ecx+eax], dl
	inc	eax
	cmp	eax, edi
	jl	SHORT $LL14@PartialEnd
$LN2@PartialEnd:

; 329  : 			}
; 330  : 
; 331  : 			mPathPoints += nPoints;

	add	DWORD PTR [esi+32], edi

; 332  : 
; 333  : 			delete[] pTypes;

	push	ebp
	call	??_V@YAXPAX@Z				; operator delete[]

; 334  : 			delete[] pPoints;

	push	ebx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 8
$LN15@PartialEnd:
	pop	edi
	pop	ebp

; 335  : 			return true;

	mov	al, 1
	pop	ebx

; 347  : }

	add	esp, 16					; 00000010H
	ret	4
$LN5@PartialEnd:

; 336  : 		}
; 337  : 		else
; 338  : 			DebugBreak();

	call	DWORD PTR __imp__DebugBreak@0

; 339  : 
; 340  : 		delete[] pTypes;

	push	ebp
	call	??_V@YAXPAX@Z				; operator delete[]

; 341  : 		delete[] pPoints;

	push	ebx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	edi, DWORD PTR _hdc$[esp+36]
	add	esp, 8
$LN9@PartialEnd:

; 342  : 	}
; 343  : 
; 344  : 	::AbortPath(hdc);

	push	edi
	call	DWORD PTR __imp__AbortPath@4
	pop	edi
	pop	ebp

; 345  : 
; 346  : 	return false;

	xor	al, al
	pop	ebx

; 347  : }

	add	esp, 16					; 00000010H
	ret	4
?PartialEndPath@Rasterizer@@QAE_NPAUHDC__@@JJ@Z ENDP	; Rasterizer::PartialEndPath
_TEXT	ENDS
PUBLIC	?EndPath@Rasterizer@@QAE_NPAUHDC__@@@Z		; Rasterizer::EndPath
; Function compile flags: /Ogtpy
;	COMDAT ?EndPath@Rasterizer@@QAE_NPAUHDC__@@@Z
_TEXT	SEGMENT
?EndPath@Rasterizer@@QAE_NPAUHDC__@@@Z PROC		; Rasterizer::EndPath, COMDAT
; _this$ = esi

; 265  : {

	push	ebx
	push	edi
	mov	edi, DWORD PTR _g_hDC

; 266  : 	::CloseFigure(hdc);

	push	edi
	call	DWORD PTR __imp__CloseFigure@4

; 267  : 
; 268  : 	if(::EndPath(hdc))

	push	edi
	call	DWORD PTR __imp__EndPath@4
	test	eax, eax
	je	SHORT $LN1@EndPath

; 269  : 	{
; 270  : 		mPathPoints = GetPath(hdc, NULL, NULL, 0);

	mov	ebx, DWORD PTR __imp__GetPath@16
	push	0
	push	0
	push	0
	push	edi
	call	ebx
	mov	DWORD PTR [esi+32], eax

; 271  : 
; 272  : 		if(!mPathPoints)

	test	eax, eax
	jne	SHORT $LN2@EndPath
$LN6@EndPath:
	pop	edi

; 273  : 			return true;

	mov	al, 1
	pop	ebx

; 285  : }

	ret	0
$LN2@EndPath:

; 274  : 
; 275  : 		mpPathTypes = (BYTE*)malloc(sizeof(BYTE) * mPathPoints);

	push	eax
	call	_malloc
	mov	DWORD PTR [esi+24], eax

; 276  : 		mpPathPoints = (POINT*)malloc(sizeof(POINT) * mPathPoints);

	mov	eax, DWORD PTR [esi+32]
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	call	_malloc

; 277  : 
; 278  : 		if(mPathPoints == GetPath(hdc, mpPathPoints, mpPathTypes, mPathPoints))

	mov	ecx, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [esi+24]
	add	esp, 8
	push	ecx
	push	edx
	push	eax
	push	edi
	mov	DWORD PTR [esi+28], eax
	call	ebx
	cmp	DWORD PTR [esi+32], eax

; 279  : 			return true;

	je	SHORT $LN6@EndPath
$LN1@EndPath:

; 280  : 	}
; 281  : 
; 282  : 	::AbortPath(hdc);

	push	edi
	call	DWORD PTR __imp__AbortPath@4
	pop	edi

; 283  : 
; 284  : 	return false;

	xor	al, al
	pop	ebx

; 285  : }

	ret	0
?EndPath@Rasterizer@@QAE_NPAUHDC__@@@Z ENDP		; Rasterizer::EndPath
_TEXT	ENDS
PUBLIC	?_ReallocEdgeBuffer@Rasterizer@@AAEXH@Z		; Rasterizer::_ReallocEdgeBuffer
; Function compile flags: /Ogtpy
;	COMDAT ?_ReallocEdgeBuffer@Rasterizer@@AAEXH@Z
_TEXT	SEGMENT
?_ReallocEdgeBuffer@Rasterizer@@AAEXH@Z PROC		; Rasterizer::_ReallocEdgeBuffer, COMDAT
; _this$ = esi
; _edges$ = eax

; 70   : 	mEdgeHeapSize = edges;
; 71   : 	mpEdgeBuffer = (Edge*)realloc(mpEdgeBuffer, sizeof(Edge)*edges);

	mov	ecx, DWORD PTR [esi+96]
	mov	DWORD PTR [esi+100], eax
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR [esi+96], eax

; 72   : }

	ret	0
?_ReallocEdgeBuffer@Rasterizer@@AAEXH@Z ENDP		; Rasterizer::_ReallocEdgeBuffer
_TEXT	ENDS
PUBLIC	?_TrashOverlay@Rasterizer@@AAEXXZ		; Rasterizer::_TrashOverlay
; Function compile flags: /Ogtpy
;	COMDAT ?_TrashOverlay@Rasterizer@@AAEXXZ
_TEXT	SEGMENT
?_TrashOverlay@Rasterizer@@AAEXXZ PROC			; Rasterizer::_TrashOverlay, COMDAT
; _this$ = esi

; 64   : 	delete [] mpOverlayBuffer;

	mov	eax, DWORD PTR [esi+112]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 65   : 	mpOverlayBuffer = NULL;

	mov	DWORD PTR [esi+112], 0

; 66   : }

	ret	0
?_TrashOverlay@Rasterizer@@AAEXXZ ENDP			; Rasterizer::_TrashOverlay
_TEXT	ENDS
PUBLIC	?_TrashPath@Rasterizer@@AAEXXZ			; Rasterizer::_TrashPath
; Function compile flags: /Ogtpy
;	COMDAT ?_TrashPath@Rasterizer@@AAEXXZ
_TEXT	SEGMENT
?_TrashPath@Rasterizer@@AAEXXZ PROC			; Rasterizer::_TrashPath, COMDAT
; _this$ = esi

; 55   : 	delete [] mpPathTypes;

	mov	eax, DWORD PTR [esi+24]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]

; 56   : 	delete [] mpPathPoints;

	mov	ecx, DWORD PTR [esi+28]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]

; 57   : 	mpPathTypes = NULL;

	xor	eax, eax
	add	esp, 8
	mov	DWORD PTR [esi+24], eax

; 58   : 	mpPathPoints = NULL;

	mov	DWORD PTR [esi+28], eax

; 59   : 	mPathPoints = 0;

	mov	DWORD PTR [esi+32], eax

; 60   : }

	ret	0
?_TrashPath@Rasterizer@@AAEXXZ ENDP			; Rasterizer::_TrashPath
; Function compile flags: /Ogtpy
; File d:\-=svn=-\svplayer\src\subtitles\separablefilter.h
_TEXT	ENDS
;	COMDAT ??1GaussianKernel@@QAE@XZ
_TEXT	SEGMENT
??1GaussianKernel@@QAE@XZ PROC				; GaussianKernel::~GaussianKernel, COMDAT
; _this$ = eax

; 119  : 		delete[] kernel;

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx

; 120  : 	}

	ret	0
??1GaussianKernel@@QAE@XZ ENDP				; GaussianKernel::~GaussianKernel
_TEXT	ENDS
PUBLIC	__real@401921fb54411744
EXTRN	__CIsqrt:PROC
EXTRN	__CIexp:PROC
;	COMDAT __real@401921fb54411744
CONST	SEGMENT
__real@401921fb54411744 DQ 0401921fb54411744r	; 6.28319
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?NormalDist@@YANNN@Z
_TEXT	SEGMENT
tv67 = -12						; size = 8
_sigma$ = 8						; size = 8
_x$ = 16						; size = 8
?NormalDist@@YANNN@Z PROC				; NormalDist, COMDAT

; 93   : 	if (sigma <= 0 && x == 0) return 1;

	fldz
	sub	esp, 12					; 0000000cH
	fld	QWORD PTR _sigma$[esp+8]
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN8@NormalDist
	fstp	ST(0)
	fcom	QWORD PTR _x$[esp+8]
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN1@NormalDist
	fstp	ST(0)
	fld1

; 96   : }

	add	esp, 12					; 0000000cH
	ret	0
$LN8@NormalDist:

; 93   : 	if (sigma <= 0 && x == 0) return 1;

	fstp	ST(1)

; 94   : 	else if (sigma <= 0) return 0;
; 95   : 	else return exp(-(x*x)/(2*sigma*sigma)) / (sigma * sqrt(2*3.1415926535));

	fld	QWORD PTR _x$[esp+8]
	fmul	ST(0), ST(0)
	fld	ST(1)
	fadd	ST(0), ST(0)
	fmulp	ST(2), ST(0)
	fdivrp	ST(1), ST(0)
	fchs
	call	__CIexp
	fstp	QWORD PTR tv67[esp+12]
	fld	QWORD PTR __real@401921fb54411744
	call	__CIsqrt
	fmul	QWORD PTR _sigma$[esp+8]
	fdivr	QWORD PTR tv67[esp+12]
$LN1@NormalDist:

; 96   : }

	add	esp, 12					; 0000000cH
	ret	0
?NormalDist@@YANNN@Z ENDP				; NormalDist
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Swap_aux@_Container_base_aux@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
?_Swap_aux@_Container_base_aux@std@@QAEXAAV12@@Z PROC	; std::_Container_base_aux::_Swap_aux, COMDAT
; _this$ = ecx
; __Right$ = eax

; 396  : 		{

	push	esi

; 397  : 		std::swap(_Myownedaux, _Right._Myownedaux);

	cmp	ecx, eax
	je	SHORT $LN3@Swap_aux
	mov	esi, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [eax], edx
$LN3@Swap_aux:

; 398  : 		std::swap(*_Myownedaux, *_Right._Myownedaux);

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, eax
	je	SHORT $LN6@Swap_aux
	mov	esi, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [eax], edx
$LN6@Swap_aux:
	pop	esi

; 399  : 		}

	ret	0
?_Swap_aux@_Container_base_aux@std@@QAEXAAV12@@Z ENDP	; std::_Container_base_aux::_Swap_aux
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\atlmfc\include\atltypes.inl
_TEXT	ENDS
;	COMDAT ??9CPoint@@QBEHUtagPOINT@@@Z
_TEXT	SEGMENT
_point$ = 8						; size = 8
??9CPoint@@QBEHUtagPOINT@@@Z PROC			; CPoint::operator!=, COMDAT
; _this$ = ecx

; 91   : 	{ return (x != point.x || y != point.y); }

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR _point$[esp-4]
	jne	SHORT $LN3@operator
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR _point$[esp]
	jne	SHORT $LN3@operator
	xor	eax, eax
	ret	8
$LN3@operator:
	mov	eax, 1
	ret	8
??9CPoint@@QBEHUtagPOINT@@@Z ENDP			; CPoint::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0CPoint@@QAE@UtagPOINT@@@Z
_TEXT	SEGMENT
_initPt$ = 8						; size = 8
??0CPoint@@QAE@UtagPOINT@@@Z PROC			; CPoint::CPoint, COMDAT
; _this$ = ecx

; 72   : 	{ *(POINT*)this = initPt; }

	mov	edx, DWORD PTR _initPt$[esp]
	mov	eax, ecx
	mov	ecx, DWORD PTR _initPt$[esp-4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	ret	8
??0CPoint@@QAE@UtagPOINT@@@Z ENDP			; CPoint::CPoint
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$Array@TSpan@Rasterizer@ssf@@@ssf@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$Array@TSpan@Rasterizer@ssf@@@ssf@@UAEPAXI@Z PROC	; ssf::Array<ssf::Rasterizer::Span>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7?$Array@TSpan@Rasterizer@ssf@@@ssf@@6B@
	test	eax, eax
	je	SHORT $LN4@scalar@3
	push	eax
	call	__aligned_free
	add	esp, 4
$LN4@scalar@3:
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN7@scalar@3
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@scalar@3:
	mov	eax, esi
	pop	esi
	ret	4
??_G?$Array@TSpan@Rasterizer@ssf@@@ssf@@UAEPAXI@Z ENDP	; ssf::Array<ssf::Rasterizer::Span>::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File d:\-=svn=-\svplayer\src\subtitles\libssf\array.h
_TEXT	ENDS
;	COMDAT ?Move@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEXAAV12@@Z
_TEXT	SEGMENT
?Move@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEXAAV12@@Z PROC ; ssf::Array<ssf::Rasterizer::Span>::Move, COMDAT
; _this$ = ecx
; _v$ = eax

; 96   : 			Swap(v);

	mov	edx, DWORD PTR [ecx+4]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], esi
	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx+8], esi
	mov	esi, DWORD PTR [eax+12]
	mov	DWORD PTR [eax+8], edx
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx+12], esi
	mov	esi, DWORD PTR [eax+16]
	mov	DWORD PTR [eax+12], edx
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [ecx+16], esi
	mov	DWORD PTR [eax+16], edx

; 97   : 			v.SetCount(0);

	mov	DWORD PTR [eax+8], 0
	pop	esi

; 98   : 		}

	ret	0
?Move@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEXAAV12@@Z ENDP ; ssf::Array<ssf::Rasterizer::Span>::Move
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Append@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEXPBTSpan@Rasterizer@2@II@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
_nSize$ = 12						; size = 4
?Append@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEXPBTSpan@Rasterizer@2@II@Z PROC ; ssf::Array<ssf::Rasterizer::Span>::Append, COMDAT
; _this$ = esi

; 78   : 		{

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _nSize$[esp+4]
	push	edi

; 79   : 			if(!nSize) return;
; 80   : 			size_t nOldSize = m_nSize;

	mov	edi, DWORD PTR [esi+8]

; 81   : 			SetCount(nOldSize + nSize);

	lea	ebx, DWORD PTR [edi+ebp]
	cmp	ebx, DWORD PTR [esi+12]
	jbe	SHORT $LN8@Append
	mov	eax, DWORD PTR [esi+16]
	cmp	eax, edi
	ja	SHORT $LN13@Append
	mov	eax, edi
$LN13@Append:
	mov	ecx, DWORD PTR [esi+4]
	add	eax, ebx
	mov	DWORD PTR [esi+12], eax
	shl	eax, 4
	push	16					; 00000010H
	push	eax
	test	ecx, ecx
	je	SHORT $LN14@Append
	push	ecx
	call	__aligned_realloc
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN15@Append
$LN14@Append:
	call	__aligned_malloc
	add	esp, 8
$LN15@Append:
	mov	DWORD PTR [esi+4], eax
$LN8@Append:

; 82   : 			memcpy(m_pData + nOldSize, ptr, nSize * sizeof(T));

	mov	eax, DWORD PTR _ptr$[esp+8]
	shl	ebp, 4
	push	ebp
	shl	edi, 4
	add	edi, DWORD PTR [esi+4]
	push	eax
	push	edi
	mov	DWORD PTR [esi+8], ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
	pop	edi
	pop	ebp
	pop	ebx

; 83   : 		}

	ret	8
?Append@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEXPBTSpan@Rasterizer@2@II@Z ENDP ; ssf::Array<ssf::Rasterizer::Span>::Append
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?Add@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEXABTSpan@Rasterizer@2@@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
?Add@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEXABTSpan@Rasterizer@2@@Z PROC ; ssf::Array<ssf::Rasterizer::Span>::Add, COMDAT
; _this$ = esi

; 66   : 		{

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _t$[esp+4]
	push	edi

; 67   : 			size_t nPos = m_nSize;

	mov	edi, DWORD PTR [esi+8]

; 68   : 			SetCount(m_nSize+1);

	lea	ebx, DWORD PTR [edi+1]
	cmp	ebx, DWORD PTR [esi+12]
	jbe	SHORT $LN3@Add
	mov	eax, DWORD PTR [esi+16]
	cmp	eax, edi
	ja	SHORT $LN8@Add
	mov	eax, edi
$LN8@Add:
	mov	ecx, DWORD PTR [esi+4]
	add	eax, ebx
	mov	DWORD PTR [esi+12], eax
	shl	eax, 4
	push	16					; 00000010H
	push	eax
	test	ecx, ecx
	je	SHORT $LN9@Add
	push	ecx
	call	__aligned_realloc
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN10@Add
$LN9@Add:
	call	__aligned_malloc
	add	esp, 8
$LN10@Add:
	mov	DWORD PTR [esi+4], eax
$LN3@Add:
	mov	DWORD PTR [esi+8], ebx

; 69   : 			m_pData[nPos] = t;

	mov	eax, DWORD PTR [ebp]
	shl	edi, 4
	add	edi, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	ecx, DWORD PTR [ebp+4]
	mov	DWORD PTR [edi+4], ecx
	mov	edx, DWORD PTR [ebp+8]
	mov	DWORD PTR [edi+8], edx
	mov	eax, DWORD PTR [ebp+12]
	mov	DWORD PTR [edi+12], eax
	pop	edi
	pop	ebp
	pop	ebx

; 70   : 		}

	ret	4
?Add@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEXABTSpan@Rasterizer@2@@Z ENDP ; ssf::Array<ssf::Rasterizer::Span>::Add
_TEXT	ENDS
PUBLIC	?Draw@Rasterizer@ssf@@QAE?AVCRect@@ABUSubPicDesc@@ABV3@HHPBKH@Z ; ssf::Rasterizer::Draw
; Function compile flags: /Ogtpy
; File d:\-=svn=-\svplayer\src\subtitles\libssf\rasterizer.cpp
;	COMDAT ?Draw@Rasterizer@ssf@@QAE?AVCRect@@ABUSubPicDesc@@ABV3@HHPBKH@Z
_TEXT	SEGMENT
_fSSE2$ = -85						; size = 1
_w$ = -84						; size = 4
_h$ = -80						; size = 4
tv1092 = -76						; size = 4
tv816 = -72						; size = 4
tv789 = -72						; size = 4
_xo$ = -68						; size = 4
_src$ = -64						; size = 4
_color$ = -60						; size = 4
tv613 = -56						; size = 4
_dst$ = -56						; size = 4
_yo$ = -56						; size = 4
tv1317 = -52						; size = 4
tv1140 = -52						; size = 4
tv257 = -52						; size = 4
tv1217 = -48						; size = 4
tv530 = -48						; size = 4
_sw$134410 = -48					; size = 4
tv1342 = -44						; size = 4
tv800 = -44						; size = 4
tv806 = -40						; size = 4
tv445 = -40						; size = 4
_ia$233734 = -36					; size = 4
_r$ = -32						; size = 16
$T233657 = -16						; size = 16
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
_spd$ = 16						; size = 4
_clip$ = 20						; size = 4
_switchpts$ = 24					; size = 4
_plane$ = 28						; size = 4
?Draw@Rasterizer@ssf@@QAE?AVCRect@@ABUSubPicDesc@@ABV3@HHPBKH@Z PROC ; ssf::Rasterizer::Draw, COMDAT
; _xsub$ = ecx
; _ysub$ = eax

; 639  : 	{

	push	ebp
	mov	ebp, esp
	and	esp, -16				; fffffff0H
	sub	esp, 100				; 00000064H
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx

; 640  : 		CRect bbox(0, 0, 0, 0);

	xor	ecx, ecx
	mov	edi, eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 641  : 
; 642  : 		if(!switchpts) return bbox;

	cmp	DWORD PTR _switchpts$[ebp], ecx
	je	$LN34@Draw

; 643  : 
; 644  : 		// clip
; 645  : 
; 646  : 		CRect r(0, 0, spd.w, spd.h);

	mov	eax, DWORD PTR _spd$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR _r$[esp+112], ecx
	mov	DWORD PTR _r$[esp+116], ecx
	mov	ecx, DWORD PTR [eax+4]

; 647  : 		r &= clip;

	mov	eax, DWORD PTR _clip$[ebp]
	mov	DWORD PTR _r$[esp+120], ecx
	push	eax
	lea	ecx, DWORD PTR _r$[esp+116]
	mov	DWORD PTR _r$[esp+128], edx
	push	ecx
	mov	edx, ecx
	push	edx
	call	DWORD PTR __imp__IntersectRect@12

; 648  : 
; 649  : 		xsub >>= FONT_SCALE;
; 650  : 		ysub >>= FONT_SCALE;
; 651  : 
; 652  : 		int x = (xsub + mOffsetX + (1<<FONT_AA)/2) >> FONT_AA;

	mov	ebx, DWORD PTR _this$[ebp]

; 653  : 		int y = (ysub + mOffsetY + (1<<FONT_AA)/2) >> FONT_AA;

	mov	ecx, DWORD PTR [ebx+136]
	mov	eax, DWORD PTR [ebx+132]

; 654  : 		int w = mOverlayWidth;
; 655  : 		int h = mOverlayHeight;

	mov	edx, DWORD PTR [ebx+120]
	sar	edi, 3
	sar	esi, 3
	lea	edi, DWORD PTR [ecx+edi+4]

; 656  : 		int xo = 0, yo = 0;

	xor	ecx, ecx
	lea	esi, DWORD PTR [eax+esi+4]
	mov	eax, DWORD PTR [ebx+116]
	mov	DWORD PTR _xo$[esp+112], ecx
	mov	DWORD PTR _yo$[esp+112], ecx

; 657  : 
; 658  : 		if(x < r.left) {xo = r.left - x; w -= r.left - x; x = r.left;}

	mov	ecx, DWORD PTR _r$[esp+112]
	sar	esi, 3
	sar	edi, 3
	cmp	esi, ecx
	mov	DWORD PTR _w$[esp+112], eax
	mov	DWORD PTR _h$[esp+112], edx
	jge	SHORT $LN32@Draw
	mov	edx, ecx
	sub	edx, esi
	sub	esi, ecx
	add	eax, esi
	mov	DWORD PTR _xo$[esp+112], edx
	mov	DWORD PTR _w$[esp+112], eax
	mov	esi, ecx
$LN32@Draw:

; 659  : 		if(y < r.top) {yo = r.top - y; h -= r.top - y; y = r.top;}

	mov	ecx, DWORD PTR _r$[esp+116]
	cmp	edi, ecx
	jge	SHORT $LN31@Draw
	mov	edx, ecx
	sub	edx, edi
	sub	edi, ecx
	add	DWORD PTR _h$[esp+112], edi
	mov	DWORD PTR _yo$[esp+112], edx
	mov	edi, ecx
$LN31@Draw:

; 660  : 		if(x+w > r.right) w = r.right - x;

	mov	ecx, DWORD PTR _r$[esp+120]
	lea	edx, DWORD PTR [eax+esi]
	cmp	edx, ecx
	jle	SHORT $LN30@Draw
	sub	ecx, esi
	mov	DWORD PTR _w$[esp+112], ecx
	mov	eax, ecx
$LN30@Draw:

; 661  : 		if(y+h > r.bottom) h = r.bottom - y;

	mov	ecx, DWORD PTR _h$[esp+112]
	lea	edx, DWORD PTR [ecx+edi]
	mov	ecx, DWORD PTR _r$[esp+124]
	cmp	edx, ecx
	jle	SHORT $LN29@Draw
	sub	ecx, edi
	mov	DWORD PTR _h$[esp+112], ecx
$LN29@Draw:

; 662  : 
; 663  : 		if(w <= 0 || h <= 0) return bbox;

	test	eax, eax
	jle	$LN27@Draw
	mov	ecx, DWORD PTR _h$[esp+112]
	test	ecx, ecx
	jle	$LN27@Draw

; 664  : 
; 665  : 		bbox.SetRect(x, y, x + w, y + h);

	add	ecx, edi
	push	ecx
	add	eax, esi
	push	eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	edi
	push	esi
	push	eax
	call	DWORD PTR __imp__SetRect@20

; 666  : 		bbox &= CRect(0, 0, spd.w, spd.h);

	xor	eax, eax
	mov	DWORD PTR $T233657[esp+112], eax
	mov	DWORD PTR $T233657[esp+116], eax
	mov	eax, DWORD PTR _spd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax+8]
	lea	eax, DWORD PTR $T233657[esp+112]
	push	eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	push	eax
	mov	DWORD PTR $T233657[esp+132], ecx
	mov	DWORD PTR $T233657[esp+136], edx
	call	DWORD PTR __imp__IntersectRect@12

; 667  : 
; 668  : 		// draw
; 669  : 
; 670  : 		const BYTE* src = mpOverlayBuffer + 4*(mOverlayWidth * yo + xo) + plane;

	mov	ecx, DWORD PTR [ebx+116]
	imul	ecx, DWORD PTR _yo$[esp+112]
	add	ecx, DWORD PTR _xo$[esp+112]
	mov	edx, DWORD PTR [ebx+112]

; 671  : 		DWORD* dst = (DWORD*)((BYTE*)spd.bits + spd.pitch * y) + x;

	mov	eax, DWORD PTR _spd$[ebp]
	lea	ebx, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+16]
	add	ebx, DWORD PTR _plane$[ebp]
	imul	ecx, edi

; 672  : 
; 673  : 		DWORD color = switchpts[0];

	mov	edx, DWORD PTR _switchpts$[ebp]
	mov	edx, DWORD PTR [edx]
	lea	ecx, DWORD PTR [ecx+esi*4]
	add	ecx, DWORD PTR [eax+24]

; 674  : 
; 675  : 		bool fSSE2 = !!(g_cpuid.m_flags & CCpuID::sse2);

	mov	eax, DWORD PTR ?g_cpuid@@3VCCpuID@@A	; g_cpuid
	shr	eax, 3
	and	al, 1
	mov	DWORD PTR _src$[esp+112], ebx
	mov	DWORD PTR _dst$[esp+112], ecx
	mov	DWORD PTR _color$[esp+112], edx
	mov	BYTE PTR _fSSE2$[esp+112], al
	jmp	SHORT $LN26@Draw
	npad	1
$LL77@Draw:
	mov	al, BYTE PTR _fSSE2$[esp+112]
$LN26@Draw:

; 676  : 
; 677  : 		while(h--)
; 678  : 		{
; 679  : 			if(switchpts[1] == 0xffffffff)

	mov	edi, DWORD PTR _switchpts$[ebp]
	dec	DWORD PTR _h$[esp+112]
	cmp	DWORD PTR [edi+4], -1
	lea	esi, DWORD PTR [edi+4]
	jne	$LN24@Draw

; 680  : 			{
; 681  : 				if(fSSE2) for(int wt=0; wt<w; ++wt) pixmix_sse2(&dst[wt], color, src[wt*4]);

	test	al, al
	je	$LN23@Draw
	cmp	DWORD PTR _w$[esp+112], 0
	jle	$LN4@Draw
	mov	eax, edx
	and	eax, 16777215				; 00ffffffH
	movd	xmm1, eax
	mov	edi, edx
	shr	edi, 24					; 00000018H
	mov	eax, ebx
	sub	eax, ecx
	mov	DWORD PTR tv1092[esp+112], eax
	mov	eax, DWORD PTR _w$[esp+112]
	pxor	xmm0, xmm0
	movdqa	xmm2, xmm0
	mov	DWORD PTR tv789[esp+112], edi
	punpcklbw xmm1, xmm2
	mov	esi, ecx
	mov	DWORD PTR tv613[esp+112], eax
	jmp	SHORT $LN22@Draw
	npad	1
$LL74@Draw:
	mov	edi, DWORD PTR tv789[esp+112]
$LN22@Draw:
	mov	eax, DWORD PTR tv1092[esp+112]
	movzx	eax, BYTE PTR [eax+esi]
	imul	eax, edi
	mov	edi, DWORD PTR [esi]
	shr	eax, 6
	movd	xmm0, edi
	and	eax, 255				; 000000ffH
	mov	edi, 255				; 000000ffH
	sub	edi, eax
	shl	eax, 16					; 00000010H
	punpcklbw xmm0, xmm2
	or	edi, eax
	punpcklwd xmm0, xmm1
	movd	xmm3, edi
	pshufd	xmm3, xmm3, 0
	pmaddwd	xmm0, xmm3
	psrld	xmm0, 8
	packssdw xmm0, xmm0
	packuswb xmm0, xmm0
	movd	eax, xmm0
	mov	DWORD PTR [esi], eax
	add	esi, 4
	sub	DWORD PTR tv613[esp+112], 1
	jne	SHORT $LL74@Draw
	jmp	$LN4@Draw
$LN23@Draw:

; 682  : 				else for(int wt=0; wt<w; ++wt) pixmix_c(&dst[wt], color, src[wt*4]);

	cmp	DWORD PTR _w$[esp+112], 0
	jle	$LN4@Draw
	mov	esi, edx
	mov	edi, edx
	and	edx, 16711935				; 00ff00ffH
	shr	esi, 8
	shr	edi, 24					; 00000018H
	and	esi, 255				; 000000ffH
	mov	DWORD PTR tv806[esp+112], edx
	mov	edx, DWORD PTR _w$[esp+112]
	sub	ebx, ecx
	mov	DWORD PTR tv789[esp+112], edi
	mov	DWORD PTR tv800[esp+112], esi
	mov	DWORD PTR tv1140[esp+112], ecx
	mov	DWORD PTR tv1092[esp+112], ebx
	mov	DWORD PTR tv530[esp+112], edx
	jmp	SHORT $LN18@Draw
$LL71@Draw:
	mov	edi, DWORD PTR tv789[esp+112]
	mov	ebx, DWORD PTR tv1092[esp+112]
$LN18@Draw:
	movzx	eax, BYTE PTR [ecx+ebx]
	mov	ecx, DWORD PTR [ecx]
	imul	eax, edi
	mov	ebx, DWORD PTR tv806[esp+112]
	mov	edi, ecx
	and	edi, 16711935				; 00ff00ffH
	shr	eax, 6
	and	eax, 255				; 000000ffH
	imul	ebx, eax
	imul	esi, eax
	mov	edx, 255				; 000000ffH
	sub	edx, eax
	imul	edi, edx
	add	edi, ebx
	mov	ebx, ecx
	shr	ebx, 8
	and	ebx, -65281				; ffff00ffH
	imul	ebx, edx
	shr	ecx, 8
	and	ecx, 16711935				; 00ff00ffH
	imul	ecx, edx
	add	ebx, esi
	mov	esi, DWORD PTR tv800[esp+112]
	mov	edx, esi
	imul	edx, eax
	shr	edi, 8
	xor	edi, ebx
	add	ecx, edx
	and	edi, 16711935				; 00ff00ffH
	xor	edi, ecx
	mov	ecx, DWORD PTR tv1140[esp+112]
	mov	DWORD PTR [ecx], edi
	add	ecx, 4
	sub	DWORD PTR tv530[esp+112], 1
	mov	DWORD PTR tv1140[esp+112], ecx
	jne	SHORT $LL71@Draw

; 683  : 			}
; 684  : 			else

	mov	edx, DWORD PTR _color$[esp+112]
	jmp	$LN78@Draw
$LN24@Draw:

; 685  : 			{
; 686  : 				const DWORD* sw = switchpts;

	mov	DWORD PTR _sw$134410[esp+112], edi

; 687  : 
; 688  : 				if(fSSE2) 

	test	al, al
	je	$LN14@Draw

; 689  : 				for(int wt=0; wt<w; ++wt)

	cmp	DWORD PTR _w$[esp+112], 0
	jle	$LN4@Draw
	mov	eax, DWORD PTR _xo$[esp+112]
	sub	ebx, ecx
	mov	DWORD PTR tv1092[esp+112], ebx
	mov	ebx, DWORD PTR _w$[esp+112]
	mov	DWORD PTR tv816[esp+112], esi
	pxor	xmm1, xmm1
	mov	DWORD PTR tv1217[esp+112], eax
	mov	esi, ecx
	mov	DWORD PTR tv257[esp+112], ebx
$LN13@Draw:

; 690  : 				{
; 691  : 					if(wt+xo >= sw[1]) {while(wt+xo >= sw[1]) sw += 2; color = sw[-2];}

	mov	ebx, DWORD PTR tv816[esp+112]
	cmp	eax, DWORD PTR [ebx]
	jb	SHORT $LN10@Draw
	npad	8
$LL9@Draw:
	add	edi, 8
	lea	edx, DWORD PTR [edi+4]
	mov	DWORD PTR tv816[esp+112], edx
	cmp	eax, DWORD PTR [edx]
	jae	SHORT $LL9@Draw
	mov	edx, DWORD PTR [edi-8]
	mov	DWORD PTR _color$[esp+112], edx
$LN10@Draw:

; 692  : 					pixmix_sse2(&dst[wt], color, src[wt*4]);

	mov	eax, DWORD PTR tv1092[esp+112]
	movzx	eax, BYTE PTR [esi+eax]
	mov	ebx, edx
	shr	ebx, 24					; 00000018H
	imul	eax, ebx
	mov	ebx, DWORD PTR [esi]
	movd	xmm0, ebx
	shr	eax, 6
	and	eax, 255				; 000000ffH
	mov	ebx, edx
	and	ebx, 16777215				; 00ffffffH
	movd	xmm2, ebx
	mov	ebx, 255				; 000000ffH
	sub	ebx, eax
	shl	eax, 16					; 00000010H
	punpcklbw xmm0, xmm1
	or	ebx, eax
	punpcklbw xmm2, xmm1
	punpcklwd xmm0, xmm2
	movd	xmm2, ebx
	pshufd	xmm2, xmm2, 0
	pmaddwd	xmm0, xmm2
	psrld	xmm0, 8
	packssdw xmm0, xmm0
	packuswb xmm0, xmm0
	movd	eax, xmm0
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR tv1217[esp+112]
	inc	eax
	add	esi, 4
	sub	DWORD PTR tv257[esp+112], 1
	mov	DWORD PTR tv1217[esp+112], eax
	jne	$LN13@Draw

; 693  : 				}

	jmp	$LN79@Draw
$LN14@Draw:

; 694  : 				else
; 695  : 				for(int wt=0; wt<w; ++wt)

	cmp	DWORD PTR _w$[esp+112], 0
	jle	$LN4@Draw
	mov	eax, DWORD PTR _xo$[esp+112]
	mov	DWORD PTR tv816[esp+112], esi
	mov	esi, DWORD PTR _w$[esp+112]
	sub	ebx, ecx
	mov	DWORD PTR tv1317[esp+112], eax
	mov	DWORD PTR tv1342[esp+112], ecx
	mov	DWORD PTR tv1092[esp+112], ebx
	mov	DWORD PTR tv445[esp+112], esi
	jmp	SHORT $LN6@Draw
	npad	2
$LL72@Draw:
	mov	ebx, DWORD PTR tv1092[esp+112]
	mov	edi, DWORD PTR _sw$134410[esp+112]
$LN6@Draw:

; 696  : 				{
; 697  : 					if(wt+xo >= sw[1]) {while(wt+xo >= sw[1]) sw += 2; color = sw[-2];}

	mov	esi, DWORD PTR tv816[esp+112]
	cmp	eax, DWORD PTR [esi]
	jb	SHORT $LN3@Draw
$LL2@Draw:
	add	edi, 8
	lea	edx, DWORD PTR [edi+4]
	mov	DWORD PTR tv816[esp+112], edx
	cmp	eax, DWORD PTR [edx]
	jae	SHORT $LL2@Draw
	mov	edx, DWORD PTR [edi-8]
	mov	DWORD PTR _sw$134410[esp+112], edi
	mov	DWORD PTR _color$[esp+112], edx
$LN3@Draw:

; 698  : 					pixmix_c(&dst[wt], color, src[wt*4]);

	movzx	eax, BYTE PTR [ecx+ebx]
	mov	ecx, DWORD PTR [ecx]
	mov	esi, edx
	shr	esi, 24					; 00000018H
	imul	eax, esi
	mov	edi, ecx
	shr	edi, 8
	shr	eax, 6
	and	eax, 255				; 000000ffH
	and	edi, -65281				; ffff00ffH
	mov	ebx, edx
	shr	ebx, 8
	and	ebx, 255				; 000000ffH
	imul	ebx, eax
	mov	esi, 255				; 000000ffH
	sub	esi, eax
	imul	edi, esi
	add	edi, ebx
	mov	ebx, ecx
	mov	DWORD PTR _ia$233734[esp+112], esi
	and	ebx, 16711935				; 00ff00ffH
	imul	ebx, esi
	mov	esi, edx
	and	esi, 16711935				; 00ff00ffH
	imul	esi, eax
	add	ebx, esi
	shr	ecx, 8
	and	ecx, 16711935				; 00ff00ffH
	imul	ecx, DWORD PTR _ia$233734[esp+112]
	mov	esi, edx
	shr	esi, 8
	and	esi, 255				; 000000ffH
	imul	esi, eax
	mov	eax, DWORD PTR tv1317[esp+112]
	shr	ebx, 8
	xor	edi, ebx
	add	ecx, esi
	and	edi, 16711935				; 00ff00ffH
	xor	edi, ecx
	mov	ecx, DWORD PTR tv1342[esp+112]
	mov	DWORD PTR [ecx], edi
	inc	eax
	add	ecx, 4
	sub	DWORD PTR tv445[esp+112], 1
	mov	DWORD PTR tv1317[esp+112], eax
	mov	DWORD PTR tv1342[esp+112], ecx
	jne	$LL72@Draw
$LN78@Draw:

; 694  : 				else
; 695  : 				for(int wt=0; wt<w; ++wt)

	mov	ecx, DWORD PTR _dst$[esp+112]
$LN79@Draw:
	mov	ebx, DWORD PTR _src$[esp+112]
$LN4@Draw:

; 699  : 				}
; 700  : 			}
; 701  : 
; 702  : 			src += 4*mOverlayWidth;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+116]
	lea	ebx, DWORD PTR [ebx+eax*4]

; 703  : 			dst = (DWORD*)((BYTE*)dst + spd.pitch);

	mov	eax, DWORD PTR _spd$[ebp]
	add	ecx, DWORD PTR [eax+16]
	cmp	DWORD PTR _h$[esp+112], 0
	mov	DWORD PTR _src$[esp+112], ebx
	mov	DWORD PTR _dst$[esp+112], ecx
	jne	$LL77@Draw
$LN27@Draw:

; 662  : 
; 663  : 		if(w <= 0 || h <= 0) return bbox;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN34@Draw:

; 704  : 		}
; 705  : 
; 706  : 		return bbox;
; 707  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?Draw@Rasterizer@ssf@@QAE?AVCRect@@ABUSubPicDesc@@ABV3@HHPBKH@Z ENDP ; ssf::Rasterizer::Draw
_TEXT	ENDS
PUBLIC	?Reuse@Rasterizer@ssf@@QAEXAAV12@@Z		; ssf::Rasterizer::Reuse
; Function compile flags: /Ogtpy
;	COMDAT ?Reuse@Rasterizer@ssf@@QAEXAAV12@@Z
_TEXT	SEGMENT
?Reuse@Rasterizer@ssf@@QAEXAAV12@@Z PROC		; ssf::Rasterizer::Reuse, COMDAT
; _this$ = ecx
; _r$ = eax

; 599  : 		mWidth = r.mWidth;

	mov	edx, DWORD PTR [eax+24]
	mov	DWORD PTR [ecx+24], edx

; 600  : 		mHeight = r.mHeight;

	mov	edx, DWORD PTR [eax+28]
	mov	DWORD PTR [ecx+28], edx

; 601  : 		mPathOffsetX = r.mPathOffsetX;

	mov	edx, DWORD PTR [eax+124]
	mov	DWORD PTR [ecx+124], edx

; 602  : 		mPathOffsetY = r.mPathOffsetY;

	mov	edx, DWORD PTR [eax+128]
	mov	DWORD PTR [ecx+128], edx

; 603  : 		mWideBorder = r.mWideBorder;

	mov	edx, DWORD PTR [eax+92]
	mov	DWORD PTR [ecx+92], edx

; 604  : 		mOutline.Move(r.mOutline);

	mov	edx, DWORD PTR [ecx+36]
	push	esi
	mov	esi, DWORD PTR [eax+36]
	mov	DWORD PTR [ecx+36], esi
	mov	esi, DWORD PTR [eax+40]
	mov	DWORD PTR [eax+36], edx
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [ecx+40], esi
	mov	esi, DWORD PTR [eax+44]
	mov	DWORD PTR [eax+40], edx
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [ecx+44], esi
	mov	esi, DWORD PTR [eax+48]
	mov	DWORD PTR [eax+44], edx
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [ecx+48], esi
	mov	DWORD PTR [eax+48], edx
	push	edi
	xor	esi, esi
	mov	DWORD PTR [eax+40], esi

; 605  : 		mWideOutline.Move(r.mWideOutline);

	mov	edx, DWORD PTR [ecx+56]
	mov	edi, DWORD PTR [eax+56]
	mov	DWORD PTR [ecx+56], edi
	mov	edi, DWORD PTR [eax+60]
	mov	DWORD PTR [eax+56], edx
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [ecx+60], edi
	mov	edi, DWORD PTR [eax+64]
	mov	DWORD PTR [eax+60], edx
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR [ecx+64], edi
	mov	edi, DWORD PTR [eax+68]
	mov	DWORD PTR [eax+64], edx
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [ecx+68], edi
	pop	edi
	mov	DWORD PTR [eax+60], esi
	mov	DWORD PTR [eax+68], edx
	pop	esi

; 606  : 	}

	ret	0
?Reuse@Rasterizer@ssf@@QAEXAAV12@@Z ENDP		; ssf::Rasterizer::Reuse
_TEXT	ENDS
PUBLIC	?Rasterize@Rasterizer@ssf@@QAE_NHH@Z		; ssf::Rasterizer::Rasterize
; Function compile flags: /Ogtpy
;	COMDAT ?Rasterize@Rasterizer@ssf@@QAE_NHH@Z
_TEXT	SEGMENT
_i$134258 = -24						; size = 4
_x2$134270 = -20					; size = 4
tv318 = -16						; size = 4
_last$134273 = -12					; size = 4
_pOutline$ = -8						; size = 8
_xsub$ = 8						; size = 4
_ysub$ = 12						; size = 4
?Rasterize@Rasterizer@ssf@@QAE_NHH@Z PROC		; ssf::Rasterizer::Rasterize, COMDAT
; _this$ = esi

; 461  : 		_TrashOverlay();

	mov	eax, DWORD PTR [esi+112]
	sub	esp, 24					; 00000018H
	push	ebx
	mov	ebx, DWORD PTR _xsub$[esp+24]
	push	ebp
	xor	ebp, ebp
	push	edi
	mov	edi, DWORD PTR _ysub$[esp+32]
	cmp	eax, ebp
	je	SHORT $LN26@Rasterize
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN26@Rasterize:

; 462  : 
; 463  : 		if(!mWidth || !mHeight)

	mov	ecx, DWORD PTR [esi+24]
	mov	DWORD PTR [esi+112], ebp
	cmp	ecx, ebp
	je	$LN20@Rasterize
	mov	edx, DWORD PTR [esi+28]
	cmp	edx, ebp
	je	$LN20@Rasterize

; 467  : 		}
; 468  : 
; 469  : 		xsub >>= FONT_SCALE;
; 470  : 		ysub >>= FONT_SCALE;
; 471  : 
; 472  : 		xsub &= (1<<FONT_AA)-1;
; 473  : 		ysub &= (1<<FONT_AA)-1;
; 474  : 
; 475  : 		int width = mWidth + xsub;
; 476  : 		int height = mHeight + ysub;
; 477  : 
; 478  : 		mOffsetX = mPathOffsetX - xsub;

	mov	eax, DWORD PTR [esi+124]
	sar	ebx, 3
	and	ebx, 7
	mov	ebp, ebx
	sub	eax, ebp
	mov	DWORD PTR [esi+132], eax

; 479  : 		mOffsetY = mPathOffsetY - ysub;

	mov	eax, DWORD PTR [esi+128]
	sar	edi, 3
	and	edi, 7
	sub	eax, edi
	mov	DWORD PTR [esi+136], eax

; 480  : 
; 481  : 		int border = ((mWideBorder + ((1<<FONT_AA)-1)) & ~((1<<FONT_AA)-1)) + (1<<FONT_AA)*4;

	mov	eax, DWORD PTR [esi+92]
	add	eax, 7
	and	eax, -8					; fffffff8H
	add	ecx, ebp
	add	edx, edi
	add	eax, 32					; 00000020H

; 482  : 
; 483  : 		if(!mWideOutline.IsEmpty())

	cmp	DWORD PTR [esi+60], 0
	mov	DWORD PTR _xsub$[esp+32], ebp
	mov	DWORD PTR _ysub$[esp+32], edi
	je	SHORT $LN19@Rasterize

; 484  : 		{
; 485  : 			width += 2*border;
; 486  : 			height += 2*border;
; 487  : 
; 488  : 			xsub += border;
; 489  : 			ysub += border;
; 490  : 
; 491  : 			mOffsetX -= border;

	sub	DWORD PTR [esi+132], eax
	lea	ebx, DWORD PTR [eax+eax]
	add	ebp, eax
	add	edi, eax
	add	ecx, ebx
	add	edx, ebx

; 492  : 			mOffsetY -= border;

	sub	DWORD PTR [esi+136], eax
	mov	DWORD PTR _xsub$[esp+32], ebp
	mov	DWORD PTR _ysub$[esp+32], edi
$LN19@Rasterize:

; 493  : 		}
; 494  : 
; 495  : 		mOverlayWidth = ((width + ((1<<FONT_AA)-1)) >> FONT_AA) + 1;

	add	ecx, 7

; 496  : 		mOverlayHeight = ((height + ((1<<FONT_AA)-1)) >> FONT_AA) + 1;

	lea	eax, DWORD PTR [edx+7]
	sar	eax, 3
	inc	eax
	sar	ecx, 3
	inc	ecx
	mov	DWORD PTR [esi+120], eax

; 497  : 
; 498  : 		mpOverlayBuffer = new BYTE[4 * mOverlayWidth * mOverlayHeight];

	imul	eax, ecx
	add	eax, eax
	add	eax, eax
	push	eax
	mov	DWORD PTR [esi+116], ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 499  : 		memset(mpOverlayBuffer, 0, 4 * mOverlayWidth * mOverlayHeight);

	mov	ecx, DWORD PTR [esi+120]
	imul	ecx, DWORD PTR [esi+116]
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	0
	push	eax
	mov	DWORD PTR [esi+112], eax
	call	_memset
	add	esp, 16					; 00000010H

; 500  : 
; 501  : 		Array<Span>* pOutline[2] = {&mOutline, &mWideOutline};

	lea	edx, DWORD PTR [esi+32]
	lea	eax, DWORD PTR [esi+52]

; 502  : 
; 503  : 		for(int i = 0; i < countof(pOutline); i++)

	xor	ecx, ecx
	mov	DWORD PTR _pOutline$[esp+36], edx
	mov	DWORD PTR _pOutline$[esp+40], eax
	mov	DWORD PTR _i$134258[esp+36], ecx
	npad	4
$LL48@Rasterize:

; 504  : 		{
; 505  : 			const Span* s = pOutline[i]->GetData();

	mov	eax, DWORD PTR _pOutline$[esp+ecx*4+36]
	mov	edi, DWORD PTR [eax+4]

; 506  : 
; 507  : 			for(size_t j = 0, k = pOutline[i]->GetCount(); j < k; j++)

	mov	eax, DWORD PTR [eax+8]
	test	eax, eax
	jbe	$LN17@Rasterize
	add	edi, 4
	mov	DWORD PTR tv318[esp+36], eax
	npad	7
$LL15@Rasterize:

; 508  : 			{
; 509  : 				int y = s[j].y1 - 0x40000000 + ysub;
; 510  : 				int x1 = s[j].x1 - 0x40000000 + xsub;

	mov	ecx, DWORD PTR [edi-4]

; 511  : 				int x2 = s[j].x2 - 0x40000000 + xsub;

	mov	edx, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [edx+ebp-1073741824]
	lea	ebx, DWORD PTR [ecx+ebp-1073741824]

; 512  : 
; 513  : 				if(x2 > x1)

	cmp	edx, ebx
	mov	DWORD PTR _x2$134270[esp+36], edx
	jle	SHORT $LN14@Rasterize

; 514  : 				{
; 515  : 					int first = x1 >> FONT_AA;
; 516  : 					int last = (x2-1) >> FONT_AA;
; 517  : 
; 518  : 					BYTE* dst = mpOverlayBuffer + 4*(mOverlayWidth * (y >> FONT_AA) + first) + i;

	mov	ebp, DWORD PTR _ysub$[esp+32]
	mov	eax, DWORD PTR [edi]
	lea	eax, DWORD PTR [eax+ebp-1073741824]
	mov	ebp, DWORD PTR _i$134258[esp+36]
	sar	eax, 3
	imul	eax, DWORD PTR [esi+116]
	mov	ecx, ebx
	sar	ecx, 3
	add	eax, ecx
	dec	edx
	sar	edx, 3
	lea	eax, DWORD PTR [ebp+eax*4]
	add	eax, DWORD PTR [esi+112]
	mov	DWORD PTR _last$134273[esp+36], edx

; 519  : 
; 520  : 					if(first == last)

	cmp	ecx, edx

; 521  : 					{
; 522  : 						*dst += x2 - x1;
; 523  : 					}
; 524  : 					else

	je	SHORT $LN50@Rasterize

; 525  : 					{
; 526  : 						*dst += (((first+1) << FONT_AA) - x1) << (6 - FONT_AA*2);

	mov	dl, cl
	add	dl, dl
	add	dl, dl
	add	dl, dl
	sub	dl, bl

; 527  : 						dst += 4;
; 528  : 
; 529  : 						while(++first < last)

	mov	ebx, DWORD PTR _last$134273[esp+36]
	add	dl, 8
	add	BYTE PTR [eax], dl
	inc	ecx
	add	eax, 4
	cmp	ecx, ebx
	jge	SHORT $LN8@Rasterize
	mov	edx, ebx
	sub	edx, ecx
	npad	3
$LL9@Rasterize:

; 530  : 						{
; 531  : 							*dst += (1 << FONT_AA) << (6 - FONT_AA*2);

	add	BYTE PTR [eax], 8

; 532  : 							dst += 4;

	add	eax, 4
	sub	edx, 1
	jne	SHORT $LL9@Rasterize
$LN8@Rasterize:

; 533  : 						}
; 534  : 
; 535  : 						*dst += (x2 - (last << FONT_AA)) << (6 - FONT_AA*2);

	add	bl, bl
	add	bl, bl
	add	bl, bl
$LN50@Rasterize:
	mov	cl, BYTE PTR _x2$134270[esp+36]
	mov	ebp, DWORD PTR _xsub$[esp+32]
	sub	cl, bl
	add	BYTE PTR [eax], cl
$LN14@Rasterize:
	add	edi, 16					; 00000010H
	sub	DWORD PTR tv318[esp+36], 1
	jne	$LL15@Rasterize

; 506  : 
; 507  : 			for(size_t j = 0, k = pOutline[i]->GetCount(); j < k; j++)

	mov	ecx, DWORD PTR _i$134258[esp+36]
$LN17@Rasterize:

; 502  : 
; 503  : 		for(int i = 0; i < countof(pOutline); i++)

	inc	ecx
	mov	DWORD PTR _i$134258[esp+36], ecx
	cmp	ecx, 2
	jb	$LL48@Rasterize

; 536  : 					}
; 537  : 				}
; 538  : 			}
; 539  : 		}
; 540  : 
; 541  : 		if(!mWideOutline.IsEmpty())

	cmp	DWORD PTR [esi+60], 0
	je	SHORT $LN4@Rasterize

; 542  : 		{
; 543  : 			BYTE* p = mpOverlayBuffer;

	mov	ebx, DWORD PTR [esi+112]

; 544  : 
; 545  : 			for(int j = 0; j < mOverlayHeight; j++, p += mOverlayWidth*4)

	xor	ebp, ebp
	cmp	DWORD PTR [esi+120], ebp
	jle	SHORT $LN4@Rasterize
	npad	3
$LL49@Rasterize:

; 546  : 			{
; 547  : 				for(int i = 0; i < mOverlayWidth; i++)

	xor	edi, edi
	cmp	DWORD PTR [esi+116], edi
	jle	SHORT $LN5@Rasterize
	lea	eax, DWORD PTR [ebx+1]
	npad	6
$LL3@Rasterize:

; 548  : 				{
; 549  : 					p[i*4+2] = min(p[i*4+1], (1<<6) - p[i*4]); // TODO: sse2

	movzx	edx, BYTE PTR [eax-1]
	mov	ecx, 64					; 00000040H
	sub	ecx, edx
	movzx	edx, BYTE PTR [eax]
	cmp	edx, ecx
	jge	SHORT $LN24@Rasterize
	mov	ecx, edx
$LN24@Rasterize:
	mov	BYTE PTR [eax+1], cl
	inc	edi
	add	eax, 4
	cmp	edi, DWORD PTR [esi+116]
	jl	SHORT $LL3@Rasterize
$LN5@Rasterize:

; 544  : 
; 545  : 			for(int j = 0; j < mOverlayHeight; j++, p += mOverlayWidth*4)

	mov	eax, DWORD PTR [esi+116]
	inc	ebp
	cmp	ebp, DWORD PTR [esi+120]
	lea	ebx, DWORD PTR [ebx+eax*4]
	jl	SHORT $LL49@Rasterize
	pop	edi
	pop	ebp
	mov	al, 1
	pop	ebx

; 550  : 				}
; 551  : 			}
; 552  : 		}
; 553  : 
; 554  : 		return true;
; 555  : 	}

	add	esp, 24					; 00000018H
	ret	8
$LN20@Rasterize:

; 464  : 		{
; 465  : 			mOverlayWidth = mOverlayHeight = 0;

	mov	DWORD PTR [esi+120], ebp
	mov	DWORD PTR [esi+116], ebp
$LN4@Rasterize:
	pop	edi
	pop	ebp

; 466  : 			return true;

	mov	al, 1
	pop	ebx

; 550  : 				}
; 551  : 			}
; 552  : 		}
; 553  : 
; 554  : 		return true;
; 555  : 	}

	add	esp, 24					; 00000018H
	ret	8
?Rasterize@Rasterizer@ssf@@QAE_NHH@Z ENDP		; ssf::Rasterizer::Rasterize
_TEXT	ENDS
PUBLIC	?_OverlapRegion@Rasterizer@ssf@@AAEXAAV?$Array@TSpan@Rasterizer@ssf@@@2@0HH@Z ; ssf::Rasterizer::_OverlapRegion
; Function compile flags: /Ogtpy
;	COMDAT ?_OverlapRegion@Rasterizer@ssf@@AAEXAAV?$Array@TSpan@Rasterizer@ssf@@@2@0HH@Z
_TEXT	SEGMENT
_ae$ = -52						; size = 4
tv425 = -48						; size = 8
tv396 = -48						; size = 4
$T233957 = -40						; size = 8
_o$ = -32						; size = 16
$T233889 = -16						; size = 16
_x$134190 = -16						; size = 16
_dst$ = 8						; size = 4
_be$ = 12						; size = 4
_src$ = 12						; size = 4
$T233997 = 16						; size = 4
_dx$ = 16						; size = 4
?_OverlapRegion@Rasterizer@ssf@@AAEXAAV?$Array@TSpan@Rasterizer@ssf@@@2@0HH@Z PROC ; ssf::Rasterizer::_OverlapRegion, COMDAT
; _this$ = eax
; _dy$ = edx

; 342  : 	{

	sub	esp, 52					; 00000034H

; 343  : 		mWideOutlineTmp.Move(dst);

	mov	ecx, DWORD PTR [eax+76]
	push	ebx
	mov	ebx, DWORD PTR _src$[esp+52]
	push	ebp
	mov	ebp, DWORD PTR _dst$[esp+56]
	push	esi
	mov	esi, DWORD PTR [ebp+4]
	mov	DWORD PTR [eax+76], esi
	mov	esi, DWORD PTR [ebp+8]
	mov	DWORD PTR [ebp+4], ecx
	mov	ecx, DWORD PTR [eax+80]
	mov	DWORD PTR [eax+80], esi
	mov	esi, DWORD PTR [ebp+12]
	mov	DWORD PTR [ebp+8], ecx
	mov	ecx, DWORD PTR [eax+84]
	mov	DWORD PTR [eax+84], esi
	mov	esi, DWORD PTR [ebp+16]
	mov	DWORD PTR [ebp+12], ecx
	mov	ecx, DWORD PTR [eax+88]
	mov	DWORD PTR [eax+88], esi
	mov	DWORD PTR [ebp+16], ecx
	mov	DWORD PTR [ebp+8], 0

; 344  : 
; 345  : 		Span* a = mWideOutlineTmp.GetData();

	mov	esi, DWORD PTR [eax+76]

; 346  : 		Span* ae = a + mWideOutlineTmp.GetCount();

	mov	ecx, DWORD PTR [eax+80]

; 347  : 		Span* b = src.GetData();
; 348  : 		Span* be = b + src.GetCount();
; 349  : 
; 350  : 		Span o(0, dy, 0, dy);

	xor	eax, eax
	mov	DWORD PTR _o$[esp+64], eax
	mov	DWORD PTR _o$[esp+72], eax

; 351  : 		o.first -= dx;

	mov	eax, DWORD PTR _dx$[esp+60]
	push	edi
	mov	edi, DWORD PTR [ebx+4]
	mov	ebx, DWORD PTR [ebx+8]
	shl	ecx, 4
	shl	ebx, 4
	mov	DWORD PTR _o$[esp+72], edx
	mov	DWORD PTR _o$[esp+80], edx
	cdq
	add	ecx, esi
	add	ebx, edi
	sub	DWORD PTR _o$[esp+68], eax
	mov	DWORD PTR tv425[esp+68], eax
	mov	eax, edx
	sbb	DWORD PTR _o$[esp+72], eax
	mov	DWORD PTR tv425[esp+72], edx

; 352  : 		o.second += dx;

	mov	edx, DWORD PTR tv425[esp+68]
	add	DWORD PTR _o$[esp+76], edx
	mov	DWORD PTR _ae$[esp+68], ecx
	mov	DWORD PTR _be$[esp+64], ebx
	adc	DWORD PTR _o$[esp+80], eax

; 353  : 
; 354  : 		while(a != ae && b != be)

	cmp	esi, ecx
	je	$LN34@OverlapReg
$LL35@OverlapReg:
	cmp	edi, ebx
	je	$LN34@OverlapReg

; 355  : 		{
; 356  : 			Span x;
; 357  : 
; 358  : 			if(b->first + o.first < a->first)

	mov	edx, DWORD PTR _o$[esp+68]
	add	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR _o$[esp+72]
	adc	eax, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR [esi+4]
	ja	$LN33@OverlapReg
	jb	SHORT $LN121@OverlapReg
	cmp	edx, DWORD PTR [esi]
	jae	$LN33@OverlapReg
$LN121@OverlapReg:

; 359  : 			{
; 360  : 				// B span is earlier.  Use it.
; 361  : 
; 362  : 				x.first = b->first + o.first;
; 363  : 				x.second = b->second + o.second;

	mov	ebp, DWORD PTR [edi+8]
	add	ebp, DWORD PTR _o$[esp+76]
	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR _x$134190[esp+68], edx
	mov	edx, DWORD PTR _o$[esp+80]
	adc	ebx, edx

; 364  : 
; 365  : 				b++;

	add	edi, 16					; 00000010H
	mov	DWORD PTR _x$134190[esp+72], eax

; 366  : 
; 367  : 				// B spans don't overlap, so begin merge loop with A first.
; 368  : 
; 369  : 				for(;;)
; 370  : 				{
; 371  : 					// If we run out of A spans or the A span doesn't overlap,
; 372  : 					// then the next B span can't either (because B spans don't
; 373  : 					// overlap) and we exit.
; 374  : 
; 375  : 					if(a == ae || a->first > x.second)

	cmp	esi, ecx
	je	$LN117@OverlapReg
	jmp	SHORT $LN32@OverlapReg
	npad	2
$LL141@OverlapReg:
	mov	ecx, DWORD PTR _ae$[esp+68]
$LN32@OverlapReg:
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, ebx
	ja	$LN117@OverlapReg
	jb	SHORT $LL28@OverlapReg
	mov	eax, DWORD PTR [esi]
	cmp	eax, ebp
	ja	$LN117@OverlapReg
	npad	5
$LL28@OverlapReg:

; 376  : 						break;
; 377  : 
; 378  : 					do {x.second = mymax(x.second, a->second);}

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR $T233957[esp+68], eax
	mov	eax, DWORD PTR [esi+12]
	cmp	ebx, eax
	ja	SHORT $LN65@OverlapReg
	jb	SHORT $LN123@OverlapReg
	cmp	ebp, DWORD PTR $T233957[esp+68]
	ja	SHORT $LN65@OverlapReg
$LN123@OverlapReg:
	mov	ebp, DWORD PTR $T233957[esp+68]
	mov	ebx, eax
$LN65@OverlapReg:

; 379  : 					while(++a != ae && a->first <= x.second);

	add	esi, 16					; 00000010H
	cmp	esi, ecx
	je	SHORT $LN25@OverlapReg
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, ebx
	jb	SHORT $LL28@OverlapReg
	ja	SHORT $LN25@OverlapReg
	mov	eax, DWORD PTR [esi]
	cmp	eax, ebp
	jbe	SHORT $LL28@OverlapReg
$LN25@OverlapReg:

; 380  : 
; 381  : 					// If we run out of B spans or the B span doesn't overlap,
; 382  : 					// then the next A span can't either (because A spans don't
; 383  : 					// overlap) and we exit.
; 384  : 
; 385  : 					if(b == be || b->first + o.first > x.second)

	cmp	edi, DWORD PTR _be$[esp+64]
	je	$LN117@OverlapReg
	mov	ecx, DWORD PTR _o$[esp+68]
	add	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR _o$[esp+72]
	adc	eax, DWORD PTR [edi+4]
	cmp	eax, ebx
	ja	$LN117@OverlapReg
	jb	SHORT $LL22@OverlapReg
	cmp	ecx, ebp
	ja	$LN117@OverlapReg
	npad	5
$LL22@OverlapReg:

; 386  : 						break;
; 387  : 
; 388  : 					do {x.second = mymax(x.second, b->second + o.second);}

	mov	ecx, DWORD PTR [edi+8]
	add	ecx, DWORD PTR _o$[esp+76]
	mov	eax, DWORD PTR [edi+12]
	adc	eax, edx
	cmp	ebx, eax
	ja	SHORT $LN69@OverlapReg
	jb	SHORT $LN126@OverlapReg
	cmp	ebp, ecx
	ja	SHORT $LN69@OverlapReg
$LN126@OverlapReg:
	mov	ebp, ecx
	mov	ebx, eax
$LN69@OverlapReg:

; 389  : 					while(++b != be && b->first + o.first <= x.second);

	add	edi, 16					; 00000010H
	cmp	edi, DWORD PTR _be$[esp+64]
	je	SHORT $LN19@OverlapReg
	mov	ecx, DWORD PTR _o$[esp+68]
	add	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR _o$[esp+72]
	adc	eax, DWORD PTR [edi+4]
	cmp	eax, ebx
	jb	SHORT $LL22@OverlapReg
	ja	SHORT $LN19@OverlapReg
	cmp	ecx, ebp
	jbe	SHORT $LL22@OverlapReg
$LN19@OverlapReg:

; 366  : 
; 367  : 				// B spans don't overlap, so begin merge loop with A first.
; 368  : 
; 369  : 				for(;;)
; 370  : 				{
; 371  : 					// If we run out of A spans or the A span doesn't overlap,
; 372  : 					// then the next B span can't either (because B spans don't
; 373  : 					// overlap) and we exit.
; 374  : 
; 375  : 					if(a == ae || a->first > x.second)

	cmp	esi, DWORD PTR _ae$[esp+68]
	jne	$LL141@OverlapReg

; 390  : 				}
; 391  : 			}
; 392  : 			else

	jmp	$LN117@OverlapReg
$LN33@OverlapReg:

; 393  : 			{
; 394  : 				// A span is earlier.  Use it.
; 395  : 
; 396  : 				x = *a;

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	mov	ebp, DWORD PTR [esi+8]
	mov	ebx, DWORD PTR [esi+12]
	mov	DWORD PTR _x$134190[esp+68], ecx
	mov	DWORD PTR _x$134190[esp+72], edx

; 397  : 
; 398  : 				a++;

	add	esi, 16					; 00000010H
$LN17@OverlapReg:

; 399  : 
; 400  : 				// A spans don't overlap, so begin merge loop with B first.
; 401  : 
; 402  : 				for(;;)
; 403  : 				{
; 404  : 					// If we run out of B spans or the B span doesn't overlap,
; 405  : 					// then the next A span can't either (because A spans don't
; 406  : 					// overlap) and we exit.
; 407  : 
; 408  : 					if(b == be || b->first + o.first > x.second)

	mov	ecx, DWORD PTR _o$[esp+68]
	add	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR _o$[esp+72]
	adc	eax, DWORD PTR [edi+4]
	cmp	eax, ebx
	ja	$LN117@OverlapReg
	jb	SHORT $LL13@OverlapReg
	cmp	ecx, ebp
	ja	$LN117@OverlapReg
	npad	2
$LL13@OverlapReg:

; 409  : 						break;
; 410  : 
; 411  : 					do {x.second = mymax(x.second, b->second + o.second);}

	mov	ecx, DWORD PTR [edi+8]
	add	ecx, DWORD PTR _o$[esp+76]
	mov	eax, DWORD PTR [edi+12]
	adc	eax, DWORD PTR _o$[esp+80]
	cmp	ebx, eax
	ja	SHORT $LN73@OverlapReg
	jb	SHORT $LN129@OverlapReg
	cmp	ebp, ecx
	ja	SHORT $LN73@OverlapReg
$LN129@OverlapReg:
	mov	ebp, ecx
	mov	ebx, eax
$LN73@OverlapReg:

; 412  : 					while(++b != be && b->first + o.first <= x.second);

	add	edi, 16					; 00000010H
	cmp	edi, DWORD PTR _be$[esp+64]
	je	SHORT $LN10@OverlapReg
	mov	ecx, DWORD PTR _o$[esp+68]
	add	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR _o$[esp+72]
	adc	eax, DWORD PTR [edi+4]
	cmp	eax, ebx
	jb	SHORT $LL13@OverlapReg
	ja	SHORT $LN10@OverlapReg
	cmp	ecx, ebp
	jbe	SHORT $LL13@OverlapReg
$LN10@OverlapReg:

; 413  : 
; 414  : 					// If we run out of A spans or the A span doesn't overlap,
; 415  : 					// then the next B span can't either (because B spans don't
; 416  : 					// overlap) and we exit.
; 417  : 
; 418  : 					if(a == ae || a->first > x.second)

	cmp	esi, DWORD PTR _ae$[esp+68]
	je	SHORT $LN117@OverlapReg
	mov	eax, DWORD PTR [esi+4]
	cmp	eax, ebx
	ja	SHORT $LN117@OverlapReg
	jb	SHORT $LL7@OverlapReg
	mov	ecx, DWORD PTR [esi]
	cmp	ecx, ebp
	ja	SHORT $LN117@OverlapReg
$LL7@OverlapReg:

; 419  : 						break;
; 420  : 
; 421  : 					do {x.second = mymax(x.second, a->second);}

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+8]
	cmp	ebx, eax
	ja	SHORT $LN77@OverlapReg
	jb	SHORT $LN132@OverlapReg
	cmp	ebp, ecx
	ja	SHORT $LN77@OverlapReg
$LN132@OverlapReg:
	mov	ebp, ecx
	mov	ebx, eax
$LN77@OverlapReg:

; 422  : 					while(++a != ae && a->first <= x.second);

	add	esi, 16					; 00000010H
	cmp	esi, DWORD PTR _ae$[esp+68]
	je	SHORT $LN4@OverlapReg
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, ebx
	jb	SHORT $LL7@OverlapReg
	ja	SHORT $LN4@OverlapReg
	mov	eax, DWORD PTR [esi]
	cmp	eax, ebp
	jbe	SHORT $LL7@OverlapReg
$LN4@OverlapReg:

; 399  : 
; 400  : 				// A spans don't overlap, so begin merge loop with B first.
; 401  : 
; 402  : 				for(;;)
; 403  : 				{
; 404  : 					// If we run out of B spans or the B span doesn't overlap,
; 405  : 					// then the next A span can't either (because A spans don't
; 406  : 					// overlap) and we exit.
; 407  : 
; 408  : 					if(b == be || b->first + o.first > x.second)

	cmp	edi, DWORD PTR _be$[esp+64]
	jne	$LN17@OverlapReg
$LN117@OverlapReg:

; 423  : 				}
; 424  : 			}
; 425  : 
; 426  : 			// Flush span.
; 427  : 
; 428  : 			dst.Add(x);

	mov	ecx, DWORD PTR _dst$[esp+64]
	mov	eax, DWORD PTR [ecx+8]
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR tv396[esp+68], eax
	mov	DWORD PTR $T233997[esp+64], edx
	cmp	edx, DWORD PTR [ecx+12]
	jbe	SHORT $LN80@OverlapReg
	mov	edx, DWORD PTR [ecx+16]
	cmp	edx, eax
	jbe	SHORT $LN84@OverlapReg
	mov	eax, edx
$LN84@OverlapReg:
	mov	edx, DWORD PTR $T233997[esp+64]
	add	eax, edx
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR [ecx+4]
	shl	eax, 4
	push	16					; 00000010H
	push	eax
	test	ecx, ecx
	je	SHORT $LN86@OverlapReg
	push	ecx
	call	__aligned_realloc
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN87@OverlapReg
$LN86@OverlapReg:
	call	__aligned_malloc
	add	esp, 8
$LN87@OverlapReg:
	mov	ecx, DWORD PTR _dst$[esp+64]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR tv396[esp+68]
$LN80@OverlapReg:
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR _x$134190[esp+68]
	shl	eax, 4
	add	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _x$134190[esp+72]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR _ae$[esp+68]
	mov	DWORD PTR [eax+8], ebp
	mov	ebp, DWORD PTR _dst$[esp+64]
	mov	DWORD PTR [eax+12], ebx
	mov	ebx, DWORD PTR _be$[esp+64]
	cmp	esi, ecx
	jne	$LL35@OverlapReg
$LN34@OverlapReg:

; 429  : 		}
; 430  : 
; 431  : 		// Copy over leftover spans.
; 432  : 
; 433  : 		dst.Append(a, ae - a);

	sub	ecx, esi
	sar	ecx, 4
	test	ecx, ecx
	je	SHORT $LN89@OverlapReg
	push	ecx
	push	esi
	mov	esi, ebp
	call	?Append@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEXPBTSpan@Rasterizer@2@II@Z ; ssf::Array<ssf::Rasterizer::Span>::Append
$LN89@OverlapReg:

; 434  : 
; 435  : 		for(; b != be; b++)

	cmp	edi, ebx
	je	$LN1@OverlapReg
$LN3@OverlapReg:

; 436  : 		{
; 437  : 			dst.Add(Span(b->first + o.first, b->second + o.second));

	mov	ebx, DWORD PTR _o$[esp+68]
	add	ebx, DWORD PTR [edi]
	mov	eax, DWORD PTR _o$[esp+72]
	adc	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi+8]
	add	ecx, DWORD PTR _o$[esp+76]
	mov	edx, DWORD PTR [edi+12]
	adc	edx, DWORD PTR _o$[esp+80]
	mov	esi, DWORD PTR [ebp+8]
	mov	DWORD PTR $T233889[esp+80], edx
	lea	edx, DWORD PTR [esi+1]
	mov	DWORD PTR $T233889[esp+72], eax
	mov	DWORD PTR $T233889[esp+76], ecx
	cmp	edx, DWORD PTR [ebp+12]
	jbe	SHORT $LN99@OverlapReg
	mov	eax, DWORD PTR [ebp+16]
	cmp	eax, esi
	ja	SHORT $LN104@OverlapReg
	mov	eax, esi
$LN104@OverlapReg:
	mov	ecx, DWORD PTR [ebp+4]
	add	eax, edx
	mov	DWORD PTR [ebp+12], eax
	shl	eax, 4
	push	16					; 00000010H
	push	eax
	test	ecx, ecx
	je	SHORT $LN105@OverlapReg
	push	ecx
	call	__aligned_realloc
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN106@OverlapReg
$LN105@OverlapReg:
	call	__aligned_malloc
	add	esp, 8
$LN106@OverlapReg:
	mov	ecx, DWORD PTR $T233889[esp+76]
	mov	DWORD PTR [ebp+4], eax
	mov	eax, DWORD PTR $T233889[esp+72]
$LN99@OverlapReg:
	lea	edx, DWORD PTR [esi+1]
	shl	esi, 4
	add	esi, DWORD PTR [ebp+4]
	mov	DWORD PTR [ebp+8], edx
	mov	edx, DWORD PTR $T233889[esp+80]
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+4], eax
	add	edi, 16					; 00000010H
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+12], edx
	cmp	edi, DWORD PTR _be$[esp+64]
	jne	$LN3@OverlapReg
$LN1@OverlapReg:

; 438  : 		}
; 439  : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 52					; 00000034H
	ret	12					; 0000000cH
?_OverlapRegion@Rasterizer@ssf@@AAEXAAV?$Array@TSpan@Rasterizer@ssf@@@2@0HH@Z ENDP ; ssf::Rasterizer::_OverlapRegion
_TEXT	ENDS
PUBLIC	?_EvaluateLine@Rasterizer@ssf@@AAEXVCPoint@@0@Z	; ssf::Rasterizer::_EvaluateLine
; Function compile flags: /Ogtpy
;	COMDAT ?_EvaluateLine@Rasterizer@ssf@@AAEXVCPoint@@0@Z
_TEXT	SEGMENT
_xacc$133542 = -8					; size = 4
_invslope$133532 = -8					; size = 4
_dy$133528 = -8						; size = 4
_dy$133543 = -4						; size = 4
_xacc$133527 = -4					; size = 4
_p0$ = 8						; size = 8
_p1$ = 16						; size = 8
?_EvaluateLine@Rasterizer@ssf@@AAEXVCPoint@@0@Z PROC	; ssf::Rasterizer::_EvaluateLine, COMDAT
; _this$ = ecx

; 98   : 		if(lastp != p0)

	mov	edx, DWORD PTR _p0$[esp-4]
	sub	esp, 12					; 0000000cH
	push	ebx
	mov	ebx, DWORD PTR _p0$[esp+16]
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi
	cmp	DWORD PTR [esi+16], edx
	jne	SHORT $LN20@EvaluateLi
	cmp	DWORD PTR [esi+20], ebx
	je	SHORT $LN15@EvaluateLi
$LN20@EvaluateLi:

; 99   : 		{
; 100  : 			_EvaluateLine(lastp, p0);

	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [esi+16]
	push	ebx
	push	edx
	push	eax
	push	ecx
	mov	ecx, esi
	call	?_EvaluateLine@Rasterizer@ssf@@AAEXVCPoint@@0@Z ; ssf::Rasterizer::_EvaluateLine
	mov	ebx, DWORD PTR _p0$[esp+28]
	mov	edx, DWORD PTR _p0$[esp+24]
$LN15@EvaluateLi:

; 101  : 		}
; 102  : 
; 103  : 		if(!fFirstSet)

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN14@EvaluateLi

; 104  : 		{
; 105  : 			firstp = p0; 

	mov	DWORD PTR [esi+8], edx
	mov	DWORD PTR [esi+12], ebx

; 106  : 			fFirstSet = true;

	mov	BYTE PTR [esi+4], 1
$LN14@EvaluateLi:

; 107  : 		}
; 108  : 
; 109  : 		lastp = p1;

	mov	ecx, DWORD PTR _p1$[esp+28]

; 110  : 
; 111  : 		// TODO: ((1<<FONT_SCALE)/2+-1)  
; 112  : 
; 113  : 		if(p1.y > p0.y)	// down

	cmp	ecx, ebx
	mov	eax, DWORD PTR _p1$[esp+24]
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], ecx
	jle	$LN35@EvaluateLi

; 114  : 		{
; 115  : 			int xacc = p0.x << (8 - FONT_SCALE);

	mov	eax, edx
	shl	eax, 5

; 116  : 
; 117  : 			// prestep p0.y down
; 118  : 
; 119  : 			int dy = p1.y - p0.y;
; 120  : 			int y = ((p0.y + ((1<<FONT_SCALE)/2-1)) & ~((1<<FONT_SCALE)-1)) + (1<<FONT_SCALE)/2;

	lea	ebp, DWORD PTR [ebx+3]
	and	ebp, -8					; fffffff8H
	mov	DWORD PTR _xacc$133527[esp+28], eax
	mov	eax, ecx
	add	ebp, 4

; 121  : 			int iy = y >> FONT_SCALE;
; 122  : 
; 123  : 			p1.y = (p1.y - ((1<<FONT_SCALE)/2+1)) >> FONT_SCALE;

	add	ecx, -5					; fffffffbH
	mov	edi, ebp
	sar	ecx, 3
	sub	eax, ebx
	sar	edi, 3

; 124  : 
; 125  : 			if(iy <= p1.y)

	cmp	edi, ecx
	mov	DWORD PTR _dy$133528[esp+28], eax
	mov	DWORD PTR _p1$[esp+28], ecx
	jg	$LN1@EvaluateLi

; 126  : 			{
; 127  : 				int invslope = ((p1.x - p0.x) << 8) / dy;

	mov	eax, DWORD PTR _p1$[esp+24]
	sub	eax, edx
	shl	eax, 8
	cdq
	idiv	DWORD PTR _dy$133528[esp+28]

; 128  : 
; 129  : 				while(mEdgeNext + p1.y + 1 - iy > mEdgeHeapSize)

	mov	edx, DWORD PTR [esi+104]
	sub	edx, edi
	lea	edx, DWORD PTR [edx+ecx+1]
	mov	DWORD PTR _invslope$133532[esp+28], eax
	cmp	edx, DWORD PTR [esi+100]
	jbe	SHORT $LN10@EvaluateLi
	npad	5
$LL11@EvaluateLi:

; 130  : 					_ReallocEdgeBuffer(mEdgeHeapSize*2);

	mov	eax, DWORD PTR [esi+100]
	mov	ecx, DWORD PTR [esi+96]
	add	eax, eax
	mov	DWORD PTR [esi+100], eax
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	call	_realloc
	mov	ecx, DWORD PTR _p1$[esp+36]
	mov	DWORD PTR [esi+96], eax
	mov	edx, DWORD PTR [esi+104]
	sub	edx, edi
	lea	eax, DWORD PTR [edx+ecx+1]
	add	esp, 8
	cmp	eax, DWORD PTR [esi+100]
	ja	SHORT $LL11@EvaluateLi
	mov	ebx, DWORD PTR _p0$[esp+28]
	mov	eax, DWORD PTR _invslope$133532[esp+28]
$LN10@EvaluateLi:

; 131  : 
; 132  : 				xacc += (invslope * (y - p0.y)) >> FONT_SCALE;

	mov	edx, DWORD PTR _xacc$133527[esp+28]
	sub	ebp, ebx
	imul	ebp, eax
	sar	ebp, 3
	add	edx, ebp

; 133  : 
; 134  : 				while(iy <= p1.y)

	cmp	edi, ecx
	jg	$LN1@EvaluateLi

; 131  : 
; 132  : 				xacc += (invslope * (y - p0.y)) >> FONT_SCALE;

	lea	ecx, DWORD PTR [edx+128]
$LL9@EvaluateLi:

; 135  : 				{
; 136  : 					int ix = (xacc + 128) >> 8;
; 137  : 
; 138  : 					mpEdgeBuffer[mEdgeNext].next = mpScanBuffer[iy];

	mov	edx, DWORD PTR [esi+108]
	mov	edx, DWORD PTR [edx+edi*4]
	mov	ebx, DWORD PTR [esi+104]
	mov	ebp, DWORD PTR [esi+96]
	mov	DWORD PTR [ebp+ebx*8], edx

; 139  : 					mpEdgeBuffer[mEdgeNext].posandflag = ix*2 + 1;

	mov	ebx, DWORD PTR [esi+104]
	mov	ebp, DWORD PTR [esi+96]
	mov	edx, ecx
	sar	edx, 8
	lea	edx, DWORD PTR [edx+edx+1]
	mov	DWORD PTR [ebp+ebx*8+4], edx

; 140  : 
; 141  : 					mpScanBuffer[iy] = mEdgeNext++;

	mov	ebx, DWORD PTR [esi+104]
	mov	edx, DWORD PTR [esi+108]
	mov	DWORD PTR [edx+edi*4], ebx
	inc	DWORD PTR [esi+104]

; 142  : 
; 143  : 					++iy;

	inc	edi

; 144  : 					xacc += invslope;

	add	ecx, eax
	cmp	edi, DWORD PTR _p1$[esp+28]
	jle	SHORT $LL9@EvaluateLi

; 180  : 				}
; 181  : 			}
; 182  : 		}
; 183  : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	16					; 00000010H
$LN35@EvaluateLi:

; 145  : 				}
; 146  : 			}
; 147  : 		}
; 148  : 		else if(p1.y < p0.y) // up

	jge	$LN1@EvaluateLi

; 149  : 		{
; 150  : 			int xacc = p1.x << (8 - FONT_SCALE);

	shl	eax, 5

; 151  : 
; 152  : 			// prestep p1.y down
; 153  : 
; 154  : 			int dy = p0.y - p1.y;
; 155  : 			int y = ((p1.y + ((1<<FONT_SCALE)/2-1)) & ~((1<<FONT_SCALE)-1)) + (1<<FONT_SCALE)/2;

	lea	ebp, DWORD PTR [ecx+3]
	mov	DWORD PTR _xacc$133542[esp+28], eax
	and	ebp, -8					; fffffff8H
	mov	eax, ebx
	sub	eax, ecx
	add	ebp, 4

; 156  : 			int iy = y >> FONT_SCALE;

	mov	edi, ebp

; 157  : 
; 158  : 			p0.y = (p0.y - ((1<<FONT_SCALE)/2+1)) >> FONT_SCALE;

	lea	ecx, DWORD PTR [ebx-5]
	sar	ecx, 3
	sar	edi, 3

; 159  : 
; 160  : 			if(iy <= p0.y)

	cmp	edi, ecx
	mov	DWORD PTR _dy$133543[esp+28], eax
	mov	DWORD PTR _p0$[esp+28], ecx
	jg	$LN1@EvaluateLi

; 161  : 			{
; 162  : 				int invslope = ((p0.x - p1.x) << 8) / dy;

	mov	eax, edx
	sub	eax, DWORD PTR _p1$[esp+24]
	shl	eax, 8
	cdq
	idiv	DWORD PTR _dy$133543[esp+28]
	mov	ebx, eax

; 163  : 
; 164  : 				while(mEdgeNext + p0.y + 1 - iy > mEdgeHeapSize)

	mov	eax, DWORD PTR [esi+104]
	sub	eax, edi
	lea	edx, DWORD PTR [eax+ecx+1]
	cmp	edx, DWORD PTR [esi+100]
	jbe	SHORT $LN3@EvaluateLi
	npad	7
$LL4@EvaluateLi:

; 165  : 					_ReallocEdgeBuffer(mEdgeHeapSize*2);

	mov	eax, DWORD PTR [esi+100]
	mov	ecx, DWORD PTR [esi+96]
	add	eax, eax
	mov	DWORD PTR [esi+100], eax
	add	eax, eax
	add	eax, eax
	add	eax, eax
	push	eax
	push	ecx
	call	_realloc
	mov	ecx, DWORD PTR _p0$[esp+36]
	mov	DWORD PTR [esi+96], eax
	mov	edx, DWORD PTR [esi+104]
	sub	edx, edi
	lea	eax, DWORD PTR [edx+ecx+1]
	add	esp, 8
	cmp	eax, DWORD PTR [esi+100]
	ja	SHORT $LL4@EvaluateLi
$LN3@EvaluateLi:

; 166  : 
; 167  : 				xacc += (invslope * (y - p1.y)) >> FONT_SCALE;

	sub	ebp, DWORD PTR _p1$[esp+28]
	mov	eax, DWORD PTR _xacc$133542[esp+28]
	imul	ebp, ebx
	sar	ebp, 3
	add	eax, ebp

; 168  : 
; 169  : 				while(iy <= p0.y)

	cmp	edi, ecx
	jg	SHORT $LN1@EvaluateLi

; 166  : 
; 167  : 				xacc += (invslope * (y - p1.y)) >> FONT_SCALE;

	sub	eax, -128				; ffffff80H
$LL2@EvaluateLi:

; 170  : 				{
; 171  : 					int ix = (xacc + 128) >> 8;
; 172  : 
; 173  : 					mpEdgeBuffer[mEdgeNext].next = mpScanBuffer[iy];

	mov	ecx, DWORD PTR [esi+108]
	mov	ecx, DWORD PTR [ecx+edi*4]
	mov	edx, DWORD PTR [esi+104]
	mov	ebp, DWORD PTR [esi+96]
	mov	DWORD PTR [ebp+edx*8], ecx

; 174  : 					mpEdgeBuffer[mEdgeNext].posandflag = ix*2;

	mov	ecx, DWORD PTR [esi+104]
	mov	ebp, DWORD PTR [esi+96]
	mov	edx, eax
	sar	edx, 8
	add	edx, edx
	mov	DWORD PTR [ebp+ecx*8+4], edx

; 175  : 
; 176  : 					mpScanBuffer[iy] = mEdgeNext++;

	mov	ecx, DWORD PTR [esi+104]
	mov	edx, DWORD PTR [esi+108]
	mov	DWORD PTR [edx+edi*4], ecx
	inc	DWORD PTR [esi+104]

; 177  : 
; 178  : 					++iy;

	inc	edi

; 179  : 					xacc += invslope;

	add	eax, ebx
	cmp	edi, DWORD PTR _p0$[esp+28]
	jle	SHORT $LL2@EvaluateLi
$LN1@EvaluateLi:

; 180  : 				}
; 181  : 			}
; 182  : 		}
; 183  : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	16					; 00000010H
?_EvaluateLine@Rasterizer@ssf@@AAEXVCPoint@@0@Z ENDP	; ssf::Rasterizer::_EvaluateLine
_TEXT	ENDS
PUBLIC	?_EvaluateBezier@Rasterizer@ssf@@AAEXABVCPoint@@000@Z ; ssf::Rasterizer::_EvaluateBezier
; Function compile flags: /Ogtpy
;	COMDAT ?_EvaluateBezier@Rasterizer@ssf@@AAEXABVCPoint@@000@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
tv453 = -44						; size = 4
_p01$133512 = -44					; size = 8
tv482 = -36						; size = 4
_p012$133515 = -36					; size = 8
tv476 = -28						; size = 4
_p0123$133517 = -28					; size = 8
_p23$133514 = -20					; size = 8
_p123$133516 = -12					; size = 8
_p0$ = 8						; size = 4
tv465 = 12						; size = 4
_p1$ = 12						; size = 4
_p2$ = 16						; size = 4
_p3$ = 20						; size = 4
?_EvaluateBezier@Rasterizer@ssf@@AAEXABVCPoint@@000@Z PROC ; ssf::Rasterizer::_EvaluateBezier, COMDAT
; _this$ = ecx

; 66   : 	{

	sub	esp, 52					; 00000034H

; 67   : 		if(abs(p0.x + p2.x - p1.x*2) +
; 68   : 		   abs(p0.y + p2.y - p1.y*2) +
; 69   : 		   abs(p1.x + p3.x - p2.x*2) +
; 70   : 		   abs(p1.y + p3.y - p2.y*2) <= max(2, 1<<FONT_AA))

	mov	eax, DWORD PTR _p0$[esp+48]
	mov	DWORD PTR _this$[esp+52], ecx
	mov	ecx, DWORD PTR _p3$[esp+48]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv482[esp+60], eax
	push	esi
	mov	esi, DWORD PTR _p1$[esp+60]
	mov	DWORD PTR tv465[esp+60], edx
	mov	edx, DWORD PTR _p2$[esp+60]
	mov	ebx, DWORD PTR [edx]
	push	edi
	mov	edi, DWORD PTR [esi]
	lea	edx, DWORD PTR [edi+edi]
	sub	eax, edx
	add	eax, ebx
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR tv453[esp+68], eax
	mov	eax, ecx
	lea	edx, DWORD PTR [ebx+ebx]
	sub	eax, edx
	add	eax, edi
	cdq
	xor	eax, edx
	sub	eax, edx
	mov	DWORD PTR tv476[esp+68], ecx
	mov	ecx, DWORD PTR tv453[esp+68]
	add	ecx, eax
	mov	eax, DWORD PTR _p2$[esp+64]
	mov	eax, DWORD PTR [eax+4]
	lea	edx, DWORD PTR [eax+eax]
	mov	eax, DWORD PTR tv465[esp+64]
	sub	eax, edx
	add	eax, DWORD PTR [esi+4]
	cdq
	xor	eax, edx
	sub	eax, edx
	add	ecx, eax
	mov	eax, DWORD PTR [esi+4]
	add	eax, eax
	mov	edx, eax
	mov	eax, DWORD PTR _p2$[esp+64]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, edx
	add	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	add	ecx, eax
	cmp	ecx, 8
	jg	SHORT $LN2@EvaluateBe

; 71   : 		{
; 72   : 			_EvaluateLine(p0, p3);

	mov	eax, DWORD PTR _p3$[esp+64]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR _p0$[esp+64]
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	push	edx
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+80]
	push	edx
	call	?_EvaluateLine@Rasterizer@ssf@@AAEXVCPoint@@0@Z ; ssf::Rasterizer::_EvaluateLine

; 93   : 		}
; 94   : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 52					; 00000034H
	ret	16					; 00000010H
$LN2@EvaluateBe:

; 73   : 		}
; 74   : 		else
; 75   : 		{
; 76   : 			CPoint p01, p12, p23, p012, p123, p0123;
; 77   : 
; 78   : 			p01.x = (p0.x + p1.x + 1) >> 1;

	mov	eax, DWORD PTR tv482[esp+68]

; 79   : 			p01.y = (p0.y + p1.y + 1) >> 1;

	mov	ecx, DWORD PTR [esi+4]
	lea	edx, DWORD PTR [eax+edi+1]
	lea	esi, DWORD PTR [ecx+ebp+1]

; 80   : 			p12.x = (p1.x + p2.x + 1) >> 1;

	lea	eax, DWORD PTR [edi+ebx+1]

; 81   : 			p12.y = (p1.y + p2.y + 1) >> 1;

	mov	edi, DWORD PTR _p2$[esp+64]
	mov	ebp, DWORD PTR [edi+4]

; 82   : 			p23.x = (p2.x + p3.x + 1) >> 1;

	mov	edi, DWORD PTR tv476[esp+68]
	sar	edx, 1
	sar	eax, 1
	lea	ecx, DWORD PTR [ecx+ebp+1]
	lea	edi, DWORD PTR [edi+ebx+1]

; 83   : 			p23.y = (p2.y + p3.y + 1) >> 1;

	mov	ebx, DWORD PTR tv465[esp+64]
	mov	DWORD PTR _p01$133512[esp+68], edx

; 84   : 			p012.x = (p01.x + p12.x + 1) >> 1;

	lea	edx, DWORD PTR [eax+edx+1]
	sar	ecx, 1
	sar	esi, 1
	mov	DWORD PTR _p01$133512[esp+72], esi

; 85   : 			p012.y = (p01.y + p12.y + 1) >> 1;

	lea	esi, DWORD PTR [ecx+esi+1]
	sar	edi, 1

; 86   : 			p123.x = (p12.x + p23.x + 1) >> 1;

	lea	eax, DWORD PTR [edi+eax+1]
	sar	edx, 1
	sar	eax, 1
	lea	ebx, DWORD PTR [ebx+ebp+1]
	sar	ebx, 1

; 87   : 			p123.y = (p12.y + p23.y + 1) >> 1;

	lea	ecx, DWORD PTR [ebx+ecx+1]
	sar	ecx, 1
	mov	DWORD PTR _p012$133515[esp+68], edx

; 88   : 			p0123.x = (p012.x + p123.x + 1) >> 1;

	lea	edx, DWORD PTR [eax+edx+1]
	sar	esi, 1
	mov	DWORD PTR _p123$133516[esp+68], eax

; 89   : 			p0123.y = (p012.y + p123.y + 1) >> 1;

	lea	eax, DWORD PTR [ecx+esi+1]
	mov	DWORD PTR _p123$133516[esp+72], ecx
	sar	edx, 1
	sar	eax, 1

; 90   : 
; 91   : 			_EvaluateBezier(p0, p01, p012, p0123);

	lea	ecx, DWORD PTR _p0123$133517[esp+68]
	push	ecx
	mov	ecx, DWORD PTR _p0$[esp+68]
	mov	DWORD PTR _p0123$133517[esp+72], edx
	lea	edx, DWORD PTR _p012$133515[esp+72]
	mov	DWORD PTR _p0123$133517[esp+76], eax
	push	edx
	lea	eax, DWORD PTR _p01$133512[esp+76]
	mov	DWORD PTR _p012$133515[esp+80], esi
	mov	esi, DWORD PTR _this$[esp+76]
	push	eax
	push	ecx
	mov	ecx, esi
	mov	DWORD PTR _p23$133514[esp+84], edi
	mov	DWORD PTR _p23$133514[esp+88], ebx
	call	?_EvaluateBezier@Rasterizer@ssf@@AAEXABVCPoint@@000@Z ; ssf::Rasterizer::_EvaluateBezier

; 92   : 			_EvaluateBezier(p0123, p123, p23, p3);

	mov	edx, DWORD PTR _p3$[esp+64]
	push	edx
	lea	eax, DWORD PTR _p23$133514[esp+72]
	push	eax
	lea	ecx, DWORD PTR _p123$133516[esp+76]
	push	ecx
	lea	edx, DWORD PTR _p0123$133517[esp+80]
	push	edx
	mov	ecx, esi
	call	?_EvaluateBezier@Rasterizer@ssf@@AAEXABVCPoint@@000@Z ; ssf::Rasterizer::_EvaluateBezier

; 93   : 		}
; 94   : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 52					; 00000034H
	ret	16					; 00000010H
?_EvaluateBezier@Rasterizer@ssf@@AAEXABVCPoint@@000@Z ENDP ; ssf::Rasterizer::_EvaluateBezier
_TEXT	ENDS
PUBLIC	??0Rasterizer@ssf@@QAE@XZ			; ssf::Rasterizer::Rasterizer
; Function compile flags: /Ogtpy
;	COMDAT ??0Rasterizer@ssf@@QAE@XZ
_TEXT	SEGMENT
??0Rasterizer@ssf@@QAE@XZ PROC				; ssf::Rasterizer::Rasterizer, COMDAT
; _this$ = eax

; 41   : 	{

	xor	ecx, ecx
	mov	DWORD PTR [eax], OFFSET ??_7Rasterizer@ssf@@6B@
	mov	DWORD PTR [eax+32], OFFSET ??_7?$Array@TSpan@Rasterizer@ssf@@@ssf@@6B@
	mov	DWORD PTR [eax+36], ecx
	mov	DWORD PTR [eax+44], ecx
	mov	DWORD PTR [eax+40], ecx
	mov	edx, 4096				; 00001000H
	mov	DWORD PTR [eax+48], edx
	mov	DWORD PTR [eax+52], OFFSET ??_7?$Array@TSpan@Rasterizer@ssf@@@ssf@@6B@
	mov	DWORD PTR [eax+56], ecx
	mov	DWORD PTR [eax+64], ecx
	mov	DWORD PTR [eax+60], ecx
	mov	DWORD PTR [eax+68], edx
	mov	DWORD PTR [eax+72], OFFSET ??_7?$Array@TSpan@Rasterizer@ssf@@@ssf@@6B@
	mov	DWORD PTR [eax+76], ecx
	mov	DWORD PTR [eax+84], ecx
	mov	DWORD PTR [eax+80], ecx
	mov	DWORD PTR [eax+88], edx

; 42   : 		mpOverlayBuffer = NULL;

	mov	DWORD PTR [eax+112], ecx

; 43   : 		mOverlayWidth = mOverlayHeight = 0;

	mov	DWORD PTR [eax+120], ecx
	mov	DWORD PTR [eax+116], ecx

; 44   : 		mPathOffsetX = mPathOffsetY = 0;

	mov	DWORD PTR [eax+128], ecx
	mov	DWORD PTR [eax+124], ecx

; 45   : 		mOffsetX = mOffsetY = 0;

	mov	DWORD PTR [eax+136], ecx
	mov	DWORD PTR [eax+132], ecx

; 46   : 	}

	ret	0
??0Rasterizer@ssf@@QAE@XZ ENDP				; ssf::Rasterizer::Rasterizer
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
;	COMDAT ??$_Pop_heap@PAHHH@std@@YAXPAH00H0@Z
_TEXT	SEGMENT
__Last$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Pop_heap@PAHHH@std@@YAXPAH00H0@Z PROC		; std::_Pop_heap<int *,int,int>, COMDAT
; __First$ = ecx
; __Dest$ = edx

; 2078 : 	*_Dest = *_First;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 2079 : 	std::_Adjust_heap(_First, _Diff(0), _Diff(_Last - _First), _Val);

	mov	edx, DWORD PTR __Last$[esp-4]
	sub	edx, ecx
	sar	edx, 2
	mov	DWORD PTR __Last$[esp-4], 0
	jmp	??$_Adjust_heap@PAHHH@std@@YAXPAHHHH@Z	; std::_Adjust_heap<int *,int,int>
??$_Pop_heap@PAHHH@std@@YAXPAH00H0@Z ENDP		; std::_Pop_heap<int *,int,int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Pop_heap_0@PAHH@std@@YAXPAH00@Z
_TEXT	SEGMENT
??$_Pop_heap_0@PAHH@std@@YAXPAH00@Z PROC		; std::_Pop_heap_0<int *,int>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 2086 : 	_Pop_heap(_First, _Last - 1, _Last - 1,
; 2087 : 		_Ty(*(_Last - 1)), _Dist_type(_First));

	mov	eax, DWORD PTR [edx-4]
	push	esi
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [edx-4], esi
	sub	edx, ecx
	push	eax
	sub	edx, 4
	sar	edx, 2
	push	0
	call	??$_Adjust_heap@PAHHH@std@@YAXPAHHHH@Z	; std::_Adjust_heap<int *,int,int>
	add	esp, 8
	pop	esi

; 2088 : 	}

	ret	0
??$_Pop_heap_0@PAHH@std@@YAXPAH00@Z ENDP		; std::_Pop_heap_0<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$unchecked_copy_backward@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
??$unchecked_copy_backward@PAHPAH@stdext@@YAPAHPAH00@Z PROC ; stdext::unchecked_copy_backward<int *,int *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 3611 : 		return (_STD _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3612 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	sub	ecx, edx
	push	esi
	mov	esi, ecx
	test	eax, eax
	jle	SHORT $LN18@unchecked_@2
	push	edx
	push	edi
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@unchecked_@2:
	mov	eax, esi
	pop	esi

; 3613 : 	}

	ret	0
??$unchecked_copy_backward@PAHPAH@stdext@@YAPAHPAH00@Z ENDP ; stdext::unchecked_copy_backward<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$pop_heap@PAH@std@@YAXPAH0@Z
_TEXT	SEGMENT
??$pop_heap@PAH@std@@YAXPAH0@Z PROC			; std::pop_heap<int *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 2093 : 	_DEBUG_RANGE(_First, _Last);
; 2094 : 	_DEBUG_HEAP(_First, _Last);
; 2095 : 	if (1 < _Last - _First)

	mov	eax, edx
	sub	eax, ecx
	push	esi
	mov	esi, eax
	and	esi, -4					; fffffffcH
	cmp	esi, 4
	jle	SHORT $LN18@pop_heap

; 2096 : 		_Pop_heap_0(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val_type(_First));

	mov	esi, DWORD PTR [edx-4]
	push	edi
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [edx-4], edi
	lea	edx, DWORD PTR [eax-4]
	push	esi
	sar	edx, 2
	push	0
	call	??$_Adjust_heap@PAHHH@std@@YAXPAHHHH@Z	; std::_Adjust_heap<int *,int,int>
	add	esp, 8
	pop	edi
$LN18@pop_heap:
	pop	esi

; 2097 : 	}

	ret	0
??$pop_heap@PAH@std@@YAXPAH0@Z ENDP			; std::pop_heap<int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Med3@PAH@std@@YAXPAH00@Z
_TEXT	SEGMENT
??$_Med3@PAH@std@@YAXPAH00@Z PROC			; std::_Med3<int *>, COMDAT
; __First$ = ecx
; __Mid$ = eax
; __Last$ = edi

; 2997 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	edx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [ecx]
	cmp	edx, esi
	jge	SHORT $LN8@Med3

; 2998 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN8@Med3
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [ecx], edx
$LN8@Med3:

; 2999 : 	if (_DEBUG_LT(*_Last, *_Mid))

	mov	edx, DWORD PTR [edi]
	mov	esi, DWORD PTR [eax]
	cmp	edx, esi
	jge	SHORT $LN13@Med3

; 3000 : 		std::iter_swap(_Last, _Mid);

	cmp	edi, eax
	je	SHORT $LN13@Med3
	mov	DWORD PTR [edi], esi
	mov	DWORD PTR [eax], edx
$LN13@Med3:

; 3001 : 	if (_DEBUG_LT(*_Mid, *_First))

	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [ecx]
	cmp	edx, esi
	jge	SHORT $LN18@Med3

; 3002 : 		std::iter_swap(_Mid, _First);

	cmp	eax, ecx
	je	SHORT $LN18@Med3
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [ecx], edx
$LN18@Med3:
	pop	esi

; 3003 : 	}

	ret	0
??$_Med3@PAH@std@@YAXPAH00@Z ENDP			; std::_Med3<int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 810  : 		return (_STD _Uninit_copy(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest, _Al,
; 811  : 			_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN16@unchecked_@3
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN16@unchecked_@3:
	mov	eax, esi
	pop	esi

; 812  : 	}

	ret	0
??$unchecked_uninitialized_copy@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAHIH@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Fill_n@PAHIH@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<int *,unsigned int,int>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3225 : 		// if _OutIt is checked, this will ensure we have enough space
; 3226 : 		_OutIt _Last = _First + _Count; (_Last);
; 3227 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3228 : 			_Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN7@Fill_n@2
	push	esi
	npad	7
$LL9@Fill_n@2:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL9@Fill_n@2
	pop	esi
$LN7@Fill_n@2:

; 3229 : 	}

	ret	0
??$_Fill_n@PAHIH@std@@YAXPAHIABHUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort1@PAHH@std@@YAXPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Insertion_sort1@PAHH@std@@YAXPAH00@Z PROC		; std::_Insertion_sort1<int *,int>, COMDAT

; 2965 : 	{	// insertion sort [_First, _Last), using operator<

	push	ebx
	mov	ebx, DWORD PTR __First$[esp]
	push	esi

; 2966 : 	if (_First != _Last)
; 2967 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	lea	esi, DWORD PTR [ebx+4]
	cmp	esi, DWORD PTR __Last$[esp+4]
	je	SHORT $LN6@Insertion_
	push	ebp
	mov	ebp, 4
	push	edi
	sub	ebp, ebx
$LL7@Insertion_:

; 2968 : 			{	// order next element
; 2969 : 			_BidIt _Next1 = _Next;
; 2970 : 			_Ty _Val = *_Next;

	mov	edi, DWORD PTR [esi]

; 2971 : 
; 2972 : 			if (_DEBUG_LT(_Val, *_First))

	cmp	edi, DWORD PTR [ebx]
	mov	edx, esi
	jge	SHORT $LN5@Insertion_

; 2973 : 				{	// found new earliest element, move to front
; 2974 : 				_STDEXT unchecked_copy_backward(_First, _Next, ++_Next1);

	lea	eax, DWORD PTR [esi+ebp-4]
	sar	eax, 2
	test	eax, eax
	jle	SHORT $LN28@Insertion_
	add	eax, eax
	add	eax, eax
	push	eax
	mov	ecx, esi
	push	ebx
	sub	ecx, eax
	push	eax
	add	ecx, 4
	push	ecx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN28@Insertion_:

; 2975 : 				*_First = _Val;

	mov	DWORD PTR [ebx], edi

; 2976 : 				}
; 2977 : 			else

	jmp	SHORT $LN4@Insertion_
$LN5@Insertion_:

; 2978 : 				{	// look for insertion point after first
; 2979 : 				for (_BidIt _First1 = _Next1;
; 2980 : 					_DEBUG_LT(_Val, *--_First1);
; 2981 : 					_Next1 = _First1)

	mov	ecx, DWORD PTR [esi-4]
	cmp	edi, ecx
	lea	eax, DWORD PTR [esi-4]
	jge	SHORT $LN1@Insertion_
$LL3@Insertion_:

; 2982 : 					*_Next1 = *_First1;	// move hole down

	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [eax-4]
	mov	edx, eax
	sub	eax, 4
	cmp	edi, ecx
	jl	SHORT $LL3@Insertion_
$LN1@Insertion_:

; 2983 : 				*_Next1 = _Val;	// insert element in hole

	mov	DWORD PTR [edx], edi
$LN4@Insertion_:

; 2966 : 	if (_First != _Last)
; 2967 : 		for (_BidIt _Next = _First; ++_Next != _Last; )

	add	esi, 4
	cmp	esi, DWORD PTR __Last$[esp+12]
	jne	SHORT $LL7@Insertion_
	pop	edi
	pop	ebp
$LN6@Insertion_:
	pop	esi
	pop	ebx

; 2984 : 				}
; 2985 : 			}
; 2986 : 	}

	ret	0
??$_Insertion_sort1@PAHH@std@@YAXPAH00@Z ENDP		; std::_Insertion_sort1<int *,int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Sort_heap@PAH@std@@YAXPAH0@Z
_TEXT	SEGMENT
??$_Sort_heap@PAH@std@@YAXPAH0@Z PROC			; std::_Sort_heap<int *>, COMDAT
; __First$ = edi
; __Last$ = eax

; 2212 : 	{	// order heap by repeatedly popping, using operator<

	push	esi

; 2213 : 	_DEBUG_RANGE(_First, _Last);
; 2214 : 	_DEBUG_HEAP(_First, _Last);
; 2215 : 	for (; 1 < _Last - _First; --_Last)

	mov	esi, eax
	sub	esi, edi
	mov	eax, esi
	sar	eax, 2
	cmp	eax, 1
	jle	SHORT $LN1@Sort_heap
$LN28@Sort_heap:

; 2216 : 		std::pop_heap(_First, _Last);

	mov	eax, DWORD PTR [edi+esi-4]
	mov	ecx, DWORD PTR [edi]
	push	eax
	mov	DWORD PTR [edi+esi-4], ecx
	lea	edx, DWORD PTR [esi-4]
	sar	edx, 2
	push	0
	mov	ecx, edi
	call	??$_Adjust_heap@PAHHH@std@@YAXPAHHHH@Z	; std::_Adjust_heap<int *,int,int>
	sub	esi, 4
	mov	eax, esi
	sar	eax, 2
	add	esp, 8
	cmp	eax, 1
	jg	SHORT $LN28@Sort_heap
$LN1@Sort_heap:
	pop	esi

; 2217 : 	}

	ret	0
??$_Sort_heap@PAH@std@@YAXPAH0@Z ENDP			; std::_Sort_heap<int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Median@PAH@std@@YAXPAH00@Z
_TEXT	SEGMENT
tv261 = -4						; size = 4
__Last$ = 8						; size = 4
??$_Median@PAH@std@@YAXPAH00@Z PROC			; std::_Median<int *>, COMDAT
; __First$ = eax
; __Mid$ = ecx

; 3007 : 	{	// sort median element to middle

	push	ecx
	push	esi
	push	edi

; 3008 : 	if (40 < _Last - _First)

	mov	edi, DWORD PTR __Last$[esp+8]
	mov	esi, eax
	mov	eax, edi
	sub	eax, esi
	sar	eax, 2
	cmp	eax, 40					; 00000028H
	jle	$LN2@Median

; 3009 : 		{	// median of nine
; 3010 : 		size_t _Step = (_Last - _First + 1) / 8;

	inc	eax
	cdq
	and	edx, 7
	add	eax, edx

; 3011 : 		std::_Med3(_First, _First + _Step, _First + 2 * _Step);

	mov	edx, DWORD PTR [esi]
	push	ebx
	sar	eax, 3
	push	ebp
	lea	ebp, DWORD PTR [eax*4]
	lea	ebx, DWORD PTR [eax*8]
	mov	eax, DWORD PTR [esi+ebp]
	lea	edi, DWORD PTR [esi+ebp]
	mov	DWORD PTR tv261[esp+20], ebx
	add	ebx, esi
	cmp	eax, edx
	jge	SHORT $LN12@Median
	cmp	edi, esi
	je	SHORT $LN12@Median
	mov	DWORD PTR [edi], edx
	mov	DWORD PTR [esi], eax
$LN12@Median:
	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [edi]
	cmp	eax, edx
	jge	SHORT $LN17@Median
	cmp	ebx, edi
	je	SHORT $LN17@Median
	mov	DWORD PTR [ebx], edx
	mov	DWORD PTR [edi], eax
$LN17@Median:
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [esi]
	cmp	eax, edx
	jge	SHORT $LN22@Median
	cmp	edi, esi
	je	SHORT $LN22@Median
	mov	DWORD PTR [edi], edx
	mov	DWORD PTR [esi], eax
$LN22@Median:

; 3012 : 		std::_Med3(_Mid - _Step, _Mid, _Mid + _Step);

	mov	edx, DWORD PTR [ecx]
	mov	eax, ecx
	sub	eax, ebp
	mov	esi, DWORD PTR [eax]
	cmp	edx, esi
	lea	ebx, DWORD PTR [ecx+ebp]
	jge	SHORT $LN32@Median
	cmp	ecx, eax
	je	SHORT $LN32@Median
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [eax], edx
$LN32@Median:
	mov	edx, DWORD PTR [ebx]
	mov	esi, DWORD PTR [ecx]
	cmp	edx, esi
	jge	SHORT $LN37@Median
	cmp	ebx, ecx
	je	SHORT $LN37@Median
	mov	DWORD PTR [ebx], esi
	mov	DWORD PTR [ecx], edx
$LN37@Median:
	mov	edx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax]
	cmp	edx, esi
	jge	SHORT $LN42@Median
	cmp	ecx, eax
	je	SHORT $LN42@Median
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [eax], edx
$LN42@Median:

; 3013 : 		std::_Med3(_Last - 2 * _Step, _Last - _Step, _Last);

	mov	edx, DWORD PTR __Last$[esp+16]
	mov	eax, edx
	sub	edx, DWORD PTR tv261[esp+20]
	sub	eax, ebp
	mov	esi, DWORD PTR [eax]
	mov	ebx, DWORD PTR [edx]
	cmp	esi, ebx
	jge	SHORT $LN52@Median
	cmp	eax, edx
	je	SHORT $LN52@Median
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [edx], esi
$LN52@Median:
	mov	ebp, DWORD PTR __Last$[esp+16]
	mov	esi, DWORD PTR [ebp]
	mov	ebx, DWORD PTR [eax]
	cmp	esi, ebx
	jge	SHORT $LN57@Median
	cmp	ebp, eax
	je	SHORT $LN57@Median
	mov	DWORD PTR [ebp], ebx
	mov	DWORD PTR [eax], esi
$LN57@Median:
	mov	esi, DWORD PTR [eax]
	mov	ebx, DWORD PTR [edx]
	cmp	esi, ebx
	jge	SHORT $LN62@Median
	cmp	eax, edx
	je	SHORT $LN62@Median
	mov	DWORD PTR [eax], ebx
	mov	DWORD PTR [edx], esi
$LN62@Median:

; 3014 : 		std::_Med3(_First + _Step, _Mid, _Last - _Step);

	mov	edx, DWORD PTR [ecx]
	mov	esi, DWORD PTR [edi]
	cmp	edx, esi
	pop	ebp
	pop	ebx
	jge	SHORT $LN72@Median
	cmp	ecx, edi
	je	SHORT $LN72@Median
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [edi], edx
$LN72@Median:
	mov	edx, DWORD PTR [eax]
	mov	esi, DWORD PTR [ecx]
	cmp	edx, esi
	jge	SHORT $LN77@Median
	cmp	eax, ecx
	je	SHORT $LN77@Median
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [ecx], edx
$LN77@Median:
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edi]
	cmp	eax, edx
	jge	SHORT $LN102@Median
	cmp	ecx, edi
	je	SHORT $LN102@Median
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [edi], eax
	pop	edi
	pop	esi

; 3018 : 	}

	pop	ecx
	ret	0
$LN2@Median:

; 3015 : 		}
; 3016 : 	else
; 3017 : 		std::_Med3(_First, _Mid, _Last);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [esi]
	cmp	eax, edx
	jge	SHORT $LN92@Median
	cmp	ecx, esi
	je	SHORT $LN92@Median
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [esi], eax
$LN92@Median:
	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx]
	cmp	eax, edx
	jge	SHORT $LN97@Median
	cmp	edi, ecx
	je	SHORT $LN97@Median
	mov	DWORD PTR [edi], edx
	mov	DWORD PTR [ecx], eax
$LN97@Median:
	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [esi]
	cmp	eax, edx
	jge	SHORT $LN102@Median
	cmp	ecx, esi
	je	SHORT $LN102@Median
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [esi], eax
$LN102@Median:
	pop	edi
	pop	esi

; 3018 : 	}

	pop	ecx
	ret	0
??$_Median@PAH@std@@YAXPAH00@Z ENDP			; std::_Median<int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@U?$pair@_K_K@std@@U12@@std@@YAXPAU?$pair@_K_K@0@ABU10@@Z
_TEXT	SEGMENT
??$_Construct@U?$pair@_K_K@std@@U12@@std@@YAXPAU?$pair@_K_K@0@ABU10@@Z PROC ; std::_Construct<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 51   : 	void _FARQ *_Vptr = _Ptr;
; 52   : 	::new (_Vptr) _T1(_Val);

	test	eax, eax
	je	SHORT $LN3@Construct
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
$LN3@Construct:

; 53   : 	}

	ret	0
??$_Construct@U?$pair@_K_K@std@@U12@@std@@YAXPAU?$pair@_K_K@0@ABU10@@Z ENDP ; std::_Construct<std::pair<unsigned __int64,unsigned __int64>,std::pair<unsigned __int64,unsigned __int64> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 205  : 	return _STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al);

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN18@Uninit_mov
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN18@Uninit_mov:
	mov	eax, esi
	pop	esi

; 206  : 	}

	ret	0
??$_Uninit_move@PAHPAHV?$allocator@H@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00AAV?$allocator@H@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<int *,int *,std::allocator<int>,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAU?$pair@_K_K@std@@PAU12@@std@@YAPAU?$pair@_K_K@0@PAU10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Copy_backward_opt@PAU?$pair@_K_K@std@@PAU12@@std@@YAPAU?$pair@_K_K@0@PAU10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *>, COMDAT
; __First$ = esi
; __Last$ = ecx
; __Dest$ = edx

; 2660 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2661 : 	_OutIt _Result = _Dest - (_Last - _First);

	mov	eax, ecx
	sub	eax, esi
	sar	eax, 4
	shl	eax, 4
	push	edi
	mov	edi, eax
	mov	eax, edx
	sub	eax, edi

; 2662 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2663 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	cmp	esi, ecx
	je	SHORT $LN7@Copy_backw@2
	sub	edx, ecx
$LL8@Copy_backw@2:
	mov	edi, DWORD PTR [ecx-16]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR [edx+ecx], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+ecx+4], edi
	mov	edi, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+ecx+8], edi
	mov	edi, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+ecx+12], edi
	cmp	ecx, esi
	jne	SHORT $LL8@Copy_backw@2
$LN7@Copy_backw@2:
	pop	edi

; 2664 : 	return _Result;
; 2665 : 	}

	ret	0
??$_Copy_backward_opt@PAU?$pair@_K_K@std@@PAU12@@std@@YAPAU?$pair@_K_K@0@PAU10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z PROC	; stdext::unchecked_fill_n<int *,unsigned int,int>, COMDAT
; __Count$ = eax
; __Val$ = edx

; 3695 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN11@unchecked_@4
	push	esi
	npad	7
$LL13@unchecked_@4:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL13@unchecked_@4
	pop	esi
$LN11@unchecked_@4:

; 3696 : 	}

	ret	0
??$unchecked_fill_n@PAHIH@stdext@@YAXPAHIABH@Z ENDP	; stdext::unchecked_fill_n<int *,unsigned int,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$_Insertion_sort@PAH@std@@YAXPAH0@Z
_TEXT	SEGMENT
??$_Insertion_sort@PAH@std@@YAXPAH0@Z PROC		; std::_Insertion_sort<int *>, COMDAT
; __First$ = ecx
; __Last$ = eax

; 2991 : 	std::_Insertion_sort1(_First, _Last, _Val_type(_First));

	cmp	ecx, eax
	je	SHORT $LN12@Insertion_@2
	push	eax
	push	ecx
	call	??$_Insertion_sort1@PAHH@std@@YAXPAH00@Z ; std::_Insertion_sort1<int *,int>
	add	esp, 8
$LN12@Insertion_@2:

; 2992 : 	}

	ret	0
??$_Insertion_sort@PAH@std@@YAXPAH0@Z ENDP		; std::_Insertion_sort<int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$sort_heap@PAH@std@@YAXPAH0@Z
_TEXT	SEGMENT
??$sort_heap@PAH@std@@YAXPAH0@Z PROC			; std::sort_heap<int *>, COMDAT
; __First$ = edi
; __Last$ = eax

; 2222 : 	_DEBUG_HEAP(_First, _Last);
; 2223 : 	_Sort_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last));

	jmp	??$_Sort_heap@PAH@std@@YAXPAH0@Z	; std::_Sort_heap<int *>
??$sort_heap@PAH@std@@YAXPAH0@Z ENDP			; std::sort_heap<int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$make_heap@PAH@std@@YAXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$make_heap@PAH@std@@YAXPAH0@Z PROC			; std::make_heap<int *>, COMDAT
; __Last$ = eax

; 2175 : 	{	// make [_First, _Last) into a heap, using operator<

	push	ebx
	mov	ebx, DWORD PTR __First$[esp]
	push	edi
	mov	edi, eax

; 2176 : 	_DEBUG_RANGE(_First, _Last);
; 2177 : 	if (1 < _Last - _First)

	sub	edi, ebx
	sar	edi, 2
	cmp	edi, 1
	jle	SHORT $LN16@make_heap

; 2178 : 		_Make_heap(_CHECKED_BASE(_First), _CHECKED_BASE(_Last),
; 2179 : 			_Dist_type(_First), _Val_type(_First));

	mov	eax, edi
	cdq
	sub	eax, edx
	push	esi
	mov	esi, eax
	sar	esi, 1
	test	esi, esi
	jle	SHORT $LN22@make_heap
$LL17@make_heap:
	mov	eax, DWORD PTR [ebx+esi*4-4]
	dec	esi
	push	eax
	push	esi
	mov	edx, edi
	mov	ecx, ebx
	call	??$_Adjust_heap@PAHHH@std@@YAXPAHHHH@Z	; std::_Adjust_heap<int *,int,int>
	add	esp, 8
	test	esi, esi
	jg	SHORT $LL17@make_heap
$LN22@make_heap:
	pop	esi
$LN16@make_heap:
	pop	edi
	pop	ebx

; 2180 : 	}

	ret	0
??$make_heap@PAH@std@@YAXPAH0@Z ENDP			; std::make_heap<int *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Unguarded_partition@PAH@std@@YA?AU?$pair@PAHPAH@0@PAH0@Z
_TEXT	SEGMENT
__Glast$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
??$_Unguarded_partition@PAH@std@@YA?AU?$pair@PAHPAH@0@PAH0@Z PROC ; std::_Unguarded_partition<int *>, COMDAT

; 3022 : 	{	// partition [_First, _Last), using operator<

	push	ecx
	push	ebx
	push	ebp

; 3023 : 	_RanIt _Mid = _First + (_Last - _First) / 2;	// sort median to _Mid

	mov	ebp, DWORD PTR __First$[esp+8]
	push	esi
	push	edi
	mov	edi, DWORD PTR __Last$[esp+16]
	mov	eax, edi
	sub	eax, ebp
	sar	eax, 2
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	esi, DWORD PTR [ebp+eax*4]

; 3024 : 	std::_Median(_First, _Mid, _Last - 1);

	lea	eax, DWORD PTR [edi-4]
	push	eax
	mov	ecx, esi
	mov	eax, ebp
	call	??$_Median@PAH@std@@YAXPAH00@Z		; std::_Median<int *>
	add	esp, 4

; 3025 : 	_RanIt _Pfirst = _Mid;

	mov	eax, esi

; 3026 : 	_RanIt _Plast = _Pfirst + 1;

	lea	ebx, DWORD PTR [esi+4]

; 3027 : 
; 3028 : 	while (_First < _Pfirst
; 3029 : 		&& !_DEBUG_LT(*(_Pfirst - 1), *_Pfirst)
; 3030 : 		&& !(*_Pfirst < *(_Pfirst - 1)))

	cmp	ebp, esi
	jae	SHORT $LN69@Unguarded_
$LL27@Unguarded_:
	mov	ecx, DWORD PTR [eax-4]
	mov	edx, DWORD PTR [eax]
	cmp	edx, ecx
	jg	SHORT $LN69@Unguarded_
	jl	SHORT $LN69@Unguarded_
	add	eax, -4					; fffffffcH
	cmp	ebp, eax
	jb	SHORT $LL27@Unguarded_
$LN69@Unguarded_:

; 3031 : 		--_Pfirst;
; 3032 : 	while (_Plast < _Last
; 3033 : 		&& !_DEBUG_LT(*_Plast, *_Pfirst)
; 3034 : 		&& !(*_Pfirst < *_Plast))

	cmp	ebx, edi
	jae	SHORT $LN24@Unguarded_
	mov	edx, DWORD PTR [eax]
	npad	2
$LL25@Unguarded_:
	mov	ecx, DWORD PTR [ebx]
	cmp	edx, ecx
	jg	SHORT $LN24@Unguarded_
	jl	SHORT $LN24@Unguarded_

; 3035 : 		++_Plast;

	add	ebx, 4
	cmp	ebx, edi
	jb	SHORT $LL25@Unguarded_
$LN24@Unguarded_:

; 3036 : 
; 3037 : 	_RanIt _Gfirst = _Plast;
; 3038 : 	_RanIt _Glast = _Pfirst;

	mov	ebp, eax
	mov	ecx, ebx
	mov	DWORD PTR __Glast$[esp+20], ebp
$LL23@Unguarded_:

; 3039 : 
; 3040 : 	for (; ; )
; 3041 : 		{	// partition
; 3042 : 		for (; _Gfirst < _Last; ++_Gfirst)

	cmp	ecx, edi
	jae	SHORT $LN73@Unguarded_
	npad	5
$LL21@Unguarded_:

; 3043 : 			if (_DEBUG_LT(*_Pfirst, *_Gfirst))

	mov	esi, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	cmp	esi, edx
	jg	SHORT $LN20@Unguarded_

; 3044 : 				;
; 3045 : 			else if (*_Gfirst < *_Pfirst)

	jl	SHORT $LN73@Unguarded_

; 3046 : 				break;
; 3047 : 			else
; 3048 : 				std::iter_swap(_Plast++, _Gfirst);

	mov	edx, ebx
	add	ebx, 4
	cmp	edx, ecx
	je	SHORT $LN20@Unguarded_
	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR [edx], esi
	mov	DWORD PTR [ecx], edi
	mov	edi, DWORD PTR __Last$[esp+16]
$LN20@Unguarded_:
	add	ecx, 4
	cmp	ecx, edi
	jb	SHORT $LL21@Unguarded_
$LN73@Unguarded_:

; 3049 : 		for (; _First < _Glast; --_Glast)

	cmp	ebp, DWORD PTR __First$[esp+16]
	jbe	SHORT $LN85@Unguarded_
	lea	edx, DWORD PTR [ebp-4]
	npad	3
$LL14@Unguarded_:

; 3050 : 			if (_DEBUG_LT(*(_Glast - 1), *_Pfirst))

	mov	esi, DWORD PTR [edx]
	mov	edi, DWORD PTR [eax]
	cmp	edi, esi
	jg	SHORT $LN13@Unguarded_

; 3051 : 				;
; 3052 : 			else if (*_Pfirst < *(_Glast - 1))

	jl	SHORT $LN84@Unguarded_

; 3053 : 				break;
; 3054 : 			else
; 3055 : 				std::iter_swap(--_Pfirst, _Glast - 1);

	sub	eax, 4
	cmp	eax, edx
	je	SHORT $LN13@Unguarded_
	mov	edi, DWORD PTR [edx]
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [eax], edi
	mov	DWORD PTR [edx], esi
$LN13@Unguarded_:
	sub	ebp, 4
	sub	edx, 4
	cmp	DWORD PTR __First$[esp+16], ebp
	jb	SHORT $LL14@Unguarded_
$LN84@Unguarded_:

; 3049 : 		for (; _First < _Glast; --_Glast)

	mov	edi, DWORD PTR __Last$[esp+16]

; 3056 : 		if (_Glast == _First && _Gfirst == _Last)

	cmp	ebp, DWORD PTR __First$[esp+16]
	mov	DWORD PTR __Glast$[esp+20], ebp
$LN85@Unguarded_:
	jne	SHORT $LN6@Unguarded_
	cmp	ecx, edi
	je	$LN75@Unguarded_

; 3058 : 
; 3059 : 		if (_Glast == _First)
; 3060 : 			{	// no room at bottom, rotate pivot upward
; 3061 : 			if (_Plast != _Gfirst)

	cmp	ebx, ecx
	je	SHORT $LN44@Unguarded_

; 3062 : 				std::iter_swap(_Pfirst, _Plast);

	cmp	eax, ebx
	je	SHORT $LN44@Unguarded_
	mov	esi, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [ebx], edx
$LN44@Unguarded_:

; 3063 : 			++_Plast;
; 3064 : 			std::iter_swap(_Pfirst++, _Gfirst++);

	mov	edx, ecx
	mov	esi, eax
	add	ebx, 4
	add	eax, 4
	add	ecx, 4
	cmp	esi, edx
	je	$LL23@Unguarded_
	mov	ebp, DWORD PTR [edx]
	mov	edi, DWORD PTR [esi]
	mov	DWORD PTR [esi], ebp
	mov	ebp, DWORD PTR __Glast$[esp+20]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR __Last$[esp+16]
	jmp	$LL23@Unguarded_
$LN6@Unguarded_:

; 3065 : 			}
; 3066 : 		else if (_Gfirst == _Last)
; 3067 : 			{	// no room at top, rotate pivot downward
; 3068 : 			if (--_Glast != --_Pfirst)

	sub	ebp, 4
	mov	DWORD PTR __Glast$[esp+20], ebp
	cmp	ecx, edi
	jne	SHORT $LN3@Unguarded_
	sub	eax, 4
	cmp	ebp, eax
	je	SHORT $LN54@Unguarded_

; 3069 : 				std::iter_swap(_Glast, _Pfirst);

	mov	esi, DWORD PTR [eax]
	mov	edx, DWORD PTR [ebp]
	mov	DWORD PTR [ebp], esi
	mov	DWORD PTR [eax], edx
$LN54@Unguarded_:

; 3070 : 			std::iter_swap(_Pfirst, --_Plast);

	sub	ebx, 4
	cmp	eax, ebx
	je	$LL23@Unguarded_
	mov	esi, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [ebx], edx

; 3071 : 			}
; 3072 : 		else

	jmp	$LL23@Unguarded_
$LN3@Unguarded_:

; 3073 : 			std::iter_swap(_Gfirst++, --_Glast);

	cmp	ecx, ebp
	je	SHORT $LN64@Unguarded_
	mov	esi, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [ebp], edx
$LN64@Unguarded_:
	add	ecx, 4

; 3074 : 		}

	jmp	$LL23@Unguarded_
$LN75@Unguarded_:

; 3057 : 			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

	mov	ecx, DWORD PTR ___$ReturnUdt$[esp+16]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], ebx
	mov	eax, ecx
	pop	ebx

; 3075 : 	}

	pop	ecx
	ret	0
??$_Unguarded_partition@PAH@std@@YA?AU?$pair@PAHPAH@0@PAH0@Z ENDP ; std::_Unguarded_partition<int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@U?$pair@_K_K@std@@@std@@QAEXPAU?$pair@_K_K@2@ABU32@@Z
_TEXT	SEGMENT
?construct@?$allocator@U?$pair@_K_K@std@@@std@@QAEXPAU?$pair@_K_K@2@ABU32@@Z PROC ; std::allocator<std::pair<unsigned __int64,unsigned __int64> >::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 155  : 		_Construct(_Ptr, _Val);

	test	eax, eax
	je	SHORT $LN5@construct
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], ecx
$LN5@construct:

; 156  : 		}

	ret	0
?construct@?$allocator@U?$pair@_K_K@std@@@std@@QAEXPAU?$pair@_K_K@2@ABU32@@Z ENDP ; std::allocator<std::pair<unsigned __int64,unsigned __int64> >::construct
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First_dest_cat$ = 8					; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 2727 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2728 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	sub	eax, edi
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	sub	ecx, edx
	push	esi
	mov	esi, ecx
	test	eax, eax
	jle	SHORT $LN8@Move_backw
	push	edx
	push	edi
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN8@Move_backw:
	mov	eax, esi
	pop	esi

; 2729 : 	}

	ret	0
??$_Move_backward_opt@PAHPAHUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAHPAH00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<int *,int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = edx

; 850  : 		return (_STD _Uninit_move(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest, _Al,
; 851  : 			_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN30@Unchecked_
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN30@Unchecked_:
	mov	eax, esi
	pop	esi

; 852  : 	}

	ret	0
??$_Unchecked_uninitialized_move@PAHPAHV?$allocator@H@std@@@stdext@@YAPAHPAH00AAV?$allocator@H@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<int *,int *,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Move_backward_opt@PAU?$pair@_K_K@std@@PAU12@Urandom_access_iterator_tag@2@U_Undefined_move_tag@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First_dest_cat$ = 8					; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Move_backward_opt@PAU?$pair@_K_K@std@@PAU12@Urandom_access_iterator_tag@2@U_Undefined_move_tag@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT
; __First$ = esi
; __Last$ = ecx
; __Dest$ = edx

; 2727 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2728 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	mov	eax, ecx
	sub	eax, esi
	sar	eax, 4
	shl	eax, 4
	push	edi
	mov	edi, eax
	mov	eax, edx
	sub	eax, edi
	cmp	esi, ecx
	je	SHORT $LN11@Move_backw@2
	sub	edx, ecx
$LL12@Move_backw@2:
	mov	edi, DWORD PTR [ecx-16]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR [edx+ecx], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+ecx+4], edi
	mov	edi, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+ecx+8], edi
	mov	edi, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+ecx+12], edi
	cmp	ecx, esi
	jne	SHORT $LL12@Move_backw@2
$LN11@Move_backw@2:
	pop	edi

; 2729 : 	}

	ret	0
??$_Move_backward_opt@PAU?$pair@_K_K@std@@PAU12@Urandom_access_iterator_tag@2@U_Undefined_move_tag@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 415  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN13@Uninit_fil
	push	esi
	npad	7
$LL15@Uninit_fil:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL15@Uninit_fil
	pop	esi
$LN13@Uninit_fil:

; 416  : 	}

	ret	0
??$_Uninit_fill_n@PAHIHV?$allocator@H@std@@@std@@YAXPAHIABHAAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU?$pair@_K_K@std@@IU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAXPAU?$pair@_K_K@0@IABU10@AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_fill_n@PAU?$pair@_K_K@std@@IU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAXPAU?$pair@_K_K@0@IABU10@AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<std::pair<unsigned __int64,unsigned __int64> *,unsigned int,std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >, COMDAT
; __Count$ = ecx
; __Val$ = edx

; 389  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	mov	eax, DWORD PTR __First$[esp-4]

; 390  : 
; 391  :  #if _HAS_ITERATOR_DEBUGGING
; 392  : //	if (_Count < 0)
; 393  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 	_FwdIt _Next = _First;
; 397  : 
; 398  : 	_TRY_BEGIN
; 399  : 	for (; 0 < _Count; --_Count, ++_First)

	test	ecx, ecx
	jbe	SHORT $LN4@Uninit_fil@2
	push	esi
	npad	7
$LL6@Uninit_fil@2:

; 400  : 		_Al.construct(_First, _Val);

	test	eax, eax
	je	SHORT $LN5@Uninit_fil@2
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], esi
$LN5@Uninit_fil@2:
	dec	ecx
	add	eax, 16					; 00000010H
	test	ecx, ecx
	ja	SHORT $LL6@Uninit_fil@2
	pop	esi
$LN4@Uninit_fil@2:

; 401  : 	_CATCH_ALL
; 402  : 	for (; _Next != _First; ++_Next)
; 403  : 		_Al.destroy(_Next);
; 404  : 	_RERAISE;
; 405  : 	_CATCH_END
; 406  : 	}

	ret	0
??$_Uninit_fill_n@PAU?$pair@_K_K@std@@IU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAXPAU?$pair@_K_K@0@IABU10@AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::pair<unsigned __int64,unsigned __int64> *,unsigned int,std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAU?$pair@_K_K@std@@PAU12@@std@@YAPAU?$pair@_K_K@0@PAU10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Copy_opt@PAU?$pair@_K_K@std@@PAU12@@std@@YAPAU?$pair@_K_K@0@PAU10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *>, COMDAT
; __First$ = ecx
; __Last$ = esi
; __Dest$ = edx

; 2456 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2457 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	eax, esi
	sub	eax, ecx
	sar	eax, 4
	shl	eax, 4
	add	eax, edx

; 2458 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2459 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	cmp	ecx, esi
	je	SHORT $LN7@Copy_opt@2
	sub	edx, ecx
	push	edi
$LL9@Copy_opt@2:
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [edx+ecx], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+ecx+4], edi
	mov	edi, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+ecx+8], edi
	mov	edi, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+ecx+12], edi
	add	ecx, 16					; 00000010H
	cmp	ecx, esi
	jne	SHORT $LL9@Copy_opt@2
	pop	edi
$LN7@Copy_opt@2:

; 2460 : 	return _Result;
; 2461 : 	}

	ret	0
??$_Copy_opt@PAU?$pair@_K_K@std@@PAU12@@std@@YAPAU?$pair@_K_K@0@PAU10@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$_Sort@PAHH@std@@YAXPAH0H@Z
_TEXT	SEGMENT
__Mid$133906 = -8					; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
??$_Sort@PAHH@std@@YAXPAH0H@Z PROC			; std::_Sort<int *,int>, COMDAT

; 3080 : 	{	// order [_First, _Last), using operator<

	sub	esp, 8
	push	ebx

; 3081 : 	_Diff _Count;
; 3082 : 	for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )

	mov	ebx, DWORD PTR __Last$[esp+8]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+20]
	mov	eax, ebx
	sub	eax, edi
	sar	eax, 2
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN3@Sort
	mov	esi, DWORD PTR __Ideal$[esp+20]
$LN7@Sort:
	test	esi, esi
	jle	SHORT $LN6@Sort

; 3083 : 		{	// divide and conquer by quicksort
; 3084 : 		pair<_RanIt, _RanIt> _Mid =
; 3085 : 			std::_Unguarded_partition(_First, _Last);

	push	ebx
	lea	eax, DWORD PTR __Mid$133906[esp+28]
	push	edi
	push	eax
	call	??$_Unguarded_partition@PAH@std@@YA?AU?$pair@PAHPAH@0@PAH0@Z ; std::_Unguarded_partition<int *>

; 3086 : 		_Ideal /= 2, _Ideal += _Ideal / 2;	// allow 1.5 log2(N) divisions
; 3087 : 
; 3088 : 		if (_Mid.first - _First < _Last - _Mid.second)

	mov	ebp, DWORD PTR __Mid$133906[esp+40]
	mov	eax, esi
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	esi, eax
	cdq
	sub	eax, edx
	sar	eax, 1
	add	esi, eax
	mov	eax, DWORD PTR __Mid$133906[esp+36]
	mov	ecx, ebx
	mov	edx, eax
	sub	ecx, ebp
	sub	edx, edi
	add	esp, 12					; 0000000cH
	and	ecx, -4					; fffffffcH
	and	edx, -4					; fffffffcH
	cmp	edx, ecx

; 3089 : 			{	// loop on second half
; 3090 : 			std::_Sort(_First, _Mid.first, _Ideal);

	push	esi
	jge	SHORT $LN5@Sort
	push	eax
	push	edi
	call	??$_Sort@PAHH@std@@YAXPAH0H@Z		; std::_Sort<int *,int>

; 3091 : 			_First = _Mid.second;

	mov	edi, ebp

; 3092 : 			}
; 3093 : 		else

	jmp	SHORT $LN38@Sort
$LN5@Sort:

; 3094 : 			{	// loop on first half
; 3095 : 			std::_Sort(_Mid.second, _Last, _Ideal);

	push	ebx
	push	ebp
	call	??$_Sort@PAHH@std@@YAXPAH0H@Z		; std::_Sort<int *,int>

; 3096 : 			_Last = _Mid.first;

	mov	ebx, DWORD PTR __Mid$133906[esp+36]
$LN38@Sort:
	mov	eax, ebx
	sub	eax, edi
	sar	eax, 2
	add	esp, 12					; 0000000cH
	cmp	eax, 32					; 00000020H
	jg	SHORT $LN7@Sort
$LN3@Sort:

; 3104 : 		}
; 3105 : 	else if (1 < _Count)

	cmp	eax, 1
	jle	SHORT $LN31@Sort

; 3106 : 		std::_Insertion_sort(_First, _Last);	// small

	cmp	edi, ebx
	je	SHORT $LN31@Sort
	push	ebx
	push	edi
	call	??$_Insertion_sort1@PAHH@std@@YAXPAH00@Z ; std::_Insertion_sort1<int *,int>
	add	esp, 8
$LN31@Sort:

; 3107 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
$LN6@Sort:

; 3097 : 			}
; 3098 : 		}
; 3099 : 
; 3100 : 	if (_ISORT_MAX < _Count)

	cmp	eax, 32					; 00000020H
	jle	SHORT $LN3@Sort

; 3101 : 		{	// heap sort if too many divisions
; 3102 : 		std::make_heap(_First, _Last);

	push	edi
	mov	eax, ebx
	call	??$make_heap@PAH@std@@YAXPAH0@Z		; std::make_heap<int *>
	add	esp, 4

; 3103 : 		std::sort_heap(_First, _Last);

	mov	eax, ebx
	call	??$_Sort_heap@PAH@std@@YAXPAH0@Z	; std::_Sort_heap<int *>

; 3107 : 	}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	0
??$_Sort@PAHH@std@@YAXPAH0H@Z ENDP			; std::_Sort<int *,int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@H@std@@YAPAHIPAH@Z
_TEXT	SEGMENT
$T239509 = -16						; size = 4
$T239501 = -12						; size = 12
??$_Allocate@H@std@@YAPAHIPAH@Z PROC			; std::_Allocate<int>, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 4
	jae	SHORT $LN1@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T239509[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T239501[esp+20]
	mov	DWORD PTR $T239509[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T239501[esp+20]
	push	ecx
	mov	DWORD PTR $T239501[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate:
$LN1@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate:
??$_Allocate@H@std@@YAPAHIPAH@Z ENDP			; std::_Allocate<int>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z
_TEXT	SEGMENT
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z PROC ; stdext::_Unchecked_move_backward<int *,int *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Dest$ = ecx

; 3669 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3670 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	sub	eax, edi
	sar	eax, 2
	lea	edx, DWORD PTR [eax*4]
	sub	ecx, edx
	push	esi
	mov	esi, ecx
	test	eax, eax
	jle	SHORT $LN22@Unchecked_@2
	push	edx
	push	edi
	push	edx
	push	esi
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN22@Unchecked_@2:
	mov	eax, esi
	pop	esi

; 3671 : 	}

	ret	0
??$_Unchecked_move_backward@PAHPAH@stdext@@YAPAHPAH00@Z ENDP ; stdext::_Unchecked_move_backward<int *,int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z
_TEXT	SEGMENT
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove<int *>, COMDAT
; __First$ = edi
; __Last$ = eax
; __Ptr$ = edx

; 1151 : 		{	// move initializing [_First, _Last), using allocator
; 1152 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1153 : 			_Ptr, this->_Alval));

	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	push	esi
	lea	esi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN32@Umove
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN32@Umove:
	mov	eax, esi
	pop	esi

; 1154 : 		}

	ret	0
??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove<int *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Unchecked_move_backward@PAU?$pair@_K_K@std@@PAU12@@stdext@@YAPAU?$pair@_K_K@std@@PAU12@00@Z
_TEXT	SEGMENT
??$_Unchecked_move_backward@PAU?$pair@_K_K@std@@PAU12@@stdext@@YAPAU?$pair@_K_K@std@@PAU12@00@Z PROC ; stdext::_Unchecked_move_backward<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *>, COMDAT
; __First$ = esi
; __Last$ = ecx
; __Dest$ = edx

; 3669 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3670 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, ecx
	sub	eax, esi
	sar	eax, 4
	shl	eax, 4
	push	edi
	mov	edi, eax
	mov	eax, edx
	sub	eax, edi
	cmp	esi, ecx
	je	SHORT $LN25@Unchecked_@3
	sub	edx, ecx
$LL26@Unchecked_@3:
	mov	edi, DWORD PTR [ecx-16]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR [edx+ecx], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+ecx+4], edi
	mov	edi, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+ecx+8], edi
	mov	edi, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+ecx+12], edi
	cmp	ecx, esi
	jne	SHORT $LL26@Unchecked_@3
$LN25@Unchecked_@3:
	pop	edi

; 3671 : 	}

	ret	0
??$_Unchecked_move_backward@PAU?$pair@_K_K@std@@PAU12@@stdext@@YAPAU?$pair@_K_K@std@@PAU12@00@Z ENDP ; stdext::_Unchecked_move_backward<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >, COMDAT
; __Count$ = eax
; __Val$ = edx

; 921  : 		_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 922  : 			_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	ecx, DWORD PTR __First$[esp-4]
	test	eax, eax
	jbe	SHORT $LN17@unchecked_@5
	push	esi
	npad	7
$LL19@unchecked_@5:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL19@unchecked_@5
	pop	esi
$LN17@unchecked_@5:

; 923  : 	}

	ret	0
??$unchecked_uninitialized_fill_n@PAHIHV?$allocator@H@std@@@stdext@@YAXPAHIABHAAV?$allocator@H@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<int *,unsigned int,int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@U?$pair@_K_K@std@@@std@@YAPAU?$pair@_K_K@0@IPAU10@@Z
_TEXT	SEGMENT
$T239965 = -16						; size = 4
$T239957 = -12						; size = 12
??$_Allocate@U?$pair@_K_K@std@@@std@@YAPAU?$pair@_K_K@0@IPAU10@@Z PROC ; std::_Allocate<std::pair<unsigned __int64,unsigned __int64> >, COMDAT
; __Count$ = ecx

; 37   : 	if (_Count <= 0)
; 38   : 		_Count = 0;
; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	ecx
	sub	esp, 16					; 00000010H
	cmp	eax, 16					; 00000010H
	jae	SHORT $LN1@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	lea	eax, DWORD PTR $T239965[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T239957[esp+20]
	mov	DWORD PTR $T239965[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T239957[esp+20]
	push	ecx
	mov	DWORD PTR $T239957[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN13@Allocate@2:
$LN1@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	shl	ecx, 4
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 44   : 	}

	add	esp, 16					; 00000010H
	ret	0
$LN12@Allocate@2:
??$_Allocate@U?$pair@_K_K@std@@@std@@YAPAU?$pair@_K_K@0@IPAU10@@Z ENDP ; std::_Allocate<std::pair<unsigned __int64,unsigned __int64> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAU?$pair@_K_K@std@@IU12@V?$allocator@U?$pair@_K_K@std@@@2@@stdext@@YAXPAU?$pair@_K_K@std@@IABU12@AAV?$allocator@U?$pair@_K_K@std@@@2@@Z
_TEXT	SEGMENT
$T239971 = -4						; size = 1
__Cat$239975 = -4					; size = 1
__Count$ = 8						; size = 4
__Val$ = 12						; size = 4
??$unchecked_uninitialized_fill_n@PAU?$pair@_K_K@std@@IU12@V?$allocator@U?$pair@_K_K@std@@@2@@stdext@@YAXPAU?$pair@_K_K@std@@IABU12@AAV?$allocator@U?$pair@_K_K@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_fill_n<std::pair<unsigned __int64,unsigned __int64> *,unsigned int,std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >, COMDAT
; __First$ = edx

; 920  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 921  : 		_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 922  : 			_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	mov	BYTE PTR $T239971[esp+4], 0
	mov	eax, DWORD PTR $T239971[esp+4]
	mov	ecx, DWORD PTR __Cat$239975[esp+4]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	mov	edx, DWORD PTR __Val$[esp+12]
	call	??$_Uninit_fill_n@PAU?$pair@_K_K@std@@IU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAXPAU?$pair@_K_K@0@IABU10@AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<unsigned __int64,unsigned __int64> *,unsigned int,std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >

; 923  : 	}

	add	esp, 16					; 00000010H
	ret	0
??$unchecked_uninitialized_fill_n@PAU?$pair@_K_K@std@@IU12@V?$allocator@U?$pair@_K_K@std@@@2@@stdext@@YAXPAU?$pair@_K_K@std@@IABU12@AAV?$allocator@U?$pair@_K_K@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<std::pair<unsigned __int64,unsigned __int64> *,unsigned int,std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAU?$pair@_K_K@std@@PAU12@@stdext@@YAPAU?$pair@_K_K@std@@PAU12@00@Z
_TEXT	SEGMENT
??$unchecked_copy@PAU?$pair@_K_K@std@@PAU12@@stdext@@YAPAU?$pair@_K_K@std@@PAU12@00@Z PROC ; stdext::unchecked_copy<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *>, COMDAT
; __First$ = ecx
; __Last$ = esi
; __Dest$ = edx

; 3579 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3580 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	eax, esi
	sub	eax, ecx
	sar	eax, 4
	shl	eax, 4
	add	eax, edx
	cmp	ecx, esi
	je	SHORT $LN21@unchecked_@6
	sub	edx, ecx
	push	edi
$LL23@unchecked_@6:
	mov	edi, DWORD PTR [ecx]
	mov	DWORD PTR [edx+ecx], edi
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+ecx+4], edi
	mov	edi, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+ecx+8], edi
	mov	edi, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+ecx+12], edi
	add	ecx, 16					; 00000010H
	cmp	ecx, esi
	jne	SHORT $LL23@unchecked_@6
	pop	edi
$LN21@unchecked_@6:

; 3581 : 	}

	ret	0
??$unchecked_copy@PAU?$pair@_K_K@std@@PAU12@@stdext@@YAPAU?$pair@_K_K@std@@PAU12@00@Z ENDP ; stdext::unchecked_copy<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U?$pair@_K_K@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U?$pair@_K_K@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,std::pair<unsigned __int64,unsigned __int64>,int,std::pair<unsigned __int64,unsigned __int64> const *,std::pair<unsigned __int64,unsigned __int64> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,std::pair<unsigned __int64,unsigned __int64>,int,std::pair<unsigned __int64,unsigned __int64> const *,std::pair<unsigned __int64,unsigned __int64> const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U?$pair@_K_K@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,std::pair<unsigned __int64,unsigned __int64>,int,std::pair<unsigned __int64,unsigned __int64> const *,std::pair<unsigned __int64,unsigned __int64> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,std::pair<unsigned __int64,unsigned __int64>,int,std::pair<unsigned __int64,unsigned __int64> const *,std::pair<unsigned __int64,unsigned __int64> const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@HHPBHABHV_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@HHPBHABHV_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base_aux>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@HHPBHABHV_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base_aux>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@U?$pair@_K_K@std@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@U?$pair@_K_K@std@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Ranit<std::pair<unsigned __int64,unsigned __int64>,int,std::pair<unsigned __int64,unsigned __int64> const *,std::pair<unsigned __int64,unsigned __int64> const &>::_Ranit<std::pair<unsigned __int64,unsigned __int64>,int,std::pair<unsigned __int64,unsigned __int64> const *,std::pair<unsigned __int64,unsigned __int64> const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@U?$pair@_K_K@std@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Ranit<std::pair<unsigned __int64,unsigned __int64>,int,std::pair<unsigned __int64,unsigned __int64> const *,std::pair<unsigned __int64,unsigned __int64> const &>::_Ranit<std::pair<unsigned __int64,unsigned __int64>,int,std::pair<unsigned __int64,unsigned __int64> const *,std::pair<unsigned __int64,unsigned __int64> const &>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@HHPBHABH@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Ranit@HHPBHABH@std@@QAE@XZ PROC			; std::_Ranit<int,int,int const *,int const &>::_Ranit<int,int,int const *,int const &>, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], 0
	ret	0
??0?$_Ranit@HHPBHABH@std@@QAE@XZ ENDP			; std::_Ranit<int,int,int const *,int const &>::_Ranit<int,int,int const *,int const &>
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??G?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
??G?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator-, COMDAT
; _this$ = edi
; __Right$ = esi

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN4@operator@2
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN3@operator@2
$LN4@operator@2:
	call	__invalid_parameter_noinfo
$LN3@operator@2:

; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	sub	eax, DWORD PTR [esi+4]
	sar	eax, 4

; 195  : 		}

	ret	0
??G?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator-
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@PAU?$pair@_K_K@1@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@PAU?$pair@_K_K@1@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	test	esi, esi
	je	SHORT $LN4@Vector_con
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN4@Vector_con
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN3@Vector_con
$LN4@Vector_con:
	call	__invalid_parameter_noinfo
$LN3@Vector_con:

; 79   : 		this->_Set_container(_Pvector);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+4], ebx

; 81   : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@PAU?$pair@_K_K@1@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-, COMDAT
; _this$ = edi
; __Right$ = esi

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN4@operator@3
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN3@operator@3
$LN4@operator@3:
	call	__invalid_parameter_noinfo
$LN3@operator@3:

; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	sub	eax, DWORD PTR [esi+4]
	sar	eax, 2

; 195  : 		}

	ret	0
??G?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator-
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAHPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAHPBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	test	esi, esi
	je	SHORT $LN4@Vector_con@2
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN4@Vector_con@2
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN3@Vector_con@2
$LN4@Vector_con@2:
	call	__invalid_parameter_noinfo
$LN3@Vector_con@2:

; 79   : 		this->_Set_container(_Pvector);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 80   : 		_Myptr = _Ptr;

	mov	DWORD PTR [edi+4], ebx

; 81   : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAE@PAHPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::_Vector_const_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
$T240158 = -16						; size = 4
$T240160 = -12						; size = 12
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate
	xor	ecx, ecx
$LN3@allocate:
	lea	edx, DWORD PTR [ecx*4]
	push	edx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 4
	jae	SHORT $LN3@allocate
	lea	eax, DWORD PTR $T240158[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T240160[esp+20]
	mov	DWORD PTR $T240158[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T240160[esp+20]
	push	ecx
	mov	DWORD PTR $T240160[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate:
$LN11@allocate:
	int	3
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?end@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@XZ
_TEXT	SEGMENT
?end@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@XZ PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN5@end
	call	__invalid_parameter_noinfo
$LN5@end:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 657  : 		}

	ret	0
?end@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@XZ ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@XZ PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN5@begin
	call	__invalid_parameter_noinfo
$LN5@begin:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 647  : 		}

	ret	0
?begin@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBE?AV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@XZ ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@PAU?$pair@_K_K@1@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@PAU?$pair@_K_K@1@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN6@Vector_ite
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN6@Vector_ite
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN5@Vector_ite
$LN6@Vector_ite:
	call	__invalid_parameter_noinfo
$LN5@Vector_ite:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 328  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@PAU?$pair@_K_K@1@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN4@operator@4
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN3@operator@4
$LN4@operator@4:
	call	__invalid_parameter_noinfo
$LN3@operator@4:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	0
??8?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAHPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAHPBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >, COMDAT
; _this$ = edi
; __Pvector$ = esi

; 327  : 		{	// construct with pointer _Ptr

	push	ebx
	mov	ebx, DWORD PTR __Ptr$[esp]
	mov	DWORD PTR [edi], 0
	test	esi, esi
	je	SHORT $LN6@Vector_ite@2
	cmp	DWORD PTR [esi+12], ebx
	ja	SHORT $LN6@Vector_ite@2
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN5@Vector_ite@2
$LN6@Vector_ite@2:
	call	__invalid_parameter_noinfo
$LN5@Vector_ite@2:
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 328  : 		}

	mov	eax, edi
	pop	ebx
	ret	4
??0?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAE@PAHPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::_Vector_iterator<int,std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@H@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@H@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<int> >::~_Container_base_aux_alloc_real<std::allocator<int> >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 440  : 		}

	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@H@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<int> >::~_Container_base_aux_alloc_real<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z
_TEXT	SEGMENT
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z PROC ; std::vector<int,std::allocator<int> >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1252 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, esi
	mov	ecx, edi
	test	esi, esi
	jbe	SHORT $LN26@Ufill
	push	ebx
	npad	7
$LL21@Ufill:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [ecx], ebx
	dec	eax
	add	ecx, 4
	test	eax, eax
	ja	SHORT $LL21@Ufill
	pop	ebx
$LN26@Ufill:

; 1253 : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]

; 1254 : 		}

	ret	0
?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ufill
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U?$pair@_K_K@std@@@std@@QAEPAU?$pair@_K_K@2@I@Z
_TEXT	SEGMENT
$T240485 = -16						; size = 4
$T240491 = -12						; size = 12
?allocate@?$allocator@U?$pair@_K_K@std@@@std@@QAEPAU?$pair@_K_K@2@I@Z PROC ; std::allocator<std::pair<unsigned __int64,unsigned __int64> >::allocate, COMDAT
; __Count$ = ecx

; 144  : 		{	// allocate array of _Count elements

	sub	esp, 16					; 00000010H

; 145  : 		return (_Allocate(_Count, (pointer)0));

	test	ecx, ecx
	ja	SHORT $LN5@allocate@2
	xor	ecx, ecx
$LN3@allocate@2:
	shl	ecx, 4
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 146  : 		}

	add	esp, 16					; 00000010H
	ret	0

; 145  : 		return (_Allocate(_Count, (pointer)0));

$LN5@allocate@2:
	or	eax, -1
	xor	edx, edx
	div	ecx
	cmp	eax, 16					; 00000010H
	jae	SHORT $LN3@allocate@2
	lea	eax, DWORD PTR $T240485[esp+16]
	push	eax
	lea	ecx, DWORD PTR $T240491[esp+20]
	mov	DWORD PTR $T240485[esp+20], 0
	call	??0exception@std@@QAE@ABQBD@Z		; std::exception::exception
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	ecx, DWORD PTR $T240491[esp+20]
	push	ecx
	mov	DWORD PTR $T240491[esp+24], OFFSET ??_7bad_alloc@std@@6B@
	call	__CxxThrowException@8
$LN12@allocate@2:
$LN11@allocate@2:
	int	3
?allocate@?$allocator@U?$pair@_K_K@std@@@std@@QAEPAU?$pair@_K_K@2@I@Z ENDP ; std::allocator<std::pair<unsigned __int64,unsigned __int64> >::allocate
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@_K_K@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@_K_K@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64,unsigned __int64> > >, COMDAT
; _this$ = eax

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 440  : 		}

	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@_K_K@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEPAU?$pair@_K_K@2@PAU32@IABU32@@Z
_TEXT	SEGMENT
$T240521 = -4						; size = 1
__Cat$240524 = -4					; size = 1
?_Ufill@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEPAU?$pair@_K_K@2@PAU32@IABU32@@Z PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 1251 : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 1252 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	BYTE PTR $T240521[esp+4], 0
	mov	eax, DWORD PTR $T240521[esp+4]
	mov	ecx, DWORD PTR __Cat$240524[esp+4]
	push	eax
	push	ecx
	push	edi
	mov	ecx, esi
	call	??$_Uninit_fill_n@PAU?$pair@_K_K@std@@IU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAXPAU?$pair@_K_K@0@IABU10@AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<unsigned __int64,unsigned __int64> *,unsigned int,std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >

; 1253 : 		return (_Ptr + _Count);

	mov	eax, esi
	shl	eax, 4
	add	eax, edi

; 1254 : 		}

	add	esp, 16					; 00000010H
	ret	0
?_Ufill@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEPAU?$pair@_K_K@2@PAU32@IABU32@@Z ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Ufill
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXXZ PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Tidy, COMDAT
; _this$ = esi

; 1129 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN4@Tidy@2

; 1130 : 			{	// something to free, destroy and deallocate it
; 1131 : 
; 1132 :  #if _HAS_ITERATOR_DEBUGGING
; 1133 : 			this->_Orphan_all();
; 1134 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1135 : 
; 1136 : 			_Destroy(_Myfirst, _Mylast);
; 1137 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@Tidy@2:

; 1138 : 			}
; 1139 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0

; 1140 : 		}

	ret	0
?_Tidy@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<int,std::allocator<int> >::~_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Vector_val@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ PROC ; std::_Vector_val<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::~_Vector_val<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >, COMDAT
; _this$ = eax
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
??1?$_Vector_val@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ ENDP ; std::_Vector_val<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::~_Vector_val<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator==, COMDAT
; _this$ = edi
; __Right$ = esi

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN4@operator@5
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN3@operator@5
$LN4@operator@5:
	call	__invalid_parameter_noinfo
$LN3@operator@5:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	sete	cl
	mov	al, cl

; 212  : 		}

	ret	0
??8?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN6@operator@6
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN5@operator@6
$LN6@operator@6:
	call	__invalid_parameter_noinfo
$LN5@operator@6:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	0
??9?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebx

; 651  : 		return (iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN7@end@2
	call	__invalid_parameter_noinfo
$LN7@end@2:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 652  : 		}

	ret	0
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebx

; 641  : 		return (iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN7@begin@2
	call	__invalid_parameter_noinfo
$LN7@begin@2:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 642  : 		}

	ret	0
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT

; 558  : 		{	// destroy the object

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, DWORD PTR _this$[esp+12]
	push	edi
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+28], edi

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, edi
	je	SHORT $LN7@vector
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@vector:

; 560  : 		}

	mov	DWORD PTR __$EHRec$[esp+28], -1
	mov	eax, DWORD PTR [esi]
	push	eax
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+20], edi
	call	??3@YAXPAX@Z				; operator delete
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	add	esp, 4
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ?empty@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBE_NXZ PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::empty, COMDAT
; _this$ = ecx

; 736  : 		return (size() == 0);

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR [ecx+12]
	and	eax, -16				; fffffff0H
	neg	eax
	sbb	eax, eax
	inc	eax

; 737  : 		}

	ret	0
?empty@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBE_NXZ ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::empty
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@XZ
_TEXT	SEGMENT
?end@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@XZ PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::end, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebx

; 651  : 		return (iterator(_Mylast, this));

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR [esi], 0
	cmp	DWORD PTR [edi+12], ebx
	jbe	SHORT $LN7@end@3
	call	__invalid_parameter_noinfo
$LN7@end@3:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 652  : 		}

	ret	0
?end@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@XZ ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@XZ
_TEXT	SEGMENT
?begin@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@XZ PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::begin, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebx

; 641  : 		return (iterator(_Myfirst, this));

	mov	ebx, DWORD PTR [edi+12]
	mov	DWORD PTR [esi], 0
	cmp	ebx, DWORD PTR [edi+16]
	jbe	SHORT $LN7@begin@3
	call	__invalid_parameter_noinfo
$LN7@begin@3:
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebx
	mov	eax, esi
	pop	ebx

; 642  : 		}

	ret	0
?begin@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@XZ ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::begin
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??1?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::~vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >, COMDAT

; 558  : 		{	// destroy the object

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??1?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, DWORD PTR _this$[esp+12]
	push	edi
	xor	edi, edi
	mov	DWORD PTR __$EHRec$[esp+28], edi

; 559  : 		_Tidy();

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, edi
	je	SHORT $LN7@vector@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@vector@2:

; 560  : 		}

	mov	DWORD PTR __$EHRec$[esp+28], -1
	mov	eax, DWORD PTR [esi]
	push	eax
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+20], edi
	call	??3@YAXPAX@Z				; operator delete
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	add	esp, 4
	pop	edi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ
__ehhandler$??1?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::~vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
PUBLIC	?Draw@Rasterizer@@QAE?AVCRect@@AAUSubPicDesc@@AAV2@PAEHHPBJ_N4@Z ; Rasterizer::Draw
; Function compile flags: /Ogtpy
; File d:\-=svn=-\svplayer\src\subtitles\rasterizer.cpp
;	COMDAT ?Draw@Rasterizer@@QAE?AVCRect@@AAUSubPicDesc@@AAV2@PAEHHPBJ_N4@Z
_TEXT	SEGMENT
_fSSE2$ = -93						; size = 1
_src$ = -92						; size = 4
tv4428 = -88						; size = 4
tv2030 = -88						; size = 4
tv1917 = -88						; size = 4
_xo$ = -84						; size = 4
tv3714 = -80						; size = 4
tv3483 = -80						; size = 4
tv2369 = -80						; size = 4
tv1927 = -80						; size = 4
tv1870 = -80						; size = 4
_s$ = -76						; size = 4
_w$ = -72						; size = 4
_am$ = -68						; size = 4
_h$ = -64						; size = 4
tv1933 = -60						; size = 4
_sw$131249 = -60					; size = 4
_sw$131185 = -60					; size = 4
tv4580 = -56						; size = 4
tv3837 = -56						; size = 4
_ia$241194 = -56					; size = 4
_ia$241139 = -56					; size = 4
_ia$241028 = -56					; size = 4
_ia$240975 = -56					; size = 4
_wt$131280 = -56					; size = 4
_wt$131271 = -56					; size = 4
_wt$131252 = -56					; size = 4
_wt$131207 = -56					; size = 4
_wt$131197 = -56					; size = 4
_y$ = -56						; size = 4
tv4757 = -52						; size = 4
tv4601 = -52						; size = 4
tv3570 = -52						; size = 4
tv3396 = -52						; size = 4
tv3138 = -52						; size = 4
_wt$131261 = -52					; size = 4
_wt$131244 = -52					; size = 4
_wt$131233 = -52					; size = 4
_wt$131216 = -52					; size = 4
_wt$131180 = -52					; size = 4
_wt$131164 = -52					; size = 4
_yo$ = -52						; size = 4
tv4909 = -48						; size = 4
tv4355 = -48						; size = 4
tv4334 = -48						; size = 4
tv4051 = -48						; size = 4
tv3589 = -48						; size = 4
tv3377 = -48						; size = 4
_ia$241225 = -48					; size = 4
_ia$241109 = -48					; size = 4
_ia$241056 = -48					; size = 4
_wt$131239 = -48					; size = 4
_wt$131228 = -48					; size = 4
_wt$131188 = -48					; size = 4
_wt$131175 = -48					; size = 4
_wt$131169 = -48					; size = 4
tv5012 = -44						; size = 4
tv4469 = -44						; size = 4
_ia$241280 = -44					; size = 4
tv5010 = -40						; size = 4
_r$241237 = -40						; size = 4
_r$241151 = -40						; size = 4
_a$241055 = -40						; size = 4
_a$241279 = -36						; size = 4
_r$ = -32						; size = 16
$T240924 = -16						; size = 16
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
_spd$ = 16						; size = 4
_clipRect$ = 20						; size = 4
_pAlphaMask$ = 24					; size = 4
_xsub$ = 28						; size = 4
_ysub$ = 32						; size = 4
_switchpts$ = 36					; size = 4
_fBody$ = 40						; size = 1
_fBorder$ = 44						; size = 1
?Draw@Rasterizer@@QAE?AVCRect@@AAUSubPicDesc@@AAV2@PAEHHPBJ_N4@Z PROC ; Rasterizer::Draw, COMDAT

; 928  : {

	push	ebp
	mov	ebp, esp
	and	esp, -16				; fffffff0H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR _spd$[ebp]
	sub	esp, 100				; 00000064H

; 929  : 	CRect bbox(0, 0, 0, 0);

	xor	edx, edx
	push	ebx
	push	esi
	push	edi
	mov	edi, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [eax+12], edx

; 930  : 
; 931  : 	if(!switchpts || !fBody && !fBorder) return(bbox);

	cmp	DWORD PTR _switchpts$[ebp], edx
	je	$LN113@Draw@2
	cmp	BYTE PTR _fBody$[ebp], dl
	jne	SHORT $LN112@Draw@2
	cmp	BYTE PTR _fBorder$[ebp], dl
	je	$LN113@Draw@2
$LN112@Draw@2:

; 932  : 
; 933  : 	// clip
; 934  : 
; 935  : 	// Limit drawn area to intersection of rendering surface and rectangular clip area
; 936  : 	CRect r(0, 0, spd.w, spd.h);
; 937  : 	r &= clipRect;

	mov	edx, DWORD PTR _clipRect$[ebp]
	xor	eax, eax
	mov	DWORD PTR _r$[esp+112], eax
	mov	DWORD PTR _r$[esp+116], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _r$[esp+120], eax
	push	edx
	lea	eax, DWORD PTR _r$[esp+116]
	mov	DWORD PTR _r$[esp+128], ecx
	push	eax
	mov	ecx, eax
	push	ecx
	call	DWORD PTR __imp__IntersectRect@12

; 938  : 
; 939  : 	// Remember that all subtitle coordinates are specified in 1/8 pixels
; 940  : 	// (x+4)>>3 rounds to nearest whole pixel.
; 941  : 	// ??? What is xsub, ysub, mOffsetX and mOffsetY ?
; 942  : 	int x = (xsub + mOffsetX + 4)>>3;

	mov	edx, DWORD PTR [edi+132]
	mov	eax, DWORD PTR _xsub$[ebp]

; 943  : 	int y = (ysub + mOffsetY + 4)>>3;

	mov	ecx, DWORD PTR [edi+136]

; 944  : 	int w = mOverlayWidth;

	mov	esi, DWORD PTR [edi+116]
	lea	ebx, DWORD PTR [edx+eax+4]
	mov	edx, DWORD PTR _ysub$[ebp]
	lea	eax, DWORD PTR [ecx+edx+4]

; 945  : 	int h = mOverlayHeight;

	mov	ecx, DWORD PTR [edi+120]
	mov	DWORD PTR _h$[esp+112], ecx

; 946  : 	int xo = 0, yo = 0;

	xor	ecx, ecx
	mov	DWORD PTR _xo$[esp+112], ecx
	mov	DWORD PTR _yo$[esp+112], ecx

; 947  : 
; 948  : 	// Again, limiting?
; 949  : 	if(x < r.left) {xo = r.left-x; w -= r.left-x; x = r.left;}

	mov	ecx, DWORD PTR _r$[esp+112]
	sar	ebx, 3
	sar	eax, 3
	cmp	ebx, ecx
	mov	DWORD PTR _y$[esp+112], eax
	mov	DWORD PTR _w$[esp+112], esi
	jge	SHORT $LN110@Draw@2
	mov	edx, ecx
	sub	edx, ebx
	sub	ebx, ecx
	add	esi, ebx
	mov	DWORD PTR _xo$[esp+112], edx
	mov	DWORD PTR _w$[esp+112], esi
	mov	ebx, ecx
$LN110@Draw@2:

; 950  : 	if(y < r.top) {yo = r.top-y; h -= r.top-y; y = r.top;}

	mov	ecx, DWORD PTR _r$[esp+116]
	cmp	eax, ecx
	jge	SHORT $LN109@Draw@2
	mov	edx, ecx
	sub	edx, eax
	sub	eax, ecx
	add	DWORD PTR _h$[esp+112], eax
	mov	DWORD PTR _yo$[esp+112], edx
	mov	eax, ecx
	mov	DWORD PTR _y$[esp+112], ecx
$LN109@Draw@2:

; 951  : 	if(x+w > r.right) w = r.right-x;

	mov	ecx, DWORD PTR _r$[esp+120]
	lea	edx, DWORD PTR [esi+ebx]
	cmp	edx, ecx
	jle	SHORT $LN108@Draw@2
	sub	ecx, ebx
	mov	esi, ecx
	mov	DWORD PTR _w$[esp+112], esi
$LN108@Draw@2:

; 952  : 	if(y+h > r.bottom) h = r.bottom-y;

	mov	ecx, DWORD PTR _h$[esp+112]
	lea	edx, DWORD PTR [ecx+eax]
	mov	ecx, DWORD PTR _r$[esp+124]
	cmp	edx, ecx
	jle	SHORT $LN107@Draw@2
	sub	ecx, eax
	mov	DWORD PTR _h$[esp+112], ecx
$LN107@Draw@2:

; 953  : 
; 954  : 	// Check if there's actually anything to render
; 955  : 	if(w <= 0 || h <= 0) return(bbox);

	test	esi, esi
	jle	$LN105@Draw@2
	cmp	DWORD PTR _h$[esp+112], 0
	jle	$LN105@Draw@2

; 956  : 
; 957  : 	bbox.SetRect(x, y, x+w, y+h);

	mov	eax, DWORD PTR _y$[esp+112]
	mov	ecx, DWORD PTR _h$[esp+112]
	add	ecx, eax
	push	ecx
	lea	edx, DWORD PTR [esi+ebx]
	push	edx
	push	eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	ebx
	push	eax
	call	DWORD PTR __imp__SetRect@20

; 958  : 	bbox &= CRect(0, 0, spd.w, spd.h);

	xor	eax, eax
	mov	DWORD PTR $T240924[esp+112], eax
	mov	DWORD PTR $T240924[esp+116], eax
	mov	eax, DWORD PTR _spd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax+8]
	lea	eax, DWORD PTR $T240924[esp+112]
	push	eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	push	eax
	mov	DWORD PTR $T240924[esp+132], ecx
	mov	DWORD PTR $T240924[esp+136], edx
	call	DWORD PTR __imp__IntersectRect@12

; 959  : 
; 960  : 	// draw
; 961  : 
; 962  : 	// The alpha bitmap of the subtitles?
; 963  : 	const byte* src = mpOverlayBuffer + 2*(mOverlayWidth * yo + xo);

	mov	ecx, DWORD PTR [edi+116]
	imul	ecx, DWORD PTR _yo$[esp+112]
	add	ecx, DWORD PTR _xo$[esp+112]

; 964  : 	// s points to what the "body" to use is
; 965  : 	// If we're rendering body fill and border, src+1 points to the array of
; 966  : 	// widened regions which contain both border and fill in one.
; 967  : 	const byte* s = fBorder ? (src+1) : src;

	cmp	BYTE PTR _fBorder$[ebp], 0
	mov	edx, DWORD PTR [edi+112]
	lea	edi, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _src$[esp+112], edi
	je	SHORT $LN115@Draw@2
	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR _s$[esp+112], eax
	jmp	SHORT $LN116@Draw@2
$LN115@Draw@2:
	mov	DWORD PTR _s$[esp+112], edi
$LN116@Draw@2:

; 968  : 	// The complex "vector clip mask" I think.
; 969  : 	const byte* am = pAlphaMask + spd.w * y + x;

	mov	ecx, DWORD PTR _spd$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _y$[esp+112]
	imul	eax, edx
	add	eax, ebx
	add	eax, DWORD PTR _pAlphaMask$[ebp]
	mov	DWORD PTR _am$[esp+112], eax

; 970  : 	// How would this differ from src?
; 971  : 	unsigned long* dst = (unsigned long *)((char *)spd.bits + spd.pitch * y) + x;

	mov	eax, DWORD PTR [ecx+16]
	imul	eax, edx
	lea	eax, DWORD PTR [eax+ebx*4]

; 972  : 
; 973  : 	// Grab the first colour
; 974  : 	unsigned long color = switchpts[0];
; 975  : 
; 976  : 	// CPUID from VDub
; 977  : 	bool fSSE2 = !!(g_cpuid.m_flags & CCpuID::sse2);

	mov	ebx, DWORD PTR ?g_cpuid@@3VCCpuID@@A	; g_cpuid
	add	eax, DWORD PTR [ecx+24]
	mov	ecx, DWORD PTR _switchpts$[ebp]
	mov	ecx, DWORD PTR [ecx]
	shr	ebx, 3
	and	bl, 1
	mov	BYTE PTR _fSSE2$[esp+112], bl
	jmp	SHORT $LN104@Draw@2
	npad	8
$LL244@Draw@2:
	mov	bl, BYTE PTR _fSSE2$[esp+112]
$LN104@Draw@2:

; 978  : 
; 979  : 	// Every remaining line in the bitmap to be rendered...
; 980  : 	while(h--)
; 981  : 	{
; 982  : 		// Basic case of no complex clipping mask
; 983  : 		if(!pAlphaMask)
; 984  : 		{
; 985  : 			// If the first colour switching coordinate is at "infinite" we're
; 986  : 			// never switching and can use some simpler code.
; 987  : 			// ??? Is this optimisation really worth the extra readability issues it adds?
; 988  : 			if(switchpts[1] == 0xffffffff)

	mov	edx, DWORD PTR _switchpts$[ebp]
	dec	DWORD PTR _h$[esp+112]
	add	edx, 4
	cmp	DWORD PTR _pAlphaMask$[ebp], 0
	mov	DWORD PTR tv1870[esp+112], edx
	jne	$LN102@Draw@2
	cmp	DWORD PTR [edx], -1
	jne	$LN101@Draw@2

; 989  : 			{
; 990  : 				// fBody is true if we're rendering a fill or a shadow.
; 991  : 				if(fBody)

	cmp	BYTE PTR _fBody$[ebp], 0
	je	$LN100@Draw@2

; 992  : 				{
; 993  : 					// Run over every pixel, overlaying the subtitles with the fill colour
; 994  : 					if(fSSE2)

	test	bl, bl
	je	$LN99@Draw@2

; 995  : 						for(int wt=0; wt<w; ++wt)

	xor	ebx, ebx
	mov	DWORD PTR _wt$131164[esp+112], ebx
	test	esi, esi
	jle	$LN4@Draw@2
	mov	edi, ecx
	shr	edi, 24					; 00000018H
	mov	edx, ecx
	and	edx, 16777215				; 00ffffffH
	pxor	xmm0, xmm0

; 996  : 							// The <<6 is due to pixmix expecting the alpha parameter to be
; 997  : 							// the multiplication of two 6-bit unsigned numbers but we
; 998  : 							// only have one here. (No alpha mask.)
; 999  : 							pixmix_sse2(&dst[wt], color, s[wt*2]);

	movdqa	xmm2, xmm0
	movd	xmm1, edx
	mov	DWORD PTR tv1917[esp+112], edi
	punpcklbw xmm1, xmm2
	jmp	SHORT $LN98@Draw@2
	npad	8
$LL236@Draw@2:
	mov	edi, DWORD PTR tv1917[esp+112]
$LN98@Draw@2:
	mov	edx, DWORD PTR _s$[esp+112]
	movzx	edx, BYTE PTR [edx+ebx*2]
	imul	edx, edi
	mov	edi, DWORD PTR [eax+ebx*4]
	shr	edx, 6
	and	edx, 255				; 000000ffH
	movd	xmm0, edi
	lea	edi, DWORD PTR [edx+1]
	mov	ebx, 256				; 00000100H
	sub	ebx, edx
	shl	edi, 16					; 00000010H
	or	edi, ebx
	mov	ebx, DWORD PTR _wt$131164[esp+112]
	punpcklbw xmm0, xmm2
	punpcklwd xmm0, xmm1
	movd	xmm3, edi
	pshufd	xmm3, xmm3, 0
	pmaddwd	xmm0, xmm3
	psrld	xmm0, 8
	packssdw xmm0, xmm0
	packuswb xmm0, xmm0
	movd	edx, xmm0
	mov	DWORD PTR [eax+ebx*4], edx
	inc	ebx
	cmp	ebx, esi
	mov	DWORD PTR _wt$131164[esp+112], ebx
	jl	SHORT $LL236@Draw@2
	jmp	$LN246@Draw@2
$LN99@Draw@2:

; 1000 : 					else
; 1001 : 						for(int wt=0; wt<w; ++wt)

	xor	ebx, ebx
	mov	DWORD PTR _wt$131169[esp+112], ebx
	test	esi, esi
	jle	$LN4@Draw@2
	mov	edx, ecx
	and	edx, 16711935				; 00ff00ffH

; 1138 : 					}
; 1139 : 				}
; 1140 : 			}
; 1141 : 		}
; 1142 : 
; 1143 : 		// Step to next scanline
; 1144 : 		src += 2*mOverlayWidth;

	mov	DWORD PTR tv1927[esp+112], edx
	mov	esi, ecx
	shr	esi, 24					; 00000018H
	mov	edx, ecx
	and	edx, 65280				; 0000ff00H
	mov	DWORD PTR tv1917[esp+112], esi
	mov	DWORD PTR tv1933[esp+112], edx
	jmp	SHORT $LN94@Draw@2
	npad	6
$LL228@Draw@2:
	mov	esi, DWORD PTR tv1917[esp+112]
$LN94@Draw@2:

; 1002 : 							pixmix(&dst[wt], color, s[wt*2]);

	mov	edx, DWORD PTR _s$[esp+112]
	movzx	edx, BYTE PTR [edx+ebx*2]
	mov	ebx, DWORD PTR [eax+ebx*4]
	imul	edx, esi
	shr	edx, 6
	and	edx, 255				; 000000ffH
	mov	edi, ebx
	and	edi, 65280				; 0000ff00H
	mov	esi, 256				; 00000100H
	sub	esi, edx
	imul	edi, esi
	mov	DWORD PTR _ia$240975[esp+112], esi
	mov	esi, DWORD PTR tv1933[esp+112]
	inc	edx
	imul	esi, edx
	add	edi, esi
	mov	esi, DWORD PTR tv1927[esp+112]
	mov	DWORD PTR tv3138[esp+112], ebx
	imul	esi, edx
	and	ebx, -65281				; ffff00ffH
	imul	ebx, DWORD PTR _ia$240975[esp+112]
	add	ebx, esi
	mov	esi, DWORD PTR tv3138[esp+112]
	xor	edi, ebx
	mov	ebx, DWORD PTR tv1927[esp+112]
	imul	ebx, edx
	mov	edx, DWORD PTR tv3138[esp+112]
	and	esi, 16711935				; 00ff00ffH
	imul	esi, DWORD PTR _ia$240975[esp+112]
	shr	edx, 8
	and	edx, 16711680				; 00ff0000H
	imul	edx, DWORD PTR _ia$240975[esp+112]
	add	esi, ebx
	mov	ebx, DWORD PTR _wt$131169[esp+112]
	and	edi, 16711680				; 00ff0000H
	xor	edi, esi
	mov	esi, DWORD PTR _w$[esp+112]
	shr	edi, 8
	and	edx, -16777216				; ff000000H
	or	edi, edx
	mov	DWORD PTR [eax+ebx*4], edi
	inc	ebx
	cmp	ebx, esi
	mov	DWORD PTR _wt$131169[esp+112], ebx
	jl	$LL228@Draw@2

; 1003 : 				}
; 1004 : 				// Not painting body, ie. painting border without fill in it
; 1005 : 				else

	jmp	$LN246@Draw@2
$LN100@Draw@2:

; 1006 : 				{
; 1007 : 					if(fSSE2)

	test	bl, bl
	je	$LN90@Draw@2

; 1008 : 						for(int wt=0; wt<w; ++wt)

	xor	ebx, ebx
	mov	DWORD PTR _wt$131175[esp+112], ebx
	test	esi, esi
	jle	$LN4@Draw@2
	mov	edx, ecx
	shr	edx, 24					; 00000018H
	mov	DWORD PTR tv1917[esp+112], edx
	mov	edx, ecx
	and	edx, 16777215				; 00ffffffH
	pxor	xmm0, xmm0

; 1009 : 							// src contains two different bitmaps, interlaced per pixel.
; 1010 : 							// The first stored is the fill, the second is the widened
; 1011 : 							// fill region created by CreateWidenedRegion().
; 1012 : 							// Since we're drawing only the border, we must otain that
; 1013 : 							// by subtracting the fill from the widened region. The
; 1014 : 							// subtraction must be saturating since the widened region
; 1015 : 							// pixel value can be smaller than the fill value.
; 1016 : 							// This happens when blur edges is used.
; 1017 : 							pixmix_sse2(&dst[wt], color, safe_subtract(src[wt*2+1], src[wt*2]));

	movdqa	xmm2, xmm0
	movd	xmm1, edx
	punpcklbw xmm1, xmm2
	npad	10
$LL237@Draw@2:
	movzx	edx, BYTE PTR [edi+ebx*2+1]
	movd	mm0, edx
	movzx	edx, BYTE PTR [edi+ebx*2]
	movd	mm1, edx
	psubusw	mm0, mm1
	movd	edi, mm0
	emms
	mov	edx, DWORD PTR tv1917[esp+112]
	imul	edx, edi
	mov	edi, DWORD PTR [eax+ebx*4]
	shr	edx, 6
	and	edx, 255				; 000000ffH
	movd	xmm0, edi
	lea	edi, DWORD PTR [edx+1]
	shl	edi, 16					; 00000010H
	mov	ebx, 256				; 00000100H
	sub	ebx, edx
	or	edi, ebx
	mov	ebx, DWORD PTR _wt$131175[esp+112]
	punpcklbw xmm0, xmm2
	punpcklwd xmm0, xmm1
	movd	xmm3, edi
	mov	edi, DWORD PTR _src$[esp+112]
	pshufd	xmm3, xmm3, 0
	pmaddwd	xmm0, xmm3
	psrld	xmm0, 8
	packssdw xmm0, xmm0
	packuswb xmm0, xmm0
	movd	edx, xmm0
	mov	DWORD PTR [eax+ebx*4], edx
	inc	ebx
	cmp	ebx, esi
	mov	DWORD PTR _wt$131175[esp+112], ebx
	jl	SHORT $LL237@Draw@2
	jmp	$LN4@Draw@2
$LN90@Draw@2:

; 1018 : 					else
; 1019 : 						for(int wt=0; wt<w; ++wt)

	xor	ebx, ebx
	mov	DWORD PTR _wt$131180[esp+112], ebx
	test	esi, esi
	jle	$LN4@Draw@2
	mov	esi, ecx
	and	esi, 16711935				; 00ff00ffH
	mov	DWORD PTR tv1927[esp+112], esi
	mov	edx, ecx
	shr	edx, 24					; 00000018H
	mov	esi, ecx
	and	esi, 65280				; 0000ff00H
	mov	DWORD PTR tv1917[esp+112], edx
	mov	DWORD PTR tv1933[esp+112], esi
	jmp	SHORT $LN85@Draw@2
	npad	3
$LL229@Draw@2:

; 1002 : 							pixmix(&dst[wt], color, s[wt*2]);

	mov	edx, DWORD PTR tv1917[esp+112]
$LN85@Draw@2:

; 1020 : 							pixmix(&dst[wt], color, safe_subtract(src[wt*2+1], src[wt*2]));

	movzx	esi, BYTE PTR [edi+ebx*2+1]
	movd	mm0, esi
	movzx	esi, BYTE PTR [edi+ebx*2]
	movd	mm1, esi
	psubusw	mm0, mm1
	movd	esi, mm0
	emms
	imul	edx, esi
	mov	ebx, DWORD PTR [eax+ebx*4]
	shr	edx, 6
	and	edx, 255				; 000000ffH
	mov	esi, ebx
	and	esi, 65280				; 0000ff00H
	mov	edi, 256				; 00000100H
	sub	edi, edx
	imul	esi, edi
	mov	DWORD PTR _ia$241028[esp+112], edi
	mov	edi, DWORD PTR tv1933[esp+112]
	inc	edx
	imul	edi, edx
	add	esi, edi
	mov	edi, DWORD PTR tv1927[esp+112]
	mov	DWORD PTR tv3377[esp+112], ebx
	imul	edi, edx
	and	ebx, -65281				; ffff00ffH
	imul	ebx, DWORD PTR _ia$241028[esp+112]
	add	ebx, edi
	mov	edi, DWORD PTR tv3377[esp+112]
	xor	esi, ebx
	mov	ebx, DWORD PTR tv1927[esp+112]
	imul	ebx, edx
	mov	edx, DWORD PTR tv3377[esp+112]
	and	edi, 16711935				; 00ff00ffH
	imul	edi, DWORD PTR _ia$241028[esp+112]
	shr	edx, 8
	and	edx, 16711680				; 00ff0000H
	imul	edx, DWORD PTR _ia$241028[esp+112]
	and	esi, 16711680				; 00ff0000H
	add	edi, ebx
	mov	ebx, DWORD PTR _wt$131180[esp+112]
	xor	esi, edi

; 1021 : 				}
; 1022 : 			}
; 1023 : 			// not (switchpts[1] == 0xffffffff)
; 1024 : 			else

	mov	edi, DWORD PTR _src$[esp+112]
	shr	esi, 8
	and	edx, -16777216				; ff000000H
	or	esi, edx
	mov	DWORD PTR [eax+ebx*4], esi
	mov	esi, DWORD PTR _w$[esp+112]
	inc	ebx
	cmp	ebx, esi
	mov	DWORD PTR _wt$131180[esp+112], ebx
	jl	$LL229@Draw@2
	jmp	$LN4@Draw@2
$LN101@Draw@2:

; 1025 : 			{
; 1026 : 				// switchpts plays an important rule here
; 1027 : 				const long *sw = switchpts;
; 1028 : 
; 1029 : 				if(fBody)

	cmp	BYTE PTR _fBody$[ebp], 0
	mov	edx, DWORD PTR _switchpts$[ebp]
	mov	DWORD PTR _sw$131185[esp+112], edx
	je	$LN81@Draw@2

; 1030 : 				{
; 1031 : 					if(fSSE2) 

	test	bl, bl
	je	$LN80@Draw@2

; 1032 : 					for(int wt=0; wt<w; ++wt)

	xor	ebx, ebx
	mov	DWORD PTR _wt$131188[esp+112], ebx
	test	esi, esi
	jle	$LN4@Draw@2
	mov	edx, DWORD PTR tv1870[esp+112]
	mov	DWORD PTR tv2030[esp+112], edx
	mov	edx, DWORD PTR _xo$[esp+112]
	pxor	xmm1, xmm1
	mov	DWORD PTR tv3396[esp+112], edx
$LN79@Draw@2:

; 1033 : 					{
; 1034 : 						// xo is the offset (usually negative) we have moved into the image
; 1035 : 						// So if we have passed the switchpoint (?) switch to another colour
; 1036 : 						// (So switchpts stores both colours *and* coordinates?)
; 1037 : 						if(wt+xo >= sw[1]) {while(wt+xo >= sw[1]) sw += 2; color = sw[-2];}

	mov	edi, DWORD PTR tv2030[esp+112]
	cmp	edx, DWORD PTR [edi]
	jl	SHORT $LN76@Draw@2
	mov	ecx, DWORD PTR _sw$131185[esp+112]
	npad	7
$LL75@Draw@2:
	add	ecx, 8
	cmp	edx, DWORD PTR [ecx+4]
	lea	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR tv2030[esp+112], edi
	jge	SHORT $LL75@Draw@2
	mov	DWORD PTR _sw$131185[esp+112], ecx
	mov	ecx, DWORD PTR [ecx-8]
$LN76@Draw@2:

; 1038 : 						pixmix_sse2(&dst[wt], color, s[wt*2]);

	mov	edx, DWORD PTR _s$[esp+112]
	movzx	edx, BYTE PTR [edx+ebx*2]
	mov	edi, ecx
	shr	edi, 24					; 00000018H
	imul	edx, edi
	mov	edi, DWORD PTR [eax+ebx*4]
	movd	xmm0, edi
	shr	edx, 6
	and	edx, 255				; 000000ffH
	mov	edi, ecx
	and	edi, 16777215				; 00ffffffH
	movd	xmm2, edi
	lea	edi, DWORD PTR [edx+1]
	punpcklbw xmm0, xmm1
	mov	ebx, 256				; 00000100H
	sub	ebx, edx
	shl	edi, 16					; 00000010H
	or	edi, ebx
	mov	ebx, DWORD PTR _wt$131188[esp+112]
	punpcklbw xmm2, xmm1
	punpcklwd xmm0, xmm2
	movd	xmm2, edi
	pshufd	xmm2, xmm2, 0
	pmaddwd	xmm0, xmm2
	psrld	xmm0, 8
	packssdw xmm0, xmm0
	packuswb xmm0, xmm0
	movd	edx, xmm0
	mov	DWORD PTR [eax+ebx*4], edx
	mov	edx, DWORD PTR tv3396[esp+112]
	inc	ebx
	inc	edx
	cmp	ebx, esi
	mov	DWORD PTR _wt$131188[esp+112], ebx
	mov	DWORD PTR tv3396[esp+112], edx
	jl	$LN79@Draw@2

; 1039 : 					}

	jmp	$LN246@Draw@2
$LN80@Draw@2:

; 1040 : 					else
; 1041 : 					for(int wt=0; wt<w; ++wt)

	xor	ebx, ebx
	mov	DWORD PTR _wt$131197[esp+112], ebx
	test	esi, esi
	jle	$LN4@Draw@2
	mov	esi, DWORD PTR tv1870[esp+112]
	mov	edi, DWORD PTR _xo$[esp+112]
	mov	DWORD PTR tv2030[esp+112], esi
	mov	DWORD PTR tv3483[esp+112], edi
	jmp	SHORT $LN72@Draw@2
	npad	3
$LL230@Draw@2:
	mov	edx, DWORD PTR _sw$131185[esp+112]
$LN72@Draw@2:

; 1042 : 					{
; 1043 : 						if(wt+xo >= sw[1]) {while(wt+xo >= sw[1]) sw += 2; color = sw[-2];}

	mov	esi, DWORD PTR tv2030[esp+112]
	cmp	edi, DWORD PTR [esi]
	jl	SHORT $LN69@Draw@2
	npad	4
$LL68@Draw@2:
	add	edx, 8
	cmp	edi, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR tv2030[esp+112], ecx
	jge	SHORT $LL68@Draw@2
	mov	ecx, DWORD PTR [edx-8]
	mov	DWORD PTR _sw$131185[esp+112], edx
$LN69@Draw@2:

; 1044 : 						pixmix(&dst[wt], color, s[wt*2]);

	mov	edx, DWORD PTR _s$[esp+112]
	movzx	edx, BYTE PTR [edx+ebx*2]
	mov	ebx, DWORD PTR [eax+ebx*4]
	mov	esi, ecx
	shr	esi, 24					; 00000018H
	imul	edx, esi
	shr	edx, 6
	and	edx, 255				; 000000ffH
	mov	esi, 256				; 00000100H
	sub	esi, edx
	inc	edx
	mov	DWORD PTR _ia$241056[esp+112], esi
	mov	esi, ebx
	and	esi, -65281				; ffff00ffH
	imul	esi, DWORD PTR _ia$241056[esp+112]
	mov	edi, ecx
	and	edi, -65281				; ffff00ffH
	imul	edi, edx
	add	edi, esi
	mov	esi, ecx
	and	esi, 65280				; 0000ff00H
	imul	esi, edx
	mov	DWORD PTR tv3570[esp+112], ebx
	and	ebx, 65280				; 0000ff00H
	mov	DWORD PTR tv5012[esp+112], esi
	mov	esi, DWORD PTR _ia$241056[esp+112]
	imul	ebx, esi
	mov	DWORD PTR _a$241055[esp+112], edx
	mov	edx, DWORD PTR tv5012[esp+112]
	add	edx, ebx
	mov	ebx, DWORD PTR tv3570[esp+112]
	xor	edi, edx
	and	ebx, 16711935				; 00ff00ffH
	mov	edx, ecx
	imul	ebx, esi
	and	edx, 16711935				; 00ff00ffH
	imul	edx, DWORD PTR _a$241055[esp+112]
	add	edx, ebx
	mov	ebx, DWORD PTR _wt$131197[esp+112]
	and	edi, 16711680				; 00ff0000H
	xor	edi, edx
	mov	edx, DWORD PTR tv3570[esp+112]
	shr	edx, 8
	and	edx, 16711680				; 00ff0000H
	imul	edx, esi
	mov	esi, DWORD PTR _w$[esp+112]
	shr	edi, 8
	and	edx, -16777216				; ff000000H
	or	edi, edx
	mov	DWORD PTR [eax+ebx*4], edi
	mov	edi, DWORD PTR tv3483[esp+112]
	inc	ebx
	inc	edi
	cmp	ebx, esi
	mov	DWORD PTR _wt$131197[esp+112], ebx
	mov	DWORD PTR tv3483[esp+112], edi
	jl	$LL230@Draw@2

; 1045 : 					}
; 1046 : 				}
; 1047 : 				// Not body
; 1048 : 				else

	jmp	$LN246@Draw@2
$LN81@Draw@2:

; 1049 : 				{
; 1050 : 					if(fSSE2) 

	test	bl, bl
	je	$LN65@Draw@2

; 1051 : 					for(int wt=0; wt<w; ++wt)

	mov	DWORD PTR _wt$131207[esp+112], 0
	test	esi, esi
	jle	$LN4@Draw@2
	mov	edx, DWORD PTR tv1870[esp+112]
	mov	ebx, DWORD PTR _xo$[esp+112]
	mov	DWORD PTR tv2030[esp+112], edx
	pxor	xmm1, xmm1
	mov	DWORD PTR tv3589[esp+112], ebx
$LL64@Draw@2:

; 1052 : 					{
; 1053 : 						if(wt+xo >= sw[1]) {while(wt+xo >= sw[1]) sw += 2; color = sw[-2];} 

	mov	edx, DWORD PTR tv2030[esp+112]
	cmp	ebx, DWORD PTR [edx]
	jl	SHORT $LN61@Draw@2
	mov	ecx, DWORD PTR _sw$131185[esp+112]
$LL60@Draw@2:
	add	ecx, 8
	cmp	ebx, DWORD PTR [ecx+4]
	lea	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv2030[esp+112], edx
	jge	SHORT $LL60@Draw@2
	mov	DWORD PTR _sw$131185[esp+112], ecx
	mov	ecx, DWORD PTR [ecx-8]
$LN61@Draw@2:

; 1054 : 						pixmix_sse2(&dst[wt], color, safe_subtract(src[wt*2+1], src[wt*2]));

	mov	ebx, DWORD PTR _wt$131207[esp+112]
	movzx	edx, BYTE PTR [edi+ebx*2+1]
	movd	mm0, edx
	movzx	edx, BYTE PTR [edi+ebx*2]
	movd	mm1, edx
	psubusw	mm0, mm1
	movd	edi, mm0
	emms
	mov	edx, ecx
	shr	edx, 24					; 00000018H
	imul	edx, edi
	mov	edi, DWORD PTR [eax+ebx*4]
	movd	xmm0, edi
	shr	edx, 6
	and	edx, 255				; 000000ffH
	mov	edi, ecx
	and	edi, 16777215				; 00ffffffH
	movd	xmm2, edi
	lea	edi, DWORD PTR [edx+1]
	shl	edi, 16					; 00000010H
	punpcklbw xmm0, xmm1
	mov	ebx, 256				; 00000100H
	sub	ebx, edx
	mov	edx, DWORD PTR _wt$131207[esp+112]
	or	edi, ebx
	mov	ebx, DWORD PTR tv3589[esp+112]
	punpcklbw xmm2, xmm1
	punpcklwd xmm0, xmm2
	movd	xmm2, edi
	pshufd	xmm2, xmm2, 0
	pmaddwd	xmm0, xmm2
	psrld	xmm0, 8
	packssdw xmm0, xmm0
	packuswb xmm0, xmm0
	movd	edi, xmm0
	mov	DWORD PTR [eax+edx*4], edi

; 1055 : 					}

	mov	edi, DWORD PTR _src$[esp+112]
	inc	edx
	inc	ebx
	cmp	edx, esi
	mov	DWORD PTR _wt$131207[esp+112], edx
	mov	DWORD PTR tv3589[esp+112], ebx
	jl	$LL64@Draw@2
	jmp	$LN4@Draw@2
$LN65@Draw@2:

; 1056 : 					else
; 1057 : 					for(int wt=0; wt<w; ++wt)

	xor	ebx, ebx
	mov	DWORD PTR _wt$131216[esp+112], ebx
	test	esi, esi
	jle	$LN4@Draw@2
	mov	edx, DWORD PTR tv1870[esp+112]
	mov	DWORD PTR tv2030[esp+112], edx
	mov	edx, DWORD PTR _xo$[esp+112]
	mov	DWORD PTR tv3714[esp+112], edx
$LL57@Draw@2:

; 1058 : 					{
; 1059 : 						if(wt+xo >= sw[1]) {while(wt+xo >= sw[1]) sw += 2; color = sw[-2];} 

	mov	esi, DWORD PTR tv2030[esp+112]
	cmp	edx, DWORD PTR [esi]
	jl	SHORT $LN54@Draw@2
	mov	ecx, DWORD PTR _sw$131185[esp+112]
	npad	1
$LL53@Draw@2:
	add	ecx, 8
	cmp	edx, DWORD PTR [ecx+4]
	lea	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR tv2030[esp+112], esi
	jge	SHORT $LL53@Draw@2
	mov	DWORD PTR _sw$131185[esp+112], ecx
	mov	ecx, DWORD PTR [ecx-8]
$LN54@Draw@2:

; 1060 : 						pixmix(&dst[wt], color, safe_subtract(src[wt*2+1], src[wt*2]));

	movzx	edx, BYTE PTR [edi+ebx*2+1]
	movd	mm0, edx
	movzx	edx, BYTE PTR [edi+ebx*2]
	movd	mm1, edx
	psubusw	mm0, mm1
	movd	esi, mm0
	emms
	mov	ebx, DWORD PTR [eax+ebx*4]
	mov	edx, ecx
	shr	edx, 24					; 00000018H
	imul	edx, esi
	mov	DWORD PTR tv3837[esp+112], ebx
	mov	edi, ebx
	shr	edx, 6
	and	edx, 255				; 000000ffH
	and	edi, -65281				; ffff00ffH
	mov	esi, 256				; 00000100H
	sub	esi, edx
	imul	edi, esi
	inc	edx
	mov	ebx, ecx
	and	ebx, -65281				; ffff00ffH
	imul	ebx, edx
	add	edi, ebx
	mov	ebx, DWORD PTR tv3837[esp+112]
	and	ebx, 65280				; 0000ff00H
	imul	ebx, esi
	mov	DWORD PTR _ia$241109[esp+112], esi
	mov	esi, ecx
	and	esi, 65280				; 0000ff00H
	imul	esi, edx
	add	ebx, esi
	mov	esi, DWORD PTR tv3837[esp+112]
	xor	edi, ebx
	mov	ebx, ecx
	and	ebx, 16711935				; 00ff00ffH
	imul	ebx, edx
	mov	edx, DWORD PTR tv3837[esp+112]
	and	esi, 16711935				; 00ff00ffH
	imul	esi, DWORD PTR _ia$241109[esp+112]
	shr	edx, 8
	and	edx, 16711680				; 00ff0000H
	imul	edx, DWORD PTR _ia$241109[esp+112]
	and	edi, 16711680				; 00ff0000H
	add	esi, ebx
	mov	ebx, DWORD PTR _wt$131216[esp+112]
	xor	edi, esi
	mov	esi, DWORD PTR _w$[esp+112]
	and	edx, -16777216				; ff000000H
	shr	edi, 8
	or	edi, edx
	mov	edx, DWORD PTR tv3714[esp+112]
	mov	DWORD PTR [eax+ebx*4], edi

; 1061 : 					}
; 1062 : 				}
; 1063 : 			}
; 1064 : 		}
; 1065 : 		// Here we *do* have an alpha mask
; 1066 : 		else

	mov	edi, DWORD PTR _src$[esp+112]
	inc	ebx
	inc	edx
	cmp	ebx, esi
	mov	DWORD PTR _wt$131216[esp+112], ebx
	mov	DWORD PTR tv3714[esp+112], edx
	jl	$LL57@Draw@2
	jmp	$LN4@Draw@2
$LN102@Draw@2:

; 1067 : 		{
; 1068 : 			if(switchpts[1] == 0xffffffff)

	cmp	DWORD PTR [edx], -1
	jne	$LN50@Draw@2

; 1069 : 			{
; 1070 : 				if(fBody)

	cmp	BYTE PTR _fBody$[ebp], 0
	je	$LN49@Draw@2

; 1071 : 				{
; 1072 : 					if(fSSE2)

	test	bl, bl
	je	$LN48@Draw@2

; 1073 : 						for(int wt=0; wt<w; ++wt)

	xor	ebx, ebx
	mov	DWORD PTR _wt$131228[esp+112], ebx
	test	esi, esi
	jle	$LN4@Draw@2
	mov	edx, ecx
	shr	edx, 24					; 00000018H
	mov	DWORD PTR tv1917[esp+112], edx
	mov	edx, ecx
	and	edx, 16777215				; 00ffffffH
	pxor	xmm0, xmm0

; 1074 : 							// Both s and am contain 6-bit bitmaps of two different
; 1075 : 							// alpha masks; s is the subtitle shape and am is the
; 1076 : 							// clipping mask.
; 1077 : 							// Multiplying them together yields a 12-bit number.
; 1078 : 							// I think some imprecision is introduced here??
; 1079 : 							pixmix2_sse2(&dst[wt], color, s[wt*2], am[wt]);

	movdqa	xmm2, xmm0
	movd	xmm1, edx
	punpcklbw xmm1, xmm2
$LN47@Draw@2:
	mov	edx, DWORD PTR _s$[esp+112]
	movzx	edx, BYTE PTR [edx+ebx*2]
	mov	edi, DWORD PTR _am$[esp+112]
	movzx	edi, BYTE PTR [ebx+edi]
	imul	edx, edi
	imul	edx, DWORD PTR tv1917[esp+112]
	mov	edi, DWORD PTR [eax+ebx*4]
	shr	edx, 12					; 0000000cH
	and	edx, 255				; 000000ffH
	movd	xmm0, edi
	lea	edi, DWORD PTR [edx+1]
	mov	ebx, 256				; 00000100H
	sub	ebx, edx
	shl	edi, 16					; 00000010H
	or	edi, ebx
	mov	ebx, DWORD PTR _wt$131228[esp+112]
	punpcklbw xmm0, xmm2
	punpcklwd xmm0, xmm1
	movd	xmm3, edi
	pshufd	xmm3, xmm3, 0
	pmaddwd	xmm0, xmm3
	psrld	xmm0, 8
	packssdw xmm0, xmm0
	packuswb xmm0, xmm0
	movd	edx, xmm0
	mov	DWORD PTR [eax+ebx*4], edx
	inc	ebx
	cmp	ebx, esi
	mov	DWORD PTR _wt$131228[esp+112], ebx
	jl	SHORT $LN47@Draw@2
	jmp	$LN246@Draw@2
$LN48@Draw@2:

; 1080 : 					else
; 1081 : 						for(int wt=0; wt<w; ++wt)

	xor	ebx, ebx
	mov	DWORD PTR _wt$131233[esp+112], ebx
	test	esi, esi
	jle	$LN4@Draw@2
	mov	edx, ecx
	and	edx, 16711935				; 00ff00ffH
	mov	DWORD PTR tv1927[esp+112], edx
	mov	esi, ecx
	shr	esi, 24					; 00000018H
	mov	edx, ecx
	and	edx, 65280				; 0000ff00H
	mov	DWORD PTR tv1917[esp+112], esi
	mov	DWORD PTR tv1933[esp+112], edx
	jmp	SHORT $LN43@Draw@2
	npad	3
$LL232@Draw@2:

; 1060 : 						pixmix(&dst[wt], color, safe_subtract(src[wt*2+1], src[wt*2]));

	mov	esi, DWORD PTR tv1917[esp+112]
$LN43@Draw@2:

; 1082 : 							pixmix2(&dst[wt], color, s[wt*2], am[wt]);

	mov	edx, DWORD PTR _s$[esp+112]
	movzx	edx, BYTE PTR [edx+ebx*2]
	mov	edi, DWORD PTR _am$[esp+112]
	movzx	edi, BYTE PTR [ebx+edi]
	mov	ebx, DWORD PTR [eax+ebx*4]
	imul	edx, edi
	imul	edx, esi
	shr	edx, 12					; 0000000cH
	and	edx, 255				; 000000ffH
	mov	edi, ebx
	and	edi, 65280				; 0000ff00H
	mov	esi, 256				; 00000100H
	sub	esi, edx
	imul	edi, esi
	mov	DWORD PTR _ia$241139[esp+112], esi
	mov	esi, DWORD PTR tv1933[esp+112]
	inc	edx
	imul	esi, edx
	add	edi, esi
	mov	esi, DWORD PTR tv1927[esp+112]
	mov	DWORD PTR tv4051[esp+112], ebx
	imul	esi, edx
	and	ebx, -65281				; ffff00ffH
	imul	ebx, DWORD PTR _ia$241139[esp+112]
	add	ebx, esi
	mov	esi, DWORD PTR tv4051[esp+112]
	xor	edi, ebx
	mov	ebx, DWORD PTR tv1927[esp+112]
	imul	ebx, edx
	mov	edx, DWORD PTR tv4051[esp+112]
	and	esi, 16711935				; 00ff00ffH
	imul	esi, DWORD PTR _ia$241139[esp+112]
	shr	edx, 8
	and	edx, 16711680				; 00ff0000H
	imul	edx, DWORD PTR _ia$241139[esp+112]
	add	esi, ebx
	mov	ebx, DWORD PTR _wt$131233[esp+112]
	and	edi, 16711680				; 00ff0000H
	xor	edi, esi
	mov	esi, DWORD PTR _w$[esp+112]
	shr	edi, 8
	and	edx, -16777216				; ff000000H
	or	edi, edx
	mov	DWORD PTR [eax+ebx*4], edi
	inc	ebx
	cmp	ebx, esi
	mov	DWORD PTR _wt$131233[esp+112], ebx
	jl	$LL232@Draw@2

; 1083 : 				}
; 1084 : 				else

	jmp	$LN246@Draw@2
$LN49@Draw@2:

; 1085 : 				{
; 1086 : 					if(fSSE2)

	test	bl, bl
	je	$LN39@Draw@2

; 1087 : 						for(int wt=0; wt<w; ++wt)

	xor	ebx, ebx
	mov	DWORD PTR _wt$131239[esp+112], ebx
	test	esi, esi
	jle	$LN4@Draw@2
	mov	edx, ecx
	shr	edx, 24					; 00000018H
	mov	DWORD PTR tv1917[esp+112], edx
	mov	edx, ecx
	and	edx, 16777215				; 00ffffffH
	pxor	xmm0, xmm0

; 1088 : 							pixmix2_sse2(&dst[wt], color, safe_subtract(src[wt*2+1], src[wt*2]), am[wt]);

	movdqa	xmm2, xmm0
	movd	xmm1, edx
	punpcklbw xmm1, xmm2
$LL241@Draw@2:
	movzx	edx, BYTE PTR [edi+ebx*2+1]
	movd	mm0, edx
	movzx	edx, BYTE PTR [edi+ebx*2]
	movd	mm1, edx
	psubusw	mm0, mm1
	movd	DWORD PTR _r$241151[esp+112], mm0
	emms
	mov	edx, DWORD PTR _am$[esp+112]
	movzx	edx, BYTE PTR [ebx+edx]
	imul	edx, DWORD PTR tv1917[esp+112]
	imul	edx, DWORD PTR _r$241151[esp+112]
	mov	edi, DWORD PTR [eax+ebx*4]
	shr	edx, 12					; 0000000cH
	and	edx, 255				; 000000ffH
	movd	xmm0, edi
	lea	edi, DWORD PTR [edx+1]
	shl	edi, 16					; 00000010H
	mov	ebx, 256				; 00000100H
	sub	ebx, edx
	or	edi, ebx
	mov	ebx, DWORD PTR _wt$131239[esp+112]
	punpcklbw xmm0, xmm2
	punpcklwd xmm0, xmm1
	movd	xmm3, edi
	mov	edi, DWORD PTR _src$[esp+112]
	pshufd	xmm3, xmm3, 0
	pmaddwd	xmm0, xmm3
	psrld	xmm0, 8
	packssdw xmm0, xmm0
	packuswb xmm0, xmm0
	movd	edx, xmm0
	mov	DWORD PTR [eax+ebx*4], edx
	inc	ebx
	cmp	ebx, esi
	mov	DWORD PTR _wt$131239[esp+112], ebx
	jl	$LL241@Draw@2
	jmp	$LN4@Draw@2
$LN39@Draw@2:

; 1089 : 					else
; 1090 : 						for(int wt=0; wt<w; ++wt)

	xor	ebx, ebx
	mov	DWORD PTR _wt$131244[esp+112], ebx
	test	esi, esi
	jle	$LN4@Draw@2
	mov	edx, ecx
	and	edx, 16711935				; 00ff00ffH
	mov	DWORD PTR tv1927[esp+112], edx
	mov	esi, ecx
	shr	esi, 24					; 00000018H
	mov	edx, ecx
	and	edx, 65280				; 0000ff00H
	mov	DWORD PTR tv1917[esp+112], esi
	mov	DWORD PTR tv1933[esp+112], edx
	jmp	SHORT $LN34@Draw@2
	npad	1
$LL233@Draw@2:

; 1082 : 							pixmix2(&dst[wt], color, s[wt*2], am[wt]);

	mov	esi, DWORD PTR tv1917[esp+112]
$LN34@Draw@2:

; 1091 : 							pixmix2(&dst[wt], color, safe_subtract(src[wt*2+1], src[wt*2]), am[wt]);

	movzx	edx, BYTE PTR [edi+ebx*2+1]
	movd	mm0, edx
	movzx	edx, BYTE PTR [edi+ebx*2]
	movd	mm1, edx
	psubusw	mm0, mm1
	movd	edi, mm0
	emms
	mov	edx, DWORD PTR _am$[esp+112]
	movzx	edx, BYTE PTR [ebx+edx]
	imul	edx, esi
	mov	ebx, DWORD PTR [eax+ebx*4]
	imul	edx, edi
	shr	edx, 12					; 0000000cH
	and	edx, 255				; 000000ffH
	mov	esi, ebx
	and	esi, 65280				; 0000ff00H
	mov	edi, 256				; 00000100H
	sub	edi, edx
	imul	esi, edi
	mov	DWORD PTR _ia$241194[esp+112], edi
	mov	edi, DWORD PTR tv1933[esp+112]
	inc	edx
	imul	edi, edx
	add	esi, edi
	mov	edi, DWORD PTR tv1927[esp+112]
	mov	DWORD PTR tv4334[esp+112], ebx
	imul	edi, edx
	and	ebx, -65281				; ffff00ffH
	imul	ebx, DWORD PTR _ia$241194[esp+112]
	add	ebx, edi
	mov	edi, DWORD PTR tv4334[esp+112]
	xor	esi, ebx
	mov	ebx, DWORD PTR tv1927[esp+112]
	imul	ebx, edx
	mov	edx, DWORD PTR tv4334[esp+112]
	and	edi, 16711935				; 00ff00ffH
	imul	edi, DWORD PTR _ia$241194[esp+112]
	shr	edx, 8
	and	edx, 16711680				; 00ff0000H
	imul	edx, DWORD PTR _ia$241194[esp+112]
	and	esi, 16711680				; 00ff0000H
	add	edi, ebx
	mov	ebx, DWORD PTR _wt$131244[esp+112]
	xor	esi, edi

; 1092 : 				}
; 1093 : 			}
; 1094 : 			else

	mov	edi, DWORD PTR _src$[esp+112]
	shr	esi, 8
	and	edx, -16777216				; ff000000H
	or	esi, edx
	mov	DWORD PTR [eax+ebx*4], esi
	mov	esi, DWORD PTR _w$[esp+112]
	inc	ebx
	cmp	ebx, esi
	mov	DWORD PTR _wt$131244[esp+112], ebx
	jl	$LL233@Draw@2
	jmp	$LN4@Draw@2
$LN50@Draw@2:

; 1095 : 			{
; 1096 : 				const long *sw = switchpts;
; 1097 : 
; 1098 : 				if(fBody)

	cmp	BYTE PTR _fBody$[ebp], 0
	mov	edx, DWORD PTR _switchpts$[ebp]
	mov	DWORD PTR _sw$131249[esp+112], edx
	je	$LN30@Draw@2

; 1099 : 				{
; 1100 : 					if(fSSE2) 

	test	bl, bl
	je	$LN29@Draw@2

; 1101 : 					for(int wt=0; wt<w; ++wt)

	mov	DWORD PTR _wt$131252[esp+112], 0
	test	esi, esi
	jle	$LN4@Draw@2
	mov	edx, DWORD PTR tv1870[esp+112]
	mov	edi, DWORD PTR _xo$[esp+112]
	mov	DWORD PTR tv2369[esp+112], edx
	mov	edx, DWORD PTR _am$[esp+112]
	sub	edx, edi
	mov	DWORD PTR tv4428[esp+112], edx
	mov	edx, DWORD PTR _wt$131252[esp+112]
	pxor	xmm1, xmm1
	mov	DWORD PTR tv4355[esp+112], edi
$LN28@Draw@2:

; 1102 : 					{
; 1103 : 						if(wt+xo >= sw[1]) {

	mov	ebx, DWORD PTR tv2369[esp+112]
	cmp	edi, DWORD PTR [ebx]
	jl	SHORT $LN25@Draw@2
	mov	ebx, DWORD PTR _sw$131249[esp+112]
$LL24@Draw@2:

; 1104 : 							while(wt+xo >= sw[1])
; 1105 : 								sw += 2; color = sw[-2];

	add	ebx, 8
	cmp	edi, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR tv2369[esp+112], ecx
	jge	SHORT $LL24@Draw@2
	mov	ecx, DWORD PTR [ebx-8]
	mov	DWORD PTR _sw$131249[esp+112], ebx
$LN25@Draw@2:

; 1106 : 						}
; 1107 : 						pixmix2_sse2(&dst[wt], color, s[wt*2], am[wt]);

	mov	ebx, DWORD PTR _s$[esp+112]
	movzx	edx, BYTE PTR [ebx+edx*2]
	mov	ebx, DWORD PTR tv4428[esp+112]
	movzx	edi, BYTE PTR [ebx+edi]
	imul	edx, edi
	mov	edi, ecx
	shr	edi, 24					; 00000018H
	imul	edx, edi
	mov	edi, DWORD PTR _wt$131252[esp+112]
	mov	edi, DWORD PTR [eax+edi*4]
	movd	xmm0, edi
	shr	edx, 12					; 0000000cH
	and	edx, 255				; 000000ffH
	mov	edi, ecx
	and	edi, 16777215				; 00ffffffH
	movd	xmm2, edi
	lea	edi, DWORD PTR [edx+1]
	shl	edi, 16					; 00000010H
	punpcklbw xmm0, xmm1
	mov	ebx, 256				; 00000100H
	sub	ebx, edx
	mov	edx, DWORD PTR _wt$131252[esp+112]
	or	edi, ebx
	punpcklbw xmm2, xmm1
	punpcklwd xmm0, xmm2
	movd	xmm2, edi
	pshufd	xmm2, xmm2, 0
	pmaddwd	xmm0, xmm2
	psrld	xmm0, 8
	packssdw xmm0, xmm0
	packuswb xmm0, xmm0
	movd	edi, xmm0
	mov	DWORD PTR [eax+edx*4], edi
	mov	edi, DWORD PTR tv4355[esp+112]
	inc	edx
	inc	edi
	cmp	edx, esi
	mov	DWORD PTR _wt$131252[esp+112], edx
	mov	DWORD PTR tv4355[esp+112], edi
	jl	$LN28@Draw@2

; 1108 : 					}

	jmp	$LN246@Draw@2
$LN29@Draw@2:

; 1109 : 					else
; 1110 : 					for(int wt=0; wt<w; ++wt)

	xor	ebx, ebx
	mov	DWORD PTR _wt$131261[esp+112], ebx
	test	esi, esi
	jle	$LN4@Draw@2
	mov	edi, DWORD PTR _xo$[esp+112]
	mov	esi, DWORD PTR _am$[esp+112]
	mov	edx, DWORD PTR tv1870[esp+112]
	sub	esi, edi
	mov	DWORD PTR tv2369[esp+112], edx
	mov	DWORD PTR tv4469[esp+112], edi
	mov	DWORD PTR tv4428[esp+112], esi
	jmp	SHORT $LN21@Draw@2
	npad	6
$LL234@Draw@2:
	mov	esi, DWORD PTR tv4428[esp+112]
$LN21@Draw@2:

; 1111 : 					{
; 1112 : 						if(wt+xo >= sw[1]) {

	mov	edx, DWORD PTR tv2369[esp+112]
	cmp	edi, DWORD PTR [edx]
	jl	SHORT $LN18@Draw@2
	mov	edx, DWORD PTR _sw$131249[esp+112]
$LL17@Draw@2:

; 1113 : 							while(wt+xo >= sw[1])
; 1114 : 								sw += 2; color = sw[-2];

	add	edx, 8
	cmp	edi, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR tv2369[esp+112], ecx
	jge	SHORT $LL17@Draw@2
	mov	ecx, DWORD PTR [edx-8]
	mov	DWORD PTR _sw$131249[esp+112], edx
$LN18@Draw@2:

; 1115 : 						}
; 1116 : 						pixmix2(&dst[wt], color, s[wt*2], am[wt]);

	movzx	esi, BYTE PTR [edi+esi]
	mov	edx, DWORD PTR _s$[esp+112]
	movzx	edx, BYTE PTR [edx+ebx*2]
	mov	ebx, DWORD PTR [eax+ebx*4]
	imul	edx, esi
	mov	esi, ecx
	shr	esi, 24					; 00000018H
	imul	edx, esi
	mov	DWORD PTR tv4580[esp+112], ebx
	mov	edi, ebx
	shr	edx, 12					; 0000000cH
	and	edx, 255				; 000000ffH
	and	edi, -65281				; ffff00ffH
	mov	esi, 256				; 00000100H
	sub	esi, edx
	imul	edi, esi
	inc	edx
	mov	ebx, ecx
	and	ebx, -65281				; ffff00ffH
	imul	ebx, edx
	add	edi, ebx
	mov	ebx, DWORD PTR tv4580[esp+112]
	and	ebx, 65280				; 0000ff00H
	imul	ebx, esi
	mov	DWORD PTR _ia$241225[esp+112], esi
	mov	esi, ecx
	and	esi, 65280				; 0000ff00H
	imul	esi, edx
	add	ebx, esi
	mov	esi, DWORD PTR tv4580[esp+112]
	xor	edi, ebx
	mov	ebx, ecx
	and	ebx, 16711935				; 00ff00ffH
	imul	ebx, edx
	mov	edx, DWORD PTR tv4580[esp+112]
	and	esi, 16711935				; 00ff00ffH
	imul	esi, DWORD PTR _ia$241225[esp+112]
	shr	edx, 8
	and	edx, 16711680				; 00ff0000H
	imul	edx, DWORD PTR _ia$241225[esp+112]
	and	edi, 16711680				; 00ff0000H
	add	esi, ebx
	mov	ebx, DWORD PTR _wt$131261[esp+112]
	xor	edi, esi
	mov	esi, DWORD PTR _w$[esp+112]
	shr	edi, 8
	and	edx, -16777216				; ff000000H
	or	edi, edx
	mov	DWORD PTR [eax+ebx*4], edi
	mov	edi, DWORD PTR tv4469[esp+112]
	inc	ebx
	inc	edi
	cmp	ebx, esi
	mov	DWORD PTR _wt$131261[esp+112], ebx
	mov	DWORD PTR tv4469[esp+112], edi
	jl	$LL234@Draw@2

; 1117 : 					}
; 1118 : 				}
; 1119 : 				else

	jmp	$LN246@Draw@2
$LN30@Draw@2:

; 1120 : 				{
; 1121 : 					if(fSSE2) 

	test	bl, bl
	je	$LN14@Draw@2

; 1122 : 					for(int wt=0; wt<w; ++wt)

	mov	DWORD PTR _wt$131271[esp+112], 0
	test	esi, esi
	jle	$LN4@Draw@2
	mov	edx, DWORD PTR tv1870[esp+112]
	mov	ebx, DWORD PTR _xo$[esp+112]
	mov	DWORD PTR tv2369[esp+112], edx
	mov	edx, DWORD PTR _am$[esp+112]
	sub	edx, ebx
	pxor	xmm1, xmm1
	mov	DWORD PTR tv4601[esp+112], ebx
	mov	DWORD PTR tv4428[esp+112], edx
	npad	6
$LL13@Draw@2:

; 1123 : 					{
; 1124 : 						if(wt+xo >= sw[1]) {

	mov	edx, DWORD PTR tv2369[esp+112]
	cmp	ebx, DWORD PTR [edx]
	jl	SHORT $LN10@Draw@2
	mov	ecx, DWORD PTR _sw$131249[esp+112]
	npad	4
$LL9@Draw@2:

; 1125 : 							while(wt+xo >= sw[1])
; 1126 : 								sw += 2; color = sw[-2];

	add	ecx, 8
	cmp	ebx, DWORD PTR [ecx+4]
	lea	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv2369[esp+112], edx
	jge	SHORT $LL9@Draw@2
	mov	DWORD PTR _sw$131249[esp+112], ecx
	mov	ecx, DWORD PTR [ecx-8]
$LN10@Draw@2:

; 1127 : 						} 
; 1128 : 						pixmix2_sse2(&dst[wt], color, safe_subtract(src[wt*2+1], src[wt*2]), am[wt]);

	mov	ebx, DWORD PTR _wt$131271[esp+112]
	movzx	edx, BYTE PTR [edi+ebx*2+1]
	movd	mm0, edx
	movzx	edx, BYTE PTR [edi+ebx*2]
	movd	mm1, edx
	psubusw	mm0, mm1
	movd	DWORD PTR _r$241237[esp+112], mm0
	emms
	mov	edi, DWORD PTR tv4601[esp+112]
	mov	edx, DWORD PTR tv4428[esp+112]
	movzx	edx, BYTE PTR [edi+edx]
	mov	edi, ecx
	shr	edi, 24					; 00000018H
	imul	edx, edi
	imul	edx, DWORD PTR _r$241237[esp+112]
	mov	edi, DWORD PTR [eax+ebx*4]
	movd	xmm0, edi
	shr	edx, 12					; 0000000cH
	and	edx, 255				; 000000ffH
	mov	edi, ecx
	and	edi, 16777215				; 00ffffffH
	movd	xmm2, edi
	lea	edi, DWORD PTR [edx+1]
	shl	edi, 16					; 00000010H
	punpcklbw xmm0, xmm1
	mov	ebx, 256				; 00000100H
	sub	ebx, edx
	mov	edx, DWORD PTR _wt$131271[esp+112]
	or	edi, ebx
	mov	ebx, DWORD PTR tv4601[esp+112]
	punpcklbw xmm2, xmm1
	punpcklwd xmm0, xmm2
	movd	xmm2, edi
	pshufd	xmm2, xmm2, 0
	pmaddwd	xmm0, xmm2
	psrld	xmm0, 8
	packssdw xmm0, xmm0
	packuswb xmm0, xmm0
	movd	edi, xmm0
	mov	DWORD PTR [eax+edx*4], edi

; 1129 : 					}

	mov	edi, DWORD PTR _src$[esp+112]
	inc	edx
	inc	ebx
	cmp	edx, esi
	mov	DWORD PTR _wt$131271[esp+112], edx
	mov	DWORD PTR tv4601[esp+112], ebx
	jl	$LL13@Draw@2
	jmp	$LN4@Draw@2
$LN14@Draw@2:

; 1130 : 					else
; 1131 : 					for(int wt=0; wt<w; ++wt)

	xor	ebx, ebx
	mov	DWORD PTR _wt$131280[esp+112], ebx
	test	esi, esi
	jle	$LN4@Draw@2
	mov	edx, DWORD PTR tv1870[esp+112]
	mov	esi, DWORD PTR _xo$[esp+112]
	mov	DWORD PTR tv2369[esp+112], edx
	mov	edx, DWORD PTR _am$[esp+112]
	sub	edx, esi
	mov	DWORD PTR tv4428[esp+112], edx
	mov	DWORD PTR tv4757[esp+112], esi
	mov	edx, esi
	jmp	SHORT $LN6@Draw@2
$LL235@Draw@2:
	mov	edi, DWORD PTR _src$[esp+112]
$LN6@Draw@2:

; 1132 : 					{
; 1133 : 						if(wt+xo >= sw[1]) {

	mov	esi, DWORD PTR tv2369[esp+112]
	cmp	edx, DWORD PTR [esi]
	jl	SHORT $LN3@Draw@2
	mov	ecx, DWORD PTR _sw$131249[esp+112]
$LL2@Draw@2:

; 1134 : 							while(wt+xo >= sw[1])
; 1135 : 								sw += 2; color = sw[-2];

	add	ecx, 8
	cmp	edx, DWORD PTR [ecx+4]
	lea	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR tv2369[esp+112], esi
	jge	SHORT $LL2@Draw@2
	mov	DWORD PTR _sw$131249[esp+112], ecx
	mov	ecx, DWORD PTR [ecx-8]
$LN3@Draw@2:

; 1136 : 						} 
; 1137 : 						pixmix2(&dst[wt], color, safe_subtract(src[wt*2+1], src[wt*2]), am[wt]);

	movzx	esi, BYTE PTR [edi+ebx*2+1]
	movd	mm0, esi
	movzx	esi, BYTE PTR [edi+ebx*2]
	movd	mm1, esi
	psubusw	mm0, mm1
	movd	esi, mm0
	emms
	mov	edi, DWORD PTR tv4428[esp+112]
	movzx	edx, BYTE PTR [edx+edi]
	mov	ebx, DWORD PTR [eax+ebx*4]
	mov	edi, ecx
	shr	edi, 24					; 00000018H
	imul	edx, edi
	imul	edx, esi
	shr	edx, 12					; 0000000cH
	and	edx, 255				; 000000ffH
	mov	esi, 256				; 00000100H
	sub	esi, edx
	inc	edx
	mov	DWORD PTR _ia$241280[esp+112], esi
	mov	esi, ebx
	and	esi, -65281				; ffff00ffH
	imul	esi, DWORD PTR _ia$241280[esp+112]
	mov	edi, ecx
	and	edi, -65281				; ffff00ffH
	imul	edi, edx
	add	edi, esi
	mov	esi, ecx
	and	esi, 65280				; 0000ff00H
	imul	esi, edx
	mov	DWORD PTR tv4909[esp+112], ebx
	and	ebx, 65280				; 0000ff00H
	mov	DWORD PTR tv5010[esp+112], esi
	mov	esi, DWORD PTR _ia$241280[esp+112]
	imul	ebx, esi
	mov	DWORD PTR _a$241279[esp+112], edx
	mov	edx, DWORD PTR tv5010[esp+112]
	add	edx, ebx
	mov	ebx, DWORD PTR tv4909[esp+112]
	xor	edi, edx
	and	ebx, 16711935				; 00ff00ffH
	mov	edx, ecx
	imul	ebx, esi
	and	edx, 16711935				; 00ff00ffH
	imul	edx, DWORD PTR _a$241279[esp+112]
	add	edx, ebx
	mov	ebx, DWORD PTR _wt$131280[esp+112]
	and	edi, 16711680				; 00ff0000H
	xor	edi, edx
	mov	edx, DWORD PTR tv4909[esp+112]
	shr	edx, 8
	and	edx, 16711680				; 00ff0000H
	imul	edx, esi
	mov	esi, DWORD PTR _w$[esp+112]
	and	edx, -16777216				; ff000000H
	shr	edi, 8
	or	edi, edx
	mov	edx, DWORD PTR tv4757[esp+112]
	mov	DWORD PTR [eax+ebx*4], edi
	inc	ebx
	inc	edx
	cmp	ebx, esi
	mov	DWORD PTR _wt$131280[esp+112], ebx
	mov	DWORD PTR tv4757[esp+112], edx
	jl	$LL235@Draw@2
$LN246@Draw@2:

; 1130 : 					else
; 1131 : 					for(int wt=0; wt<w; ++wt)

	mov	edi, DWORD PTR _src$[esp+112]
$LN4@Draw@2:

; 1138 : 					}
; 1139 : 				}
; 1140 : 			}
; 1141 : 		}
; 1142 : 
; 1143 : 		// Step to next scanline
; 1144 : 		src += 2*mOverlayWidth;

	mov	edx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [edx+116]
	add	edx, edx

; 1145 : 		s += 2*mOverlayWidth;

	add	DWORD PTR _s$[esp+112], edx
	add	edi, edx

; 1146 : 		am += spd.w;

	mov	edx, DWORD PTR _spd$[ebp]
	mov	ebx, DWORD PTR [edx+4]
	add	DWORD PTR _am$[esp+112], ebx

; 1147 : 		dst = (unsigned long *)((char *)dst + spd.pitch);

	add	eax, DWORD PTR [edx+16]
	cmp	DWORD PTR _h$[esp+112], 0
	mov	DWORD PTR _src$[esp+112], edi
	jne	$LL244@Draw@2

; 1148 : 	}
; 1149 : 
; 1150 : 	// Remember to EMMS!
; 1151 : 	// Rendering fails in funny ways if we don't do this.
; 1152 : 	_mm_empty();

	emms
$LN105@Draw@2:

; 953  : 
; 954  : 	// Check if there's actually anything to render
; 955  : 	if(w <= 0 || h <= 0) return(bbox);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN113@Draw@2:

; 1153 : 
; 1154 : 	return bbox;
; 1155 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
?Draw@Rasterizer@@QAE?AVCRect@@AAUSubPicDesc@@AAV2@PAEHHPBJ_N4@Z ENDP ; Rasterizer::Draw
_TEXT	ENDS
PUBLIC	?PartialBeginPath@Rasterizer@@QAE_NPAUHDC__@@_N@Z ; Rasterizer::PartialBeginPath
; Function compile flags: /Ogtpy
;	COMDAT ?PartialBeginPath@Rasterizer@@QAE_NPAUHDC__@@_N@Z
_TEXT	SEGMENT
?PartialBeginPath@Rasterizer@@QAE_NPAUHDC__@@_N@Z PROC	; Rasterizer::PartialBeginPath, COMDAT
; _this$ = esi

; 289  : 	if(bClearPath)
; 290  : 		_TrashPath();

	mov	eax, DWORD PTR [esi+24]
	push	edi
	mov	edi, DWORD PTR _g_hDC
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	ecx, DWORD PTR [esi+28]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	xor	eax, eax
	add	esp, 8

; 291  : 
; 292  : 	return !!::BeginPath(hdc);

	push	edi
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR [esi+32], eax
	call	DWORD PTR __imp__BeginPath@4
	neg	eax
	sbb	eax, eax
	neg	eax
	pop	edi

; 293  : }

	ret	0
?PartialBeginPath@Rasterizer@@QAE_NPAUHDC__@@_N@Z ENDP	; Rasterizer::PartialBeginPath
_TEXT	ENDS
PUBLIC	?BeginPath@Rasterizer@@QAE_NPAUHDC__@@@Z	; Rasterizer::BeginPath
; Function compile flags: /Ogtpy
;	COMDAT ?BeginPath@Rasterizer@@QAE_NPAUHDC__@@@Z
_TEXT	SEGMENT
?BeginPath@Rasterizer@@QAE_NPAUHDC__@@@Z PROC		; Rasterizer::BeginPath, COMDAT
; _this$ = esi

; 259  : 	_TrashPath();

	mov	eax, DWORD PTR [esi+24]
	push	edi
	mov	edi, DWORD PTR _g_hDC
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	ecx, DWORD PTR [esi+28]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	xor	eax, eax
	add	esp, 8

; 260  : 
; 261  : 	return !!::BeginPath(hdc);

	push	edi
	mov	DWORD PTR [esi+24], eax
	mov	DWORD PTR [esi+28], eax
	mov	DWORD PTR [esi+32], eax
	call	DWORD PTR __imp__BeginPath@4
	neg	eax
	sbb	eax, eax
	neg	eax
	pop	edi

; 262  : }

	ret	0
?BeginPath@Rasterizer@@QAE_NPAUHDC__@@@Z ENDP		; Rasterizer::BeginPath
_TEXT	ENDS
PUBLIC	?_EvaluateLine@Rasterizer@@AAEXHHHH@Z		; Rasterizer::_EvaluateLine
EXTRN	__allshr:PROC
; Function compile flags: /Ogtpy
;	COMDAT ?_EvaluateLine@Rasterizer@@AAEXHHHH@Z
_TEXT	SEGMENT
_y$128714 = -24						; size = 4
_invslope$128700 = -24					; size = 8
_dy$128696 = -24					; size = 4
_invslope$128717 = -16					; size = 8
_dy$128713 = -16					; size = 4
_y$128697 = -16						; size = 4
_xacc$128711 = -8					; size = 8
_xacc$128694 = -8					; size = 8
_x0$ = 8						; size = 4
_y0$ = 12						; size = 4
_x1$ = 16						; size = 4
_y1$ = 20						; size = 4
?_EvaluateLine@Rasterizer@@AAEXHHHH@Z PROC		; Rasterizer::_EvaluateLine, COMDAT
; _this$ = ecx

; 176  : {

	sub	esp, 28					; 0000001cH
	push	ebx

; 177  : 	if(lastp.x != x0 || lastp.y != y0)

	mov	ebx, DWORD PTR _y0$[esp+28]
	push	ebp
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+16]
	push	edi
	mov	edi, DWORD PTR _x0$[esp+40]
	cmp	eax, edi
	jne	SHORT $LN15@EvaluateLi@2
	cmp	DWORD PTR [esi+20], ebx
	je	SHORT $LN16@EvaluateLi@2
$LN15@EvaluateLi@2:

; 178  : 	{
; 179  : 		_EvaluateLine(lastp.x, lastp.y, x0, y0);

	mov	ecx, DWORD PTR [esi+20]
	push	ebx
	push	edi
	push	ecx
	push	eax
	mov	ecx, esi
	call	?_EvaluateLine@Rasterizer@@AAEXHHHH@Z	; Rasterizer::_EvaluateLine
$LN16@EvaluateLi@2:

; 180  : 	}
; 181  : 
; 182  : 	if(!fFirstSet) {firstp.x = x0; firstp.y = y0; fFirstSet = true;}

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN14@EvaluateLi@2
	mov	DWORD PTR [esi+8], edi
	mov	DWORD PTR [esi+12], ebx
	mov	BYTE PTR [esi+4], 1
$LN14@EvaluateLi@2:

; 183  : 	lastp.x = x1; lastp.y = y1;

	mov	ecx, DWORD PTR _y1$[esp+40]

; 184  : 
; 185  : 	if(y1 > y0)	// down

	cmp	ecx, ebx
	mov	eax, DWORD PTR _x1$[esp+40]
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], ecx
	jle	$LN31@EvaluateLi@2

; 186  : 	{
; 187  : 		__int64 xacc = (__int64)x0 << 13;

	mov	eax, edi
	cdq
	mov	ebp, eax

; 188  : 
; 189  : 		// prestep y0 down
; 190  : 
; 191  : 		int dy = y1 - y0;

	mov	eax, ecx
	sub	eax, ebx

; 192  : 		int y = ((y0 + 3)&~7) + 4;

	add	ebx, 3
	and	ebx, -8					; fffffff8H
	add	ebx, 4
	shld	edx, ebp, 13

; 193  : 		int iy = y >> 3;
; 194  : 
; 195  : 		y1 = (y1 - 5) >> 3;

	add	ecx, -5					; fffffffbH
	mov	edi, ebx
	sar	ecx, 3
	sar	edi, 3
	shl	ebp, 13					; 0000000dH

; 196  : 
; 197  : 		if(iy <= y1)

	cmp	edi, ecx
	mov	DWORD PTR _xacc$128694[esp+48], edx
	mov	DWORD PTR _dy$128696[esp+44], eax
	mov	DWORD PTR _y$128697[esp+44], ebx
	mov	DWORD PTR _y1$[esp+40], ecx
	jg	$LN1@EvaluateLi@2

; 198  : 		{
; 199  : 			__int64 invslope = (__int64(x1 - x0) << 16) / dy;

	mov	eax, DWORD PTR _x1$[esp+40]
	sub	eax, DWORD PTR _x0$[esp+40]
	cdq
	mov	ecx, eax
	mov	eax, DWORD PTR _dy$128696[esp+44]
	mov	ebx, edx
	cdq
	shld	ebx, ecx, 16
	push	edx
	push	eax
	shl	ecx, 16					; 00000010H
	push	ebx
	push	ecx
	call	__alldiv

; 200  : 
; 201  : 			while(mEdgeNext + y1 + 1 - iy > mEdgeHeapSize)

	mov	ebx, DWORD PTR _y1$[esp+40]
	mov	DWORD PTR _invslope$128700[esp+48], edx
	mov	edx, ebx
	mov	DWORD PTR _invslope$128700[esp+44], eax
	mov	eax, DWORD PTR [esi+104]
	sub	edx, edi
	lea	ecx, DWORD PTR [edx+eax+1]
	cmp	ecx, DWORD PTR [esi+100]
	jbe	SHORT $LN10@EvaluateLi@2
	npad	5
$LL11@EvaluateLi@2:

; 202  : 				_ReallocEdgeBuffer(mEdgeHeapSize*2);

	mov	eax, DWORD PTR [esi+100]
	add	eax, eax
	lea	edx, DWORD PTR [eax*8]
	mov	DWORD PTR [esi+100], eax
	mov	eax, DWORD PTR [esi+96]
	push	edx
	push	eax
	call	_realloc
	mov	DWORD PTR [esi+96], eax
	mov	edx, DWORD PTR [esi+104]
	mov	ecx, ebx
	sub	ecx, edi
	lea	eax, DWORD PTR [ecx+edx+1]
	add	esp, 8
	cmp	eax, DWORD PTR [esi+100]
	ja	SHORT $LL11@EvaluateLi@2
$LN10@EvaluateLi@2:

; 203  : 
; 204  : 			xacc += (invslope * (y - y0)) >> 3;

	mov	eax, DWORD PTR _y$128697[esp+44]
	mov	ecx, DWORD PTR _invslope$128700[esp+48]
	sub	eax, DWORD PTR _y0$[esp+40]
	push	ecx
	mov	ecx, DWORD PTR _invslope$128700[esp+48]
	cdq
	push	ecx
	push	edx
	push	eax
	call	__allmul
	mov	cl, 3
	call	__allshr
	mov	ebx, DWORD PTR _xacc$128694[esp+48]
	add	ebp, eax
	adc	ebx, edx
	npad	8
$LL9@EvaluateLi@2:

; 205  : 
; 206  : 			while(iy <= y1)
; 207  : 			{
; 208  : 				int ix = (int)((xacc + 32768) >> 16);
; 209  : 
; 210  : 				mpEdgeBuffer[mEdgeNext].next = mpScanBuffer[iy];

	mov	edx, DWORD PTR [esi+108]
	mov	edx, DWORD PTR [edx+edi*4]
	mov	ecx, DWORD PTR [esi+96]
	mov	eax, DWORD PTR [esi+104]
	mov	DWORD PTR [ecx+eax*8], edx
	mov	eax, ebp
	add	eax, 32768				; 00008000H
	mov	edx, ebx
	adc	edx, 0
	mov	cl, 16					; 00000010H
	call	__allshr

; 211  : 				mpEdgeBuffer[mEdgeNext].posandflag = ix*2 + 1;

	mov	ecx, DWORD PTR [esi+104]
	mov	edx, DWORD PTR [esi+96]
	lea	eax, DWORD PTR [eax+eax+1]
	mov	DWORD PTR [edx+ecx*8+4], eax

; 212  : 
; 213  : 				mpScanBuffer[iy] = mEdgeNext++;

	mov	ecx, DWORD PTR [esi+104]
	mov	eax, DWORD PTR [esi+108]
	mov	DWORD PTR [eax+edi*4], ecx
	inc	DWORD PTR [esi+104]

; 214  : 
; 215  : 				++iy;

	inc	edi

; 216  : 				xacc += invslope;

	add	ebp, DWORD PTR _invslope$128700[esp+44]
	adc	ebx, DWORD PTR _invslope$128700[esp+48]
	cmp	edi, DWORD PTR _y1$[esp+40]
	jle	SHORT $LL9@EvaluateLi@2

; 252  : 			}
; 253  : 		}
; 254  : 	}
; 255  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	16					; 00000010H
$LN31@EvaluateLi@2:

; 217  : 			}
; 218  : 		}
; 219  : 	}
; 220  : 	else if(y1 < y0) // up

	jge	$LN1@EvaluateLi@2

; 221  : 	{
; 222  : 		__int64 xacc = (__int64)x1 << 13;

	cdq
	mov	ebp, eax

; 223  : 
; 224  : 		// prestep y1 down
; 225  : 
; 226  : 		int dy = y0 - y1;

	mov	eax, ebx
	sub	eax, ecx

; 227  : 		int y = ((y1 + 3)&~7) + 4;

	add	ecx, 3
	and	ecx, -8					; fffffff8H
	add	ecx, 4
	shld	edx, ebp, 13

; 228  : 		int iy = y >> 3;
; 229  : 
; 230  : 		y0 = (y0 - 5) >> 3;

	add	ebx, -5					; fffffffbH
	mov	edi, ecx
	sar	ebx, 3
	sar	edi, 3
	shl	ebp, 13					; 0000000dH

; 231  : 
; 232  : 		if(iy <= y0)

	cmp	edi, ebx
	mov	DWORD PTR _xacc$128711[esp+48], edx
	mov	DWORD PTR _dy$128713[esp+44], eax
	mov	DWORD PTR _y$128714[esp+44], ecx
	mov	DWORD PTR _y0$[esp+40], ebx
	jg	$LN1@EvaluateLi@2

; 233  : 		{
; 234  : 			__int64 invslope = (__int64(x0 - x1) << 16) / dy;

	mov	eax, DWORD PTR _x0$[esp+40]
	sub	eax, DWORD PTR _x1$[esp+40]
	cdq
	mov	ecx, eax
	mov	eax, DWORD PTR _dy$128713[esp+44]
	mov	ebx, edx
	cdq
	shld	ebx, ecx, 16
	push	edx
	push	eax
	shl	ecx, 16					; 00000010H
	push	ebx
	push	ecx
	call	__alldiv

; 235  : 
; 236  : 			while(mEdgeNext + y0 + 1 - iy > mEdgeHeapSize)

	mov	ebx, DWORD PTR _y0$[esp+40]
	mov	DWORD PTR _invslope$128717[esp+48], edx
	mov	edx, ebx
	mov	DWORD PTR _invslope$128717[esp+44], eax
	mov	eax, DWORD PTR [esi+104]
	sub	edx, edi
	lea	ecx, DWORD PTR [edx+eax+1]
	cmp	ecx, DWORD PTR [esi+100]
	jbe	SHORT $LN3@EvaluateLi@2
$LL4@EvaluateLi@2:

; 237  : 				_ReallocEdgeBuffer(mEdgeHeapSize*2);

	mov	eax, DWORD PTR [esi+100]
	add	eax, eax
	lea	edx, DWORD PTR [eax*8]
	mov	DWORD PTR [esi+100], eax
	mov	eax, DWORD PTR [esi+96]
	push	edx
	push	eax
	call	_realloc
	mov	DWORD PTR [esi+96], eax
	mov	edx, DWORD PTR [esi+104]
	mov	ecx, ebx
	sub	ecx, edi
	lea	eax, DWORD PTR [ecx+edx+1]
	add	esp, 8
	cmp	eax, DWORD PTR [esi+100]
	ja	SHORT $LL4@EvaluateLi@2
$LN3@EvaluateLi@2:

; 238  : 
; 239  : 			xacc += (invslope * (y - y1)) >> 3;

	mov	eax, DWORD PTR _y$128714[esp+44]
	mov	ecx, DWORD PTR _invslope$128717[esp+48]
	sub	eax, DWORD PTR _y1$[esp+40]
	push	ecx
	mov	ecx, DWORD PTR _invslope$128717[esp+48]
	cdq
	push	ecx
	push	edx
	push	eax
	call	__allmul
	mov	cl, 3
	call	__allshr
	mov	ebx, DWORD PTR _xacc$128711[esp+48]
	add	ebp, eax
	adc	ebx, edx
	npad	5
$LL2@EvaluateLi@2:

; 240  : 
; 241  : 			while(iy <= y0)
; 242  : 			{
; 243  : 				int ix = (int)((xacc + 32768) >> 16);
; 244  : 
; 245  : 				mpEdgeBuffer[mEdgeNext].next = mpScanBuffer[iy];

	mov	edx, DWORD PTR [esi+108]
	mov	edx, DWORD PTR [edx+edi*4]
	mov	ecx, DWORD PTR [esi+96]
	mov	eax, DWORD PTR [esi+104]
	mov	DWORD PTR [ecx+eax*8], edx
	mov	eax, ebp
	add	eax, 32768				; 00008000H
	mov	edx, ebx
	adc	edx, 0
	mov	cl, 16					; 00000010H
	call	__allshr

; 246  : 				mpEdgeBuffer[mEdgeNext].posandflag = ix*2;

	mov	ecx, DWORD PTR [esi+104]
	mov	edx, DWORD PTR [esi+96]
	add	eax, eax
	mov	DWORD PTR [edx+ecx*8+4], eax

; 247  : 
; 248  : 				mpScanBuffer[iy] = mEdgeNext++;

	mov	ecx, DWORD PTR [esi+104]
	mov	eax, DWORD PTR [esi+108]
	mov	DWORD PTR [eax+edi*4], ecx
	inc	DWORD PTR [esi+104]

; 249  : 
; 250  : 				++iy;

	inc	edi

; 251  : 				xacc += invslope;

	add	ebp, DWORD PTR _invslope$128717[esp+44]
	adc	ebx, DWORD PTR _invslope$128717[esp+48]
	cmp	edi, DWORD PTR _y0$[esp+40]
	jle	SHORT $LL2@EvaluateLi@2
$LN1@EvaluateLi@2:

; 252  : 			}
; 253  : 		}
; 254  : 	}
; 255  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 28					; 0000001cH
	ret	16					; 00000010H
?_EvaluateLine@Rasterizer@@AAEXHHHH@Z ENDP		; Rasterizer::_EvaluateLine
_TEXT	ENDS
PUBLIC	?_EvaluateLine@Rasterizer@@AAEXHH@Z		; Rasterizer::_EvaluateLine
; Function compile flags: /Ogtpy
;	COMDAT ?_EvaluateLine@Rasterizer@@AAEXHH@Z
_TEXT	SEGMENT
?_EvaluateLine@Rasterizer@@AAEXHH@Z PROC		; Rasterizer::_EvaluateLine, COMDAT
; _this$ = ecx
; _pt1idx$ = esi
; _pt2idx$ = edx

; 169  : 	const POINT* pt1 = mpPathPoints + pt1idx;

	mov	eax, DWORD PTR [ecx+28]
	push	edi

; 170  : 	const POINT* pt2 = mpPathPoints + pt2idx;
; 171  : 
; 172  : 	_EvaluateLine(pt1->x, pt1->y, pt2->x, pt2->y);

	mov	edi, DWORD PTR [eax+edx*8+4]
	mov	edx, DWORD PTR [eax+edx*8]
	push	edi
	push	edx
	mov	edx, DWORD PTR [eax+esi*8+4]
	mov	eax, DWORD PTR [eax+esi*8]
	push	edx
	push	eax
	call	?_EvaluateLine@Rasterizer@@AAEXHHHH@Z	; Rasterizer::_EvaluateLine

; 173  : }

	pop	edi
	ret	0
?_EvaluateLine@Rasterizer@@AAEXHH@Z ENDP		; Rasterizer::_EvaluateLine
_TEXT	ENDS
PUBLIC	__real@4020000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@4010000000000000
PUBLIC	__real@4018000000000000
PUBLIC	__real@3fc5555555555555
PUBLIC	__real@4008000000000000
PUBLIC	?_EvaluateBezier@Rasterizer@@AAEXH_N@Z		; Rasterizer::_EvaluateBezier
;	COMDAT __real@4020000000000000
CONST	SEGMENT
__real@4020000000000000 DQ 04020000000000000r	; 8
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@4010000000000000
CONST	SEGMENT
__real@4010000000000000 DQ 04010000000000000r	; 4
CONST	ENDS
;	COMDAT __real@4018000000000000
CONST	SEGMENT
__real@4018000000000000 DQ 04018000000000000r	; 6
CONST	ENDS
;	COMDAT __real@3fc5555555555555
CONST	SEGMENT
__real@3fc5555555555555 DQ 03fc5555555555555r	; 0.166667
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?_EvaluateBezier@Rasterizer@@AAEXH_N@Z
_TEXT	SEGMENT
tv432 = -80						; size = 8
_cy0$ = -80						; size = 8
_cy3$ = -72						; size = 8
_cx0$ = -64						; size = 8
tv427 = -56						; size = 8
_cx2$ = -56						; size = 8
_cx3$ = -48						; size = 8
_h$ = -40						; size = 8
_y2$ = -40						; size = 8
_cy1$ = -32						; size = 8
_cy2$ = -24						; size = 8
_y3$ = -24						; size = 8
_cx1$ = -16						; size = 8
_x3$ = -16						; size = 8
_t$128664 = -8						; size = 8
_x2$ = -8						; size = 8
_fBSpline$ = 8						; size = 1
?_EvaluateBezier@Rasterizer@@AAEXH_N@Z PROC		; Rasterizer::_EvaluateBezier, COMDAT
; _this$ = esi
; _ptbase$ = edx

; 75   : {

	sub	esp, 80					; 00000050H

; 76   : 	const POINT* pt0 = mpPathPoints + ptbase;
; 77   : 	const POINT* pt1 = mpPathPoints + ptbase + 1;
; 78   : 	const POINT* pt2 = mpPathPoints + ptbase + 2;
; 79   : 	const POINT* pt3 = mpPathPoints + ptbase + 3;
; 80   : 
; 81   : 	double x0 = pt0->x;
; 82   : 	double x1 = pt1->x;
; 83   : 	double x2 = pt2->x;
; 84   : 	double x3 = pt3->x;
; 85   : 	double y0 = pt0->y;
; 86   : 	double y1 = pt1->y;
; 87   : 	double y2 = pt2->y;
; 88   : 	double y3 = pt3->y;
; 89   : 
; 90   : 	double cx3, cx2, cx1, cx0, cy3, cy2, cy1, cy0;
; 91   : 
; 92   : 	if(fBSpline)

	cmp	BYTE PTR _fBSpline$[esp+76], 0
	mov	eax, DWORD PTR [esi+28]
	fild	DWORD PTR [eax+edx*8]
	lea	ecx, DWORD PTR [eax+edx*8]
	fild	DWORD PTR [ecx+8]
	push	ebx
	fild	DWORD PTR [eax+edx*8+16]
	push	edi
	lea	edi, DWORD PTR [ecx+8]
	lea	ebx, DWORD PTR [eax+edx*8+16]
	fst	QWORD PTR _x2$[esp+88]
	lea	eax, DWORD PTR [eax+edx*8+24]
	fild	DWORD PTR [eax]
	fst	QWORD PTR _x3$[esp+88]
	fild	DWORD PTR [ecx+4]
	fild	DWORD PTR [edi+4]
	fild	DWORD PTR [ebx+4]
	fstp	QWORD PTR _y2$[esp+88]
	fild	DWORD PTR [eax+4]
	fstp	QWORD PTR _y3$[esp+88]
	je	$LN16@EvaluateBe@2

; 93   : 	{
; 94   : 		// 1   [-1 +3 -3 +1]
; 95   : 		// - * [+3 -6 +3  0]
; 96   : 		// 6   [-3  0 +3  0]
; 97   : 		//	   [+1 +4 +1  0]
; 98   : 
; 99   : 		double _1div6 = 1.0/6.0;
; 100  : 
; 101  : 		cx3 = _1div6*(-  x0+3*x1-3*x2+x3);

	fld	QWORD PTR __real@4008000000000000
	fmul	ST(4), ST(0)
	fxch	ST(4)
	fst	QWORD PTR tv427[esp+88]
	fld	ST(5)
	fmul	ST(0), ST(5)
	fsub	ST(0), ST(7)
	fsubrp	ST(1), ST(0)
	faddp	ST(3), ST(0)
	fld	QWORD PTR __real@3fc5555555555555
	fmul	ST(3), ST(0)
	fxch	ST(3)
	fstp	QWORD PTR _cx3$[esp+88]

; 102  : 		cx2 = _1div6*( 3*x0-6*x1+3*x2);

	fld	ST(5)
	fmul	ST(0), ST(4)
	fstp	QWORD PTR tv432[esp+88]
	fld	ST(4)
	fmul	QWORD PTR __real@4018000000000000
	fsubr	QWORD PTR tv432[esp+88]
	fld	QWORD PTR tv427[esp+88]
	fadd	ST(1), ST(0)
	fxch	ST(1)
	fmul	ST(0), ST(4)
	fstp	QWORD PTR _cx2$[esp+88]

; 103  : 		cx1 = _1div6*(-3*x0	   +3*x2);

	fsub	QWORD PTR tv432[esp+88]
	fmul	ST(0), ST(3)
	fstp	QWORD PTR _cx1$[esp+88]

; 104  : 		cx0 = _1div6*(   x0+4*x1+1*x2);

	fxch	ST(4)
	fmul	QWORD PTR __real@4010000000000000
	faddp	ST(5), ST(0)
	fxch	ST(4)
	fadd	QWORD PTR _x2$[esp+88]
	fmul	ST(0), ST(1)
	fstp	QWORD PTR _cx0$[esp+88]

; 105  : 
; 106  : 		cy3 = _1div6*(-  y0+3*y1-3*y2+y3);

	fld	QWORD PTR _y2$[esp+88]
	fmul	ST(0), ST(2)
	fld	ST(3)
	fmul	ST(0), ST(3)
	fsub	ST(0), ST(5)
	fsub	ST(0), ST(1)
	fadd	QWORD PTR _y3$[esp+88]
	fmul	ST(0), ST(2)
	fstp	QWORD PTR _cy3$[esp+88]

; 107  : 		cy2 = _1div6*( 3*y0-6*y1+3*y2);

	fld	ST(4)
	fmulp	ST(3), ST(0)
	fld	ST(3)
	fld	QWORD PTR __real@4018000000000000
	fmul	ST(1), ST(0)
	fld	ST(4)
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fadd	ST(0), ST(2)
	fmul	ST(0), ST(3)
	fst	QWORD PTR _cy2$[esp+88]

; 108  : 		cy1 = _1div6*(-3*y0     +3*y2);

	fxch	ST(2)
	fsubrp	ST(4), ST(0)
	fxch	ST(3)
	fmul	ST(0), ST(2)
	fstp	QWORD PTR _cy1$[esp+88]

; 109  : 		cy0 = _1div6*(   y0+4*y1+1*y2);

	fxch	ST(3)
	fmul	QWORD PTR __real@4010000000000000
	faddp	ST(4), ST(0)
	fxch	ST(3)
	fadd	QWORD PTR _y2$[esp+88]
	fmulp	ST(3), ST(0)
	fxch	ST(2)
	fstp	QWORD PTR _cy0$[esp+88]

; 110  : 	}
; 111  : 	else // bezier

	jmp	$LN6@EvaluateBe@2
$LN16@EvaluateBe@2:

; 76   : 	const POINT* pt0 = mpPathPoints + ptbase;
; 77   : 	const POINT* pt1 = mpPathPoints + ptbase + 1;
; 78   : 	const POINT* pt2 = mpPathPoints + ptbase + 2;
; 79   : 	const POINT* pt3 = mpPathPoints + ptbase + 3;
; 80   : 
; 81   : 	double x0 = pt0->x;
; 82   : 	double x1 = pt1->x;
; 83   : 	double x2 = pt2->x;
; 84   : 	double x3 = pt3->x;
; 85   : 	double y0 = pt0->y;
; 86   : 	double y1 = pt1->y;
; 87   : 	double y2 = pt2->y;
; 88   : 	double y3 = pt3->y;
; 89   : 
; 90   : 	double cx3, cx2, cx1, cx0, cy3, cy2, cy1, cy0;
; 91   : 
; 92   : 	if(fBSpline)

	fstp	ST(2)

; 112  : 	{
; 113  : 		// [-1 +3 -3 +1]
; 114  : 		// [+3 -6 +3  0]
; 115  : 		// [-3 +3  0  0]
; 116  : 		// [+1  0  0  0]
; 117  : 
; 118  : 		cx3 = -  x0+3*x1-3*x2+x3;

	fld	ST(3)
	fld	QWORD PTR __real@4008000000000000
	fmul	ST(1), ST(0)
	fmul	ST(4), ST(0)
	fxch	ST(4)
	fst	QWORD PTR tv427[esp+88]
	fld	ST(1)
	fsub	ST(0), ST(7)
	fsubrp	ST(1), ST(0)
	fadd	QWORD PTR _x3$[esp+88]
	fstp	QWORD PTR _cx3$[esp+88]

; 119  : 		cx2 =  3*x0-6*x1+3*x2;

	fld	ST(5)
	fmul	ST(0), ST(4)
	fst	QWORD PTR tv432[esp+88]
	fld	QWORD PTR __real@4018000000000000
	fmul	ST(6), ST(0)
	fxch	ST(1)
	fsubrp	ST(6), ST(0)
	fxch	ST(5)
	fadd	QWORD PTR tv427[esp+88]
	fstp	QWORD PTR _cx2$[esp+88]

; 120  : 		cx1 = -3*x0+3*x1;

	fsub	QWORD PTR tv432[esp+88]
	fstp	QWORD PTR _cx1$[esp+88]

; 121  : 		cx0 =    x0;

	fxch	ST(4)
	fstp	QWORD PTR _cx0$[esp+88]

; 122  : 
; 123  : 		cy3 = -  y0+3*y1-3*y2+y3;

	fld	ST(0)
	fmul	ST(0), ST(2)
	fld	QWORD PTR _y2$[esp+88]
	fmul	ST(0), ST(3)
	fld	ST(1)
	fsub	ST(0), ST(6)
	fsub	ST(0), ST(1)
	fadd	QWORD PTR _y3$[esp+88]
	fstp	QWORD PTR _cy3$[esp+88]

; 124  : 		cy2 =  3*y0-6*y1+3*y2;

	fld	ST(5)
	fmulp	ST(4), ST(0)
	fxch	ST(2)
	fmul	ST(0), ST(4)
	fsubr	ST(0), ST(3)
	faddp	ST(2), ST(0)
	fxch	ST(1)
	fst	QWORD PTR _cy2$[esp+88]

; 125  : 		cy1 = -3*y0+3*y1;

	fxch	ST(1)
	fsubrp	ST(2), ST(0)
	fxch	ST(1)
	fstp	QWORD PTR _cy1$[esp+88]

; 126  : 		cy0 =    y0;

	fxch	ST(2)
	fstp	QWORD PTR _cy0$[esp+88]
	fxch	ST(1)
$LN6@EvaluateBe@2:

; 127  : 	}
; 128  : 
; 129  : 	//
; 130  : 	// This equation is from Graphics Gems I.
; 131  : 	//
; 132  : 	// The idea is that since we're approximating a cubic curve with lines,
; 133  : 	// any error we incur is due to the curvature of the line, which we can
; 134  : 	// estimate by calculating the maximum acceleration of the curve.  For
; 135  : 	// a cubic, the acceleration (second derivative) is a line, meaning that
; 136  : 	// the absolute maximum acceleration must occur at either the beginning
; 137  : 	// (|c2|) or the end (|c2+c3|).  Our bounds here are a little more
; 138  : 	// conservative than that, but that's okay.
; 139  : 	//
; 140  : 	// If the acceleration of the parametric formula is zero (c2 = c3 = 0),
; 141  : 	// that component of the curve is linear and does not incur any error.
; 142  : 	// If a=0 for both X and Y, the curve is a line segment and we can
; 143  : 	// use a step size of 1.
; 144  : 
; 145  : 	double maxaccel1 = fabs(2*cy2) + fabs(6*cy3);

	fld	QWORD PTR __real@4000000000000000
	fmul	ST(1), ST(0)
	fxch	ST(1)
	fabs
	fld	QWORD PTR _cy3$[esp+88]
	fmul	ST(0), ST(3)
	fabs
	faddp	ST(1), ST(0)

; 146  : 	double maxaccel2 = fabs(2*cx2) + fabs(6*cx3);

	fld	QWORD PTR _cx2$[esp+88]
	fmulp	ST(2), ST(0)
	fxch	ST(1)
	fabs
	fld	QWORD PTR _cx3$[esp+88]
	fmulp	ST(3), ST(0)
	fxch	ST(2)
	fabs
	faddp	ST(2), ST(0)

; 147  : 
; 148  : 	double maxaccel = maxaccel1 > maxaccel2 ? maxaccel1 : maxaccel2;

	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN20@EvaluateBe@2
	fstp	ST(1)
	jmp	SHORT $LN11@EvaluateBe@2
$LN20@EvaluateBe@2:
	fstp	ST(0)
$LN11@EvaluateBe@2:

; 149  : 	double h = 1.0;

	fld1
	fstp	QWORD PTR _h$[esp+88]

; 150  : 
; 151  : 	if(maxaccel > 8.0) h = sqrt(8.0 / maxaccel);

	fld	QWORD PTR __real@4020000000000000
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN24@EvaluateBe@2
	fdivrp	ST(1), ST(0)
	call	__CIsqrt
	fstp	QWORD PTR _h$[esp+88]
	jmp	SHORT $LN5@EvaluateBe@2
$LN24@EvaluateBe@2:
	fstp	ST(1)
	fstp	ST(0)
$LN5@EvaluateBe@2:

; 152  : 
; 153  : 	if(!fFirstSet) {firstp.x = (LONG)cx0; firstp.y = (LONG)cy0; lastp = firstp; fFirstSet = true;}

	cmp	BYTE PTR [esi+4], 0
	jne	SHORT $LN4@EvaluateBe@2
	fld	QWORD PTR _cx0$[esp+88]
	call	__ftol2_sse
	fld	QWORD PTR _cy0$[esp+88]
	mov	DWORD PTR [esi+8], eax
	call	__ftol2_sse
	mov	DWORD PTR [esi+12], eax
	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi+16], eax
	mov	DWORD PTR [esi+20], ecx
	mov	BYTE PTR [esi+4], 1
$LN4@EvaluateBe@2:

; 154  : 
; 155  : 	for(double t = 0; t < 1.0; t += h)

	fldz
	fst	QWORD PTR _t$128664[esp+88]
$LN3@EvaluateBe@2:

; 156  : 	{
; 157  : 		double x = cx0 + t*(cx1 + t*(cx2 + t*cx3));
; 158  : 		double y = cy0 + t*(cy1 + t*(cy2 + t*cy3));

	fld	QWORD PTR _cy3$[esp+88]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _cy2$[esp+88]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _cy1$[esp+88]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _cy0$[esp+88]

; 159  : 		_EvaluateLine(lastp.x, lastp.y, (int)x, (int)y);

	call	__ftol2_sse
	fld	QWORD PTR _cx3$[esp+88]
	fmul	ST(0), ST(1)
	push	eax
	fadd	QWORD PTR _cx2$[esp+92]
	fmul	ST(0), ST(1)
	fadd	QWORD PTR _cx1$[esp+92]
	fmulp	ST(1), ST(0)
	fadd	QWORD PTR _cx0$[esp+92]
	call	__ftol2_sse
	mov	edx, DWORD PTR [esi+20]
	push	eax
	mov	eax, DWORD PTR [esi+16]
	push	edx
	push	eax
	mov	ecx, esi
	call	?_EvaluateLine@Rasterizer@@AAEXHHHH@Z	; Rasterizer::_EvaluateLine
	fld	QWORD PTR _t$128664[esp+88]
	fadd	QWORD PTR _h$[esp+88]
	fst	QWORD PTR _t$128664[esp+88]
	fld1
	fcomp	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	je	SHORT $LN3@EvaluateBe@2
	fstp	ST(0)

; 160  : 	}
; 161  : 
; 162  : 	double x = cx0 + cx1 + cx2 + cx3;
; 163  : 	double y = cy0 + cy1 + cy2 + cy3;

	fld	QWORD PTR _cy0$[esp+88]
	fadd	QWORD PTR _cy1$[esp+88]
	fadd	QWORD PTR _cy2$[esp+88]
	fadd	QWORD PTR _cy3$[esp+88]

; 164  : 	_EvaluateLine(lastp.x, lastp.y, (int)x, (int)y);

	call	__ftol2_sse
	fld	QWORD PTR _cx0$[esp+88]
	fadd	QWORD PTR _cx1$[esp+88]
	push	eax
	fadd	QWORD PTR _cx2$[esp+92]
	fadd	QWORD PTR _cx3$[esp+92]
	call	__ftol2_sse
	mov	ecx, DWORD PTR [esi+20]
	mov	edx, DWORD PTR [esi+16]
	push	eax
	push	ecx
	push	edx
	mov	ecx, esi
	call	?_EvaluateLine@Rasterizer@@AAEXHHHH@Z	; Rasterizer::_EvaluateLine

; 165  : }

	pop	edi
	pop	ebx
	add	esp, 80					; 00000050H
	ret	4
?_EvaluateBezier@Rasterizer@@AAEXH_N@Z ENDP		; Rasterizer::_EvaluateBezier
_TEXT	ENDS
PUBLIC	??1Rasterizer@@UAE@XZ				; Rasterizer::~Rasterizer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1Rasterizer@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1Rasterizer@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1Rasterizer@@UAE@XZ$1
__ehfuncinfo$??1Rasterizer@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1Rasterizer@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1Rasterizer@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1Rasterizer@@UAE@XZ PROC				; Rasterizer::~Rasterizer, COMDAT
; _this$ = ecx

; 48   : {

	push	-1
	push	__ehhandler$??1Rasterizer@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi], OFFSET ??_7Rasterizer@@6B@
	mov	DWORD PTR __$EHRec$[esp+32], 1

; 49   : 	_TrashPath();

	mov	eax, DWORD PTR [esi+24]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	eax, DWORD PTR [esi+28]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]

; 50   : 	_TrashOverlay();

	mov	eax, DWORD PTR [esi+112]
	xor	ebx, ebx
	push	eax
	mov	DWORD PTR [esi+24], ebx
	mov	DWORD PTR [esi+28], ebx
	mov	DWORD PTR [esi+32], ebx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 12					; 0000000cH

; 51   : }

	lea	eax, DWORD PTR [esi+68]
	push	eax
	mov	DWORD PTR [esi+112], ebx
	mov	BYTE PTR __$EHRec$[esp+36], bl
	call	??1?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::~vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
	add	esi, 44					; 0000002cH
	push	esi
	mov	DWORD PTR __$EHRec$[esp+36], -1
	call	??1?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::~vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:0, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1Rasterizer@@UAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 44					; 0000002cH
	push	eax
	call	??1?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::~vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
	ret	0
__unwindfunclet$??1Rasterizer@@UAE@XZ$1:
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 68					; 00000044H
	push	eax
	call	??1?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::~vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
	ret	0
__ehhandler$??1Rasterizer@@UAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??1Rasterizer@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1Rasterizer@@UAE@XZ ENDP				; Rasterizer::~Rasterizer
; Function compile flags: /Ogtpy
;	COMDAT ??_GRasterizer@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GRasterizer@@UAEPAXI@Z PROC				; Rasterizer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1Rasterizer@@UAE@XZ			; Rasterizer::~Rasterizer
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN4@scalar@4
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN4@scalar@4:
	mov	eax, esi
	pop	esi
	ret	4
??_GRasterizer@@UAEPAXI@Z ENDP				; Rasterizer::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	__real@406fe00000000000
;	COMDAT __real@406fe00000000000
; File d:\-=svn=-\svplayer\src\subtitles\separablefilter.h
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ??0GaussianKernel@@QAE@N@Z
_TEXT	SEGMENT
tv227 = -12						; size = 4
tv192 = -12						; size = 8
_sigma$ = 8						; size = 8
??0GaussianKernel@@QAE@N@Z PROC				; GaussianKernel::GaussianKernel, COMDAT
; _this$ = esi

; 104  : 	{
; 105  : 		width = (int)(sigma*3 + 0.5) | 1; // binary-or with 1 to make sure the number is odd

	fld	QWORD PTR _sigma$[esp-4]
	sub	esp, 16					; 00000010H
	fmul	QWORD PTR __real@4008000000000000
	push	edi
	fadd	QWORD PTR __real@3fe0000000000000
	call	__ftol2_sse
	or	eax, 1

; 106  : 		if (width < 3) width = 3;

	cmp	eax, 3
	mov	DWORD PTR [esi+4], eax
	jge	SHORT $LN4@GaussianKe
	mov	DWORD PTR [esi+4], 3
$LN4@GaussianKe:

; 107  : 		kernel = new int[width];

	mov	eax, DWORD PTR [esi+4]
	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 108  : 		kernel[width/2] = (int)(NormalDist(sigma, 0) * 255);

	fldz
	sub	esp, 12					; 0000000cH
	fstp	QWORD PTR [esp+8]
	fld	QWORD PTR _sigma$[esp+32]
	mov	edi, eax
	fstp	QWORD PTR [esp]
	mov	DWORD PTR [esi], edi
	call	?NormalDist@@YANNN@Z			; NormalDist
	fmul	QWORD PTR __real@406fe00000000000
	add	esp, 16					; 00000010H
	call	__ftol2_sse
	mov	ecx, eax
	mov	eax, DWORD PTR [esi+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR [edi+eax*4], ecx

; 109  : 		divisor = kernel[width/2];

	mov	eax, DWORD PTR [esi+4]
	cdq
	sub	eax, edx
	mov	edx, DWORD PTR [esi]
	sar	eax, 1
	mov	ecx, DWORD PTR [edx+eax*4]

; 110  : 		for (int x = width/2-1; x >= 0; x--) {

	lea	edi, DWORD PTR [eax-1]
	mov	DWORD PTR [esi+8], ecx
	test	edi, edi
	jl	$LN15@GaussianKe
	fld	QWORD PTR _sigma$[esp+16]
	fldz
$LN3@GaussianKe:

; 111  : 			int val = (int)(NormalDist(sigma, width/2-x) * 255 + 0.5);

	mov	eax, DWORD PTR [esi+4]
	cdq
	sub	eax, edx
	sar	eax, 1
	sub	eax, edi
	mov	DWORD PTR tv227[esp+20], eax
	fild	DWORD PTR tv227[esp+20]
	fxch	ST(2)
	fcom	ST(1)
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	SHORT $LN18@GaussianKe
	fld	ST(1)
	fucomp	ST(3)
	fnstsw	ax
	fstp	ST(2)
	test	ah, 68					; 00000044H
	jp	SHORT $LN10@GaussianKe
	fld1
	jmp	SHORT $LN7@GaussianKe
$LN10@GaussianKe:
	fld	ST(0)
	jmp	SHORT $LN7@GaussianKe
$LN18@GaussianKe:
	fstp	ST(1)
	fld	ST(1)
	fmulp	ST(2), ST(0)
	fld	ST(0)
	fadd	ST(0), ST(1)
	fmulp	ST(1), ST(0)
	fdivp	ST(1), ST(0)
	fchs
	call	__CIexp
	fstp	QWORD PTR tv192[esp+20]
	fld	QWORD PTR __real@401921fb54411744
	call	__CIsqrt
	fld	QWORD PTR _sigma$[esp+16]
	fmul	ST(1), ST(0)
	fld	QWORD PTR tv192[esp+20]
	fdivrp	ST(2), ST(0)
	fldz
	fxch	ST(1)
	fxch	ST(2)
$LN7@GaussianKe:
	fmul	QWORD PTR __real@406fe00000000000
	fadd	QWORD PTR __real@3fe0000000000000
	call	__ftol2_sse

; 112  : 			divisor += val*2;
; 113  : 			kernel[x] = val;

	mov	ecx, DWORD PTR [esi]
	lea	edx, DWORD PTR [eax+eax]
	add	DWORD PTR [esi+8], edx
	mov	DWORD PTR [ecx+edi*4], eax

; 114  : 			kernel[width - x - 1] = val;

	mov	edx, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	sub	edx, edi
	sub	edi, 1
	mov	DWORD PTR [ecx+edx*4-4], eax
	jns	$LN3@GaussianKe
	fstp	ST(1)
	fstp	ST(0)
$LN15@GaussianKe:

; 115  : 		}
; 116  : 	}

	mov	eax, esi
	pop	edi
	add	esp, 16					; 00000010H
	ret	8
??0GaussianKernel@@QAE@N@Z ENDP				; GaussianKernel::GaussianKernel
PUBLIC	?CreateWidenedRegion@Rasterizer@ssf@@QAE_NH@Z	; ssf::Rasterizer::CreateWidenedRegion
; Function compile flags: /Ogtpy
;	COMDAT ?CreateWidenedRegion@Rasterizer@ssf@@QAE_NH@Z
_TEXT	SEGMENT
tv197 = 8						; size = 4
_this$ = 8						; size = 4
?CreateWidenedRegion@Rasterizer@ssf@@QAE_NH@Z PROC	; ssf::Rasterizer::CreateWidenedRegion, COMDAT
; _r$ = eax

; 442  : 	{

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+4]
	push	esi
	push	edi
	mov	edi, eax

; 443  : 		if(r < 0) r = 0;

	test	edi, edi
	jge	SHORT $LN4@CreateWide
	xor	edi, edi
$LN4@CreateWide:

; 444  : 
; 445  : 		r >>= FONT_SCALE;

	sar	edi, 3

; 446  : 
; 447  : 		for(int y = -r; y <= r; ++y)

	mov	esi, edi
	neg	esi
	cmp	esi, edi
	jg	SHORT $LN13@CreateWide
	mov	ebx, edi
	imul	ebx, edi
$LL3@CreateWide:

; 448  : 		{
; 449  : 			int x = (int)(0.5f + sqrt(float(r*r - y*y)));

	mov	eax, esi
	imul	eax, esi
	mov	ecx, ebx
	sub	ecx, eax

; 450  : 
; 451  : 			_OverlapRegion(mWideOutline, mOutline, x, y);

	mov	DWORD PTR tv197[esp+12], ecx
	push	ecx
	fild	DWORD PTR tv197[esp+16]
	fstp	DWORD PTR [esp]
	call	_sqrtf
	fadd	QWORD PTR __real@3fe0000000000000
	add	esp, 4
	call	__ftol2_sse
	push	eax
	lea	eax, DWORD PTR [ebp+32]
	push	eax
	lea	eax, DWORD PTR [ebp+52]
	push	eax
	mov	edx, esi
	mov	eax, ebp
	call	?_OverlapRegion@Rasterizer@ssf@@AAEXAAV?$Array@TSpan@Rasterizer@ssf@@@2@0HH@Z ; ssf::Rasterizer::_OverlapRegion
	inc	esi
	cmp	esi, edi
	jle	SHORT $LL3@CreateWide
$LN13@CreateWide:

; 452  : 		}
; 453  : 
; 454  : 		mWideBorder = r;

	mov	DWORD PTR [ebp+92], edi

; 455  : 
; 456  : 		return true;
; 457  : 	}

	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx
	ret	4
?CreateWidenedRegion@Rasterizer@ssf@@QAE_NH@Z ENDP	; ssf::Rasterizer::CreateWidenedRegion
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_copy@PAU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_copy@PAU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >, COMDAT
; __Last$ = edx
; __Dest$ = eax

; 122  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	mov	ecx, DWORD PTR __First$[esp-4]

; 123  : 	_DEBUG_RANGE(_First, _Last);
; 124  : 	_DEBUG_POINTER(_Dest);
; 125  : 	_FwdIt _Next = _Dest;
; 126  : 
; 127  : 	_TRY_BEGIN
; 128  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop
	push	esi
	npad	7
$LL6@Uninit_cop:

; 129  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
$LN5@Uninit_cop:
	add	ecx, 16					; 00000010H
	add	eax, 16					; 00000010H
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop
	pop	esi
$LN4@Uninit_cop:

; 130  : 	_CATCH_ALL
; 131  : 	for (; _Next != _Dest; ++_Next)
; 132  : 		_Al.destroy(_Next);
; 133  : 	_RERAISE;
; 134  : 	_CATCH_END
; 135  : 	return (_Dest);
; 136  : 	}

	ret	0
??$_Uninit_copy@PAU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAPAU?$pair@_K_K@0@PBU10@0PAU10@AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
___formal$ = 12						; size = 1
___formal$ = 16						; size = 1
??$_Uninit_copy@PBU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAPAU?$pair@_K_K@0@PBU10@0PAU10@AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::pair<unsigned __int64,unsigned __int64> const *,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >, COMDAT
; __Last$ = edx
; __Dest$ = eax

; 122  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	mov	ecx, DWORD PTR __First$[esp-4]

; 123  : 	_DEBUG_RANGE(_First, _Last);
; 124  : 	_DEBUG_POINTER(_Dest);
; 125  : 	_FwdIt _Next = _Dest;
; 126  : 
; 127  : 	_TRY_BEGIN
; 128  : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	ecx, edx
	je	SHORT $LN4@Uninit_cop@2
	push	esi
	npad	7
$LL6@Uninit_cop@2:

; 129  : 		_Al.construct(_Dest, *_First);

	test	eax, eax
	je	SHORT $LN5@Uninit_cop@2
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [eax], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], esi
	mov	esi, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], esi
$LN5@Uninit_cop@2:
	add	ecx, 16					; 00000010H
	add	eax, 16					; 00000010H
	cmp	ecx, edx
	jne	SHORT $LL6@Uninit_cop@2
	pop	esi
$LN4@Uninit_cop@2:

; 130  : 	_CATCH_ALL
; 131  : 	for (; _Next != _Dest; ++_Next)
; 132  : 		_Al.destroy(_Next);
; 133  : 	_RERAISE;
; 134  : 	_CATCH_END
; 135  : 	return (_Dest);
; 136  : 	}

	ret	0
??$_Uninit_copy@PBU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAPAU?$pair@_K_K@0@PBU10@0PAU10@AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::pair<unsigned __int64,unsigned __int64> const *,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@stdext@@YAPAU?$pair@_K_K@std@@PAU12@00AAV?$allocator@U?$pair@_K_K@std@@@2@@Z
_TEXT	SEGMENT
$T263609 = -4						; size = 1
__Cat$263613 = 8					; size = 1
__Last$ = 8						; size = 4
__Dest$ = 12						; size = 4
??$unchecked_uninitialized_copy@PAU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@stdext@@YAPAU?$pair@_K_K@std@@PAU12@00AAV?$allocator@U?$pair@_K_K@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >, COMDAT
; __First$ = edx

; 809  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 810  : 		return (_STD _Uninit_copy(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest, _Al,
; 811  : 			_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$263613[esp]
	mov	BYTE PTR $T263609[esp+4], 0
	mov	eax, DWORD PTR $T263609[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+12]
	call	??$_Uninit_copy@PAU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >

; 812  : 	}

	add	esp, 16					; 00000010H
	ret	0
??$unchecked_uninitialized_copy@PAU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@stdext@@YAPAU?$pair@_K_K@std@@PAU12@00AAV?$allocator@U?$pair@_K_K@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@PAU?$pair@_K_K@2@V?$allocator@U?$pair@_K_K@std@@@2@@stdext@@YAPAU?$pair@_K_K@std@@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@0PAU12@AAV?$allocator@U?$pair@_K_K@std@@@2@@Z
_TEXT	SEGMENT
$T263638 = -4						; size = 1
__Cat$263642 = 8					; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@PAU?$pair@_K_K@2@V?$allocator@U?$pair@_K_K@std@@@2@@stdext@@YAPAU?$pair@_K_K@std@@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@0PAU12@AAV?$allocator@U?$pair@_K_K@std@@@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >, COMDAT

; 809  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 810  : 		return (_STD _Uninit_copy(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest, _Al,
; 811  : 			_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$263642[esp]
	mov	edx, DWORD PTR __First$[esp+4]
	mov	BYTE PTR $T263638[esp+4], 0
	mov	eax, DWORD PTR $T263638[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+16]
	call	??$_Uninit_copy@PBU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAPAU?$pair@_K_K@0@PBU10@0PAU10@AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned __int64,unsigned __int64> const *,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >

; 812  : 	}

	add	esp, 16					; 00000010H
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@PAU?$pair@_K_K@2@V?$allocator@U?$pair@_K_K@std@@@2@@stdext@@YAPAU?$pair@_K_K@std@@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@0PAU12@AAV?$allocator@U?$pair@_K_K@std@@@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??G?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEHABV?$_Vector_const_iterator@HV?$allocator@H@std@@@1@@Z
_TEXT	SEGMENT
??G?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEHABV?$_Vector_const_iterator@HV?$allocator@H@std@@@1@@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator-, COMDAT
; _this$ = edi
; __Right$ = esi

; 398  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN6@operator@7
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN5@operator@7
$LN6@operator@7:
	call	__invalid_parameter_noinfo
$LN5@operator@7:
	mov	eax, DWORD PTR [edi+4]
	sub	eax, DWORD PTR [esi+4]
	sar	eax, 2

; 399  : 		}

	ret	0
??G?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEHABV?$_Vector_const_iterator@HV?$allocator@H@std@@@1@@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator-
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAU?$pair@_K_K@std@@@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEPAU?$pair@_K_K@1@PAU21@00@Z
_TEXT	SEGMENT
$T263731 = -4						; size = 1
__Last$ = 8						; size = 4
__Cat$263734 = 12					; size = 1
__Ptr$ = 12						; size = 4
??$_Ucopy@PAU?$pair@_K_K@std@@@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEPAU?$pair@_K_K@1@PAU21@00@Z PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Ucopy<std::pair<unsigned __int64,unsigned __int64> *>, COMDAT
; __First$ = edx

; 1143 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1144 : 		{	// copy initializing [_First, _Last), using allocator
; 1145 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1146 : 			_Ptr, this->_Alval));

	mov	ecx, DWORD PTR __Cat$263734[esp]
	mov	BYTE PTR $T263731[esp+4], 0
	mov	eax, DWORD PTR $T263731[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+12]
	call	??$_Uninit_copy@PAU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >

; 1147 : 		}

	add	esp, 16					; 00000010H
	ret	8
??$_Ucopy@PAU?$pair@_K_K@std@@@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEPAU?$pair@_K_K@1@PAU21@00@Z ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Ucopy<std::pair<unsigned __int64,unsigned __int64> *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEPAU?$pair@_K_K@1@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@1@0PAU21@@Z
_TEXT	SEGMENT
$T263794 = -4						; size = 1
__Cat$263797 = 8					; size = 1
__Ptr$ = 8						; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
??$_Ucopy@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEPAU?$pair@_K_K@1@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@1@0PAU21@@Z PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Ucopy<std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > > >, COMDAT

; 1143 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1144 : 		{	// copy initializing [_First, _Last), using allocator
; 1145 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1146 : 			_Ptr, this->_Alval));

	mov	ecx, DWORD PTR __Cat$263797[esp]
	mov	edx, DWORD PTR __First$[esp+4]
	mov	BYTE PTR $T263794[esp+4], 0
	mov	eax, DWORD PTR $T263794[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+16]
	call	??$_Uninit_copy@PBU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAPAU?$pair@_K_K@0@PBU10@0PAU10@AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned __int64,unsigned __int64> const *,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >

; 1147 : 		}

	add	esp, 16					; 00000010H
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEPAU?$pair@_K_K@1@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@1@0PAU21@@Z ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Ucopy<std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\algorithm
_TEXT	ENDS
;	COMDAT ??$sort@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$sort@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z PROC ; std::sort<std::_Vector_iterator<int,std::allocator<int> > >, COMDAT

; 3111 : 	{	// order [_First, _Last), using operator<

	push	ecx

; 3112 : 	_DEBUG_RANGE(_First, _Last);
; 3113 : 	std::_Sort(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Last - _First);

	mov	eax, DWORD PTR __Last$[esp]
	test	eax, eax
	je	SHORT $LN8@sort
	cmp	eax, DWORD PTR __First$[esp]
	je	SHORT $LN7@sort
$LN8@sort:
	call	__invalid_parameter_noinfo
$LN7@sort:
	mov	eax, DWORD PTR __Last$[esp+4]
	mov	ecx, DWORD PTR __First$[esp+4]
	mov	edx, eax
	sub	edx, ecx
	sar	edx, 2
	push	edx
	push	eax
	push	ecx
	call	??$_Sort@PAHH@std@@YAXPAH0H@Z		; std::_Sort<int *,int>
	add	esp, 12					; 0000000cH
	pop	ecx

; 3114 : 	}

	ret	0
??$sort@V?$_Vector_iterator@HV?$allocator@H@std@@@std@@@std@@YAXV?$_Vector_iterator@HV?$allocator@H@std@@@0@0@Z ENDP ; std::sort<std::_Vector_iterator<int,std::allocator<int> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
??Y?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator+=, COMDAT
; _this$ = esi
; __Off$ = eax

; 159  : 		{	// increment by integer

	push	edi
	mov	edi, eax

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN26@operator@8
	call	__invalid_parameter_noinfo

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN16@operator@8
$LN26@operator@8:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN17@operator@8
$LN16@operator@8:
	xor	edx, edx
$LN17@operator@8:
	mov	ecx, DWORD PTR [esi+4]
	shl	edi, 4
	add	ecx, edi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN4@operator@8
	test	eax, eax
	je	SHORT $LN22@operator@8
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN23@operator@8
$LN22@operator@8:
	xor	eax, eax
$LN23@operator@8:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN27@operator@8
$LN4@operator@8:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	__invalid_parameter_noinfo
$LN27@operator@8:

; 164  : 		_Myptr += _Off;

	add	DWORD PTR [esi+4], edi

; 165  : 		return (*this);

	mov	eax, esi
	pop	edi

; 166  : 		}

	ret	0
??Y?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = esi

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN26@operator@9
	call	__invalid_parameter_noinfo

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN16@operator@9
$LN26@operator@9:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN17@operator@9
$LN16@operator@9:
	xor	edx, edx
$LN17@operator@9:
	mov	ecx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR __Off$[esp]
	add	edi, edi
	add	edi, edi
	add	ecx, edi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN4@operator@9
	test	eax, eax
	je	SHORT $LN22@operator@9
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN23@operator@9
$LN22@operator@9:
	xor	eax, eax
$LN23@operator@9:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN27@operator@9
$LN4@operator@9:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	__invalid_parameter_noinfo
$LN27@operator@9:

; 164  : 		_Myptr += _Off;

	add	DWORD PTR [esi+4], edi

; 165  : 		return (*this);

	mov	eax, esi
	pop	edi

; 166  : 		}

	ret	4
??Y?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
??Y?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator+=, COMDAT
; _this$ = esi
; __Off$ = eax

; 374  : 		{	// increment by integer

	push	edi
	mov	edi, eax

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN28@operator@10
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN18@operator@10
$LN28@operator@10:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN19@operator@10
$LN18@operator@10:
	xor	edx, edx
$LN19@operator@10:
	mov	ecx, DWORD PTR [esi+4]
	shl	edi, 4
	add	ecx, edi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN6@operator@10
	test	eax, eax
	je	SHORT $LN24@operator@10
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN25@operator@10
$LN24@operator@10:
	xor	eax, eax
$LN25@operator@10:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN29@operator@10
$LN6@operator@10:
	call	__invalid_parameter_noinfo
$LN29@operator@10:
	add	DWORD PTR [esi+4], edi

; 376  : 		return (*this);

	mov	eax, esi
	pop	edi

; 377  : 		}

	ret	0
??Y?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+=, COMDAT
; _this$ = esi

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN28@operator@11
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN18@operator@11
$LN28@operator@11:
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN19@operator@11
$LN18@operator@11:
	xor	edx, edx
$LN19@operator@11:
	mov	ecx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR __Off$[esp]
	add	edi, edi
	add	edi, edi
	add	ecx, edi
	cmp	ecx, DWORD PTR [edx+16]
	ja	SHORT $LN6@operator@11
	test	eax, eax
	je	SHORT $LN24@operator@11
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN25@operator@11
$LN24@operator@11:
	xor	eax, eax
$LN25@operator@11:
	cmp	ecx, DWORD PTR [eax+12]
	jae	SHORT $LN29@operator@11
$LN6@operator@11:
	call	__invalid_parameter_noinfo
$LN29@operator@11:
	add	DWORD PTR [esi+4], edi

; 376  : 		return (*this);

	mov	eax, esi
	pop	edi

; 377  : 		}

	ret	4
??Y?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??H?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
??H?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator+, COMDAT
; _this$ = eax
; __Off$ = ecx

; 380  : 		{	// return this + integer

	push	ebx

; 381  : 		_Myt _Tmp = *this;

	mov	ebx, DWORD PTR [eax+4]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+4]
	push	esi
	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, ecx

; 382  : 		return (_Tmp += _Off);

	test	esi, esi
	jne	SHORT $LN30@operator@12
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN21@operator@12:
	shl	edi, 4
	add	edi, ebx
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN8@operator@12
	test	esi, esi
	je	SHORT $LN26@operator@12
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN27@operator@12
$LN30@operator@12:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN21@operator@12
$LN26@operator@12:
	xor	eax, eax
$LN27@operator@12:
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN7@operator@12
$LN8@operator@12:
	call	__invalid_parameter_noinfo
$LN7@operator@12:
	mov	DWORD PTR [ebp+4], edi

; 383  : 		}

	pop	edi
	mov	DWORD PTR [ebp], esi
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx
	ret	4
??H?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator+
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator+, COMDAT
; _this$ = eax

; 380  : 		{	// return this + integer

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	esi

; 381  : 		_Myt _Tmp = *this;

	mov	esi, DWORD PTR [eax]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 382  : 		return (_Tmp += _Off);

	test	esi, esi
	jne	SHORT $LN30@operator@13
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN21@operator@13:
	mov	ecx, DWORD PTR __Off$[esp+8]
	lea	edi, DWORD PTR [edi+ecx*4]
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN8@operator@13
	test	esi, esi
	je	SHORT $LN26@operator@13
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN27@operator@13
$LN30@operator@13:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN21@operator@13
$LN26@operator@13:
	xor	eax, eax
$LN27@operator@13:
	cmp	edi, DWORD PTR [eax+12]
	jae	SHORT $LN7@operator@13
$LN8@operator@13:
	call	__invalid_parameter_noinfo
$LN7@operator@13:
	mov	DWORD PTR [ebx+4], edi

; 383  : 		}

	pop	edi
	mov	DWORD PTR [ebx], esi
	pop	esi
	mov	eax, ebx
	pop	ebx
	ret	8
??H?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator+
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<int> >::_Container_base_aux_alloc_real<std::allocator<int> >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<int> >::_Container_base_aux_alloc_real<std::allocator<int> >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z PROC ; std::vector<int,std::allocator<int> >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	DWORD PTR [esi], 0
	test	edi, edi
	je	SHORT $LN8@Make_iter
	mov	eax, DWORD PTR __Where$[esp]
	cmp	DWORD PTR [edi+12], eax
	ja	SHORT $LN8@Make_iter
	cmp	eax, DWORD PTR [edi+16]
	jbe	SHORT $LN7@Make_iter
$LN8@Make_iter:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __Where$[esp]
$LN7@Make_iter:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx
	mov	eax, esi

; 662  : 		}

	ret	8
?_Make_iter@?$vector@HV?$allocator@H@std@@@std@@QBE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@@Z ENDP ; std::vector<int,std::allocator<int> >::_Make_iter
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@_K_K@std@@@std@@@std@@IAE@V?$allocator@U?$pair@_K_K@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@_K_K@std@@@std@@@std@@IAE@V?$allocator@U?$pair@_K_K@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64,unsigned __int64> > >, COMDAT
; _this$ = esi

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@Container_@2
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
$LN3@Container_@2:

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 421  : 		}

	mov	eax, esi
	ret	4
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@_K_K@std@@@std@@@std@@IAE@V?$allocator@U?$pair@_K_K@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBE?AV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 8
?_Make_iter@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBE?AV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@@Z PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Make_iter, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = esi

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	DWORD PTR [esi], 0
	test	edi, edi
	je	SHORT $LN8@Make_iter@2
	mov	eax, DWORD PTR __Where$[esp]
	cmp	DWORD PTR [edi+12], eax
	ja	SHORT $LN8@Make_iter@2
	cmp	eax, DWORD PTR [edi+16]
	jbe	SHORT $LN7@Make_iter@2
$LN8@Make_iter@2:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __Where$[esp]
$LN7@Make_iter@2:
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], ecx
	mov	eax, esi

; 662  : 		}

	ret	8
?_Make_iter@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBE?AV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@@Z ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Make_iter
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator++, COMDAT
; _this$ = esi

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN19@operator@14
	call	__invalid_parameter_noinfo

; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN15@operator@14
$LN19@operator@14:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN16@operator@14
$LN15@operator@14:
	xor	eax, eax
$LN16@operator@14:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN20@operator@14
	call	__invalid_parameter_noinfo
$LN20@operator@14:

; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [esi+4], 16			; 00000010H

; 126  : 		return (*this);

	mov	eax, esi

; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEABU?$pair@_K_K@1@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEABU?$pair@_K_K@1@XZ PROC ; std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator*, COMDAT
; _this$ = esi

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN19@operator@15
	call	__invalid_parameter_noinfo

; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN15@operator@15
$LN19@operator@15:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN16@operator@15
$LN15@operator@15:
	xor	eax, eax
$LN16@operator@15:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN20@operator@15
	call	__invalid_parameter_noinfo

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [esi+4]

; 107  : 		}

	ret	0
$LN20@operator@15:

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, ecx

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEABU?$pair@_K_K@1@XZ ENDP ; std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++, COMDAT
; _this$ = esi

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN19@operator@16
	call	__invalid_parameter_noinfo

; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN15@operator@16
$LN19@operator@16:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN16@operator@16
$LN15@operator@16:
	xor	eax, eax
$LN16@operator@16:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN20@operator@16
	call	__invalid_parameter_noinfo
$LN20@operator@16:

; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	add	DWORD PTR [esi+4], 4

; 126  : 		return (*this);

	mov	eax, esi

; 127  : 		}

	ret	0
??E?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ PROC ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*, COMDAT
; _this$ = esi

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN19@operator@17
	call	__invalid_parameter_noinfo

; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN15@operator@17
$LN19@operator@17:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN16@operator@17
$LN15@operator@17:
	xor	eax, eax
$LN16@operator@17:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN20@operator@17
	call	__invalid_parameter_noinfo

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR [esi+4]

; 107  : 		}

	ret	0
$LN20@operator@17:

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, ecx

; 107  : 		}

	ret	0
??D?$_Vector_const_iterator@HV?$allocator@H@std@@@std@@QBEABHXZ ENDP ; std::_Vector_const_iterator<int,std::allocator<int> >::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z PROC ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >, COMDAT
; _this$ = esi

; 425  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Vector_val
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4

; 425  : 		{	// construct allocator from _Al

$LN8@Vector_val:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4
??0?$_Vector_val@HV?$allocator@H@std@@@std@@IAE@V?$allocator@H@1@@Z ENDP ; std::_Vector_val<int,std::allocator<int> >::_Vector_val<int,std::allocator<int> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z PROC ; std::vector<int,std::allocator<int> >::erase, COMDAT
; _this$ = esi

; 1033 : 		{	// erase [_First, _Last)

	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[esp]
	push	ebp
	push	edi

; 1034 : 		iterator _First = _Make_iter(_First_arg);

	mov	DWORD PTR [ebx], 0
	test	esi, esi
	je	SHORT $LN11@erase
	mov	eax, DWORD PTR __First_arg$[esp+12]
	cmp	DWORD PTR [esi+12], eax
	ja	SHORT $LN11@erase
	cmp	eax, DWORD PTR [esi+16]
	jbe	SHORT $LN10@erase
$LN11@erase:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First_arg$[esp+12]
$LN10@erase:

; 1035 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	edi, DWORD PTR __Last_arg$[esp+12]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ebx], ecx
	mov	DWORD PTR [ebx+4], eax
	cmp	DWORD PTR [esi+12], edi
	ja	SHORT $LN30@erase
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN29@erase
$LN30@erase:
	call	__invalid_parameter_noinfo
	mov	edi, DWORD PTR __Last_arg$[esp+12]
$LN29@erase:

; 1036 : 
; 1037 : 		if (_First != _Last)

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN47@erase
	cmp	eax, ecx
	je	SHORT $LN46@erase
$LN47@erase:
	call	__invalid_parameter_noinfo
$LN46@erase:
	mov	edx, DWORD PTR [ebx+4]
	cmp	edx, edi
	je	SHORT $LN72@erase

; 1038 : 			{	// worth doing, copy down over hole
; 1039 : 
; 1040 :  #if _HAS_ITERATOR_DEBUGGING
; 1041 : 			if (_Last < _First || _First._Mycont != this
; 1042 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1043 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));
; 1046 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1047 : 
; 1048 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1049 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1050 : 				_VEC_ITER_BASE(_First));

	mov	eax, DWORD PTR [esi+16]
	sub	eax, edi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	lea	ebp, DWORD PTR [ecx+edx]
	test	eax, eax
	jle	SHORT $LN69@erase
	push	ecx
	push	edi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN69@erase:

; 1051 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1052 : 
; 1053 : 			_Destroy(_Ptr, _Mylast);
; 1054 : 			_Mylast = _Ptr;

	mov	DWORD PTR [esi+16], ebp
$LN72@erase:

; 1055 : 			}
; 1056 : #if _HAS_ITERATOR_DEBUGGING
; 1057 :         return (iterator(_First._Myptr, this));
; 1058 : #else
; 1059 : 		return (_First);
; 1060 : #endif
; 1061 : 		}

	pop	edi
	pop	ebp
	mov	eax, ebx
	pop	ebx
	ret	20					; 00000014H
?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ENDP ; std::vector<int,std::allocator<int> >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAE@V?$allocator@U?$pair@_K_K@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAE@V?$allocator@U?$pair@_K_K@std@@@1@@Z PROC ; std::_Vector_val<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Vector_val<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >, COMDAT
; _this$ = esi

; 425  : 		{	// construct allocator from _Al

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@Vector_val@2
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4

; 425  : 		{	// construct allocator from _Al

$LN8@Vector_val@2:
	xor	eax, eax
	mov	DWORD PTR [esi], eax

; 426  : 		}

	mov	eax, esi
	ret	4
??0?$_Vector_val@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAE@V?$allocator@U?$pair@_K_K@std@@@1@@Z ENDP ; std::_Vector_val<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Vector_val<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator!=, COMDAT
; _this$ = edi
; __Right$ = esi

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN6@operator@18
	cmp	eax, DWORD PTR [esi]
	je	SHORT $LN5@operator@18
$LN6@operator@18:
	call	__invalid_parameter_noinfo
$LN5@operator@18:
	mov	eax, DWORD PTR [edi+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [esi+4]
	setne	cl
	mov	al, cl

; 217  : 		}

	ret	0
??9?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator++, COMDAT
; _this$ = esi

; 349  : 		++(*(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN21@operator@19
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN17@operator@19
$LN21@operator@19:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN18@operator@19
$LN17@operator@19:
	xor	eax, eax
$LN18@operator@19:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN22@operator@19
	call	__invalid_parameter_noinfo
$LN22@operator@19:
	add	DWORD PTR [esi+4], 16			; 00000010H

; 350  : 		return (*this);

	mov	eax, esi

; 351  : 		}

	ret	0
??E?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEAAU?$pair@_K_K@1@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEAAU?$pair@_K_K@1@XZ PROC ; std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator*, COMDAT
; _this$ = esi

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN21@operator@20
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN17@operator@20
$LN21@operator@20:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN18@operator@20
$LN17@operator@20:
	xor	eax, eax
$LN18@operator@20:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN22@operator@20
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 340  : 		}

	ret	0
$LN22@operator@20:

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, ecx

; 340  : 		}

	ret	0
??D?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QBEAAU?$pair@_K_K@1@XZ ENDP ; std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator++, COMDAT
; _this$ = esi

; 349  : 		++(*(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN21@operator@21
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN17@operator@21
$LN21@operator@21:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN18@operator@21
$LN17@operator@21:
	xor	eax, eax
$LN18@operator@21:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN22@operator@21
	call	__invalid_parameter_noinfo
$LN22@operator@21:
	add	DWORD PTR [esi+4], 4

; 350  : 		return (*this);

	mov	eax, esi

; 351  : 		}

	ret	0
??E?$_Vector_iterator@HV?$allocator@H@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??D?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ
_TEXT	SEGMENT
??D?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ PROC ; std::_Vector_iterator<int,std::allocator<int> >::operator*, COMDAT
; _this$ = esi

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	jne	SHORT $LN21@operator@22
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN17@operator@22
$LN21@operator@22:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN18@operator@22
$LN17@operator@22:
	xor	eax, eax
$LN18@operator@22:
	mov	ecx, DWORD PTR [esi+4]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN22@operator@22
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi+4]

; 340  : 		}

	ret	0
$LN22@operator@22:

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	eax, ecx

; 340  : 		}

	ret	0
??D?$_Vector_iterator@HV?$allocator@H@std@@@std@@QBEAAHXZ ENDP ; std::_Vector_iterator<int,std::allocator<int> >::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T265160 = -12						; size = 8
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ PROC	; std::vector<int,std::allocator<int> >::clear, COMDAT
; _this$ = eax

; 1064 : 		{	// erase all

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, eax

; 1065 : 		erase(begin(), end());

	mov	ebp, DWORD PTR [esi+16]
	push	edi
	cmp	DWORD PTR [esi+12], ebp
	jbe	SHORT $LN9@clear
	call	__invalid_parameter_noinfo
$LN9@clear:
	mov	edi, DWORD PTR [esi+12]
	mov	ebx, DWORD PTR [esi]
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN28@clear
	call	__invalid_parameter_noinfo
$LN28@clear:
	mov	eax, DWORD PTR [esi]
	push	ebp
	push	ebx
	push	edi
	push	eax
	lea	eax, DWORD PTR $T265160[esp+44]
	push	eax
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase

; 1066 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ENDP	; std::vector<int,std::allocator<int> >::clear
_TEXT	ENDS
PUBLIC	?Rasterize@Rasterizer@@QAE_NHHHN@Z		; Rasterizer::Rasterize
EXTRN	__aullshr:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Rasterize@Rasterizer@@QAE_NHHHN@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Rasterize@Rasterizer@@QAE_NHHHN@Z$0
__ehfuncinfo$?Rasterize@Rasterizer@@QAE_NHHHN@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Rasterize@Rasterizer@@QAE_NHHHN@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File d:\-=svn=-\svplayer\src\subtitles\rasterizer.cpp
xdata$x	ENDS
;	COMDAT ?Rasterize@Rasterizer@@QAE_NHHHN@Z
_TEXT	SEGMENT
_pass$129751 = -60					; size = 4
_i$129691 = -60						; size = 4
_width$ = -60						; size = 4
tv1631 = -56						; size = 4
_x1$129704 = -56					; size = 4
_height$ = -56						; size = 4
$T265458 = -52						; size = 4
_tmp$129757 = -52					; size = 4
_border$129761 = -48					; size = 4
_last$129710 = -48					; size = 4
tv1661 = -44						; size = 4
_x2$129706 = -44					; size = 4
_pOutline$ = -40					; size = 8
_it$129695 = -32					; size = 8
_filter$129718 = -24					; size = 12
_itEnd$129697 = -24					; size = 8
__$EHRec$ = -12						; size = 12
tv1570 = 8						; size = 4
_xsub$ = 8						; size = 4
_dst$129767 = 12					; size = 4
_ysub$ = 12						; size = 4
_fBlur$ = 16						; size = 4
_j$129762 = 20						; size = 4
_fGaussianBlur$ = 20					; size = 8
?Rasterize@Rasterizer@@QAE_NHHHN@Z PROC			; Rasterizer::Rasterize, COMDAT
; _this$ = edi

; 688  : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$?Rasterize@Rasterizer@@QAE_NHHHN@Z
	push	eax
	mov	DWORD PTR fs:0, esp

; 689  : 	_TrashOverlay();

	mov	eax, DWORD PTR [edi+112]
	sub	esp, 48					; 00000030H
	push	ebx
	push	ebp
	push	esi
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]

; 690  : 
; 691  : 	if(!mWidth || !mHeight)

	mov	eax, DWORD PTR [edi+36]
	xor	ebp, ebp
	add	esp, 4
	mov	DWORD PTR [edi+112], ebp
	cmp	eax, ebp
	je	$LN30@Rasterize@2
	mov	edx, DWORD PTR [edi+40]
	cmp	edx, ebp
	je	$LN30@Rasterize@2

; 694  : 		return true;
; 695  : 	}
; 696  : 
; 697  : 	xsub &= 7;

	mov	ecx, DWORD PTR _xsub$[esp+68]

; 698  : 	ysub &= 7;
; 699  : 
; 700  : 	int width = mWidth + xsub;
; 701  : 	int height = mHeight + ysub;
; 702  : 
; 703  : 	mOffsetX = mPathOffsetX - xsub;
; 704  : 	mOffsetY = mPathOffsetY - ysub;
; 705  : 
; 706  : 	mWideBorder = (mWideBorder+7)&~7;
; 707  : 
; 708  : 	if(!mWideOutline.empty() || fBlur || fGaussianBlur > 0)

	fld	QWORD PTR _fGaussianBlur$[esp+68]
	mov	esi, DWORD PTR _ysub$[esp+68]
	fldz
	and	ecx, 7
	add	eax, ecx
	mov	DWORD PTR _width$[esp+72], eax
	mov	eax, DWORD PTR [edi+124]
	and	esi, 7
	sub	eax, ecx
	mov	DWORD PTR _xsub$[esp+68], ecx
	mov	ecx, DWORD PTR [edi+128]
	add	edx, esi
	sub	ecx, esi
	mov	DWORD PTR _ysub$[esp+68], esi
	mov	esi, DWORD PTR [edi+92]
	add	esi, 7
	and	esi, -8					; fffffff8H
	lea	ebx, DWORD PTR [edi+68]
	mov	DWORD PTR [edi+132], eax
	mov	DWORD PTR [edi+136], ecx
	mov	DWORD PTR [edi+92], esi
	mov	eax, DWORD PTR [ebx+16]
	sub	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR _height$[esp+72], edx
	test	eax, -16				; fffffff0H
	jne	SHORT $LN28@Rasterize@2
	cmp	DWORD PTR _fBlur$[esp+68], ebp
	jne	SHORT $LN28@Rasterize@2
	fcom	ST(1)
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN217@Rasterize@2
$LN28@Rasterize@2:

; 709  : 	{
; 710  : 		int bluradjust = 0;
; 711  : 		if (fGaussianBlur > 0)

	fcomp	ST(1)
	xor	ecx, ecx
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN220@Rasterize@2

; 712  : 			bluradjust += (int)(fGaussianBlur*3*8 + 0.5) | 1;

	fmul	QWORD PTR __real@4008000000000000
	fmul	QWORD PTR __real@4020000000000000
	fadd	QWORD PTR __real@3fe0000000000000
	call	__ftol2_sse
	mov	ecx, eax
	or	ecx, 1
	jmp	SHORT $LN27@Rasterize@2
$LN220@Rasterize@2:

; 709  : 	{
; 710  : 		int bluradjust = 0;
; 711  : 		if (fGaussianBlur > 0)

	fstp	ST(0)
$LN27@Rasterize@2:

; 713  : 		if (fBlur)

	cmp	DWORD PTR _fBlur$[esp+68], ebp
	je	SHORT $LN26@Rasterize@2

; 714  : 			bluradjust += 8;

	add	ecx, 8
$LN26@Rasterize@2:

; 715  : 
; 716  : 		// Expand the buffer a bit when we're blurring, since that can also widen the borders a bit
; 717  : 		bluradjust = (bluradjust+7)&~7;
; 718  : 
; 719  : 		width += 2*mWideBorder + bluradjust*2;
; 720  : 		height += 2*mWideBorder + bluradjust*2;

	mov	edx, DWORD PTR _height$[esp+72]
	lea	eax, DWORD PTR [ecx+7]
	and	eax, -8					; fffffff8H
	lea	ecx, DWORD PTR [esi+eax]

; 721  : 
; 722  : 		xsub += mWideBorder + bluradjust;

	add	DWORD PTR _xsub$[esp+68], ecx

; 723  : 		ysub += mWideBorder + bluradjust;

	add	DWORD PTR _ysub$[esp+68], ecx
	lea	ebp, DWORD PTR [ecx+ecx]
	add	DWORD PTR _width$[esp+72], ebp

; 724  : 
; 725  : 		mOffsetX -= mWideBorder + bluradjust;

	lea	ecx, DWORD PTR [esi+eax]
	sub	DWORD PTR [edi+132], ecx

; 726  : 		mOffsetY -= mWideBorder + bluradjust;

	add	esi, eax
	sub	DWORD PTR [edi+136], esi
	add	edx, ebp
	xor	ebp, ebp
	jmp	SHORT $LN29@Rasterize@2
$LN217@Rasterize@2:

; 698  : 	ysub &= 7;
; 699  : 
; 700  : 	int width = mWidth + xsub;
; 701  : 	int height = mHeight + ysub;
; 702  : 
; 703  : 	mOffsetX = mPathOffsetX - xsub;
; 704  : 	mOffsetY = mPathOffsetY - ysub;
; 705  : 
; 706  : 	mWideBorder = (mWideBorder+7)&~7;
; 707  : 
; 708  : 	if(!mWideOutline.empty() || fBlur || fGaussianBlur > 0)

	fstp	ST(1)
	fstp	ST(0)
$LN29@Rasterize@2:

; 727  : 	}
; 728  : 
; 729  : 	mOverlayWidth = ((width+7)>>3) + 1;

	mov	eax, DWORD PTR _width$[esp+72]
	lea	ecx, DWORD PTR [eax+7]

; 730  : 	mOverlayHeight = ((height+7)>>3) + 1;

	lea	eax, DWORD PTR [edx+7]
	sar	eax, 3
	inc	eax
	sar	ecx, 3
	inc	ecx
	mov	DWORD PTR [edi+120], eax

; 731  : 
; 732  : 	mpOverlayBuffer = new byte[2 * mOverlayWidth * mOverlayHeight];

	imul	eax, ecx
	add	eax, eax
	push	eax
	mov	DWORD PTR [edi+116], ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 733  : 	memset(mpOverlayBuffer, 0, 2 * mOverlayWidth * mOverlayHeight);

	mov	ecx, DWORD PTR [edi+120]
	imul	ecx, DWORD PTR [edi+116]
	add	esp, 4
	add	ecx, ecx
	push	ecx
	push	ebp
	push	eax
	mov	DWORD PTR [edi+112], eax
	call	_memset

; 734  : 
; 735  : 	// Are we doing a border?
; 736  : 
; 737  : 	tSpanBuffer* pOutline[2] = {&mOutline, &mWideOutline};

	lea	edx, DWORD PTR [edi+44]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pOutline$[esp+72], edx
	mov	DWORD PTR _pOutline$[esp+76], ebx

; 738  : 
; 739  : 	for(int i = countof(pOutline)-1; i >= 0; i--)

	mov	DWORD PTR _i$129691[esp+72], 1
$LN25@Rasterize@2:

; 740  : 	{
; 741  : 		tSpanBuffer::iterator it = pOutline[i]->begin();

	mov	eax, DWORD PTR _i$129691[esp+72]
	mov	esi, DWORD PTR _pOutline$[esp+eax*4+72]
	mov	ebp, DWORD PTR [esi+12]
	cmp	ebp, DWORD PTR [esi+16]
	jbe	SHORT $LN47@Rasterize@2
	call	__invalid_parameter_noinfo
$LN47@Rasterize@2:

; 742  : 		tSpanBuffer::iterator itEnd = pOutline[i]->end();

	mov	eax, DWORD PTR [esi+16]
	mov	ebx, DWORD PTR [esi]
	mov	DWORD PTR _it$129695[esp+72], ebx
	mov	DWORD PTR $T265458[esp+72], eax
	cmp	DWORD PTR [esi+12], eax
	jbe	SHORT $LN66@Rasterize@2
	call	__invalid_parameter_noinfo
$LN66@Rasterize@2:
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR _itEnd$129697[esp+72], ecx
	npad	5

; 743  : 
; 744  : 		for(; it!=itEnd; ++it)

$LL89@Rasterize@2:
	test	ebx, ebx
	je	SHORT $LN104@Rasterize@2
	cmp	ebx, DWORD PTR _itEnd$129697[esp+72]
	je	SHORT $LN103@Rasterize@2
$LN104@Rasterize@2:
	call	__invalid_parameter_noinfo
$LN103@Rasterize@2:
	cmp	ebp, DWORD PTR $T265458[esp+72]
	je	$LN24@Rasterize@2

; 745  : 		{
; 746  : 			int y = (int)(((*it).first >> 32) - 0x40000000 + ysub);

	test	ebx, ebx
	jne	$LN199@Rasterize@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN129@Rasterize@2:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN116@Rasterize@2
	call	__invalid_parameter_noinfo
$LN116@Rasterize@2:
	mov	eax, DWORD PTR [ebp]
	mov	edx, DWORD PTR [ebp+4]
	mov	cl, 32					; 00000020H
	call	__aullshr
	mov	edx, DWORD PTR _ysub$[esp+68]
	lea	esi, DWORD PTR [eax+edx-1073741824]

; 747  : 			int x1 = (int)(((*it).first & 0xffffffff) - 0x40000000 + xsub);

	test	ebx, ebx
	jne	$LN198@Rasterize@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN149@Rasterize@2:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN136@Rasterize@2
	call	__invalid_parameter_noinfo
$LN136@Rasterize@2:
	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR _xsub$[esp+68]
	lea	edx, DWORD PTR [eax+ecx-1073741824]
	mov	DWORD PTR _x1$129704[esp+72], edx

; 748  : 			int x2 = (int)(((*it).second & 0xffffffff) - 0x40000000 + xsub);

	test	ebx, ebx
	jne	SHORT $LN197@Rasterize@2
	call	__invalid_parameter_noinfo
$LN169@Rasterize@2:
	cmp	ebp, DWORD PTR [ebx+16]
	jb	SHORT $LN156@Rasterize@2
	call	__invalid_parameter_noinfo
$LN156@Rasterize@2:
	mov	ecx, DWORD PTR _xsub$[esp+68]
	mov	eax, DWORD PTR [ebp+8]
	lea	ebx, DWORD PTR [eax+ecx-1073741824]

; 749  : 
; 750  : 			if(x2 > x1)

	mov	ecx, DWORD PTR _x1$129704[esp+72]
	cmp	ebx, ecx
	mov	DWORD PTR _x2$129706[esp+72], ebx
	jle	SHORT $LN21@Rasterize@2

; 751  : 			{
; 752  : 				int first = x1>>3;
; 753  : 				int last = (x2-1)>>3;
; 754  : 				byte* dst = mpOverlayBuffer + 2*(mOverlayWidth*(y>>3) + first) + i;

	mov	eax, DWORD PTR _i$129691[esp+72]
	sar	esi, 3
	imul	esi, DWORD PTR [edi+116]
	sar	ecx, 3
	add	esi, ecx
	lea	edx, DWORD PTR [ebx-1]
	sar	edx, 3
	lea	eax, DWORD PTR [eax+esi*2]
	add	eax, DWORD PTR [edi+112]
	mov	DWORD PTR _last$129710[esp+72], edx

; 755  : 
; 756  : 				if(first == last)

	cmp	ecx, edx
	jne	SHORT $LN18@Rasterize@2

; 757  : 					*dst += x2-x1;

	sub	bl, BYTE PTR _x1$129704[esp+72]
	add	BYTE PTR [eax], bl

; 758  : 				else

	jmp	SHORT $LN21@Rasterize@2
$LN199@Rasterize@2:

; 745  : 		{
; 746  : 			int y = (int)(((*it).first >> 32) - 0x40000000 + ysub);

	mov	eax, DWORD PTR [ebx]
	jmp	$LN129@Rasterize@2
$LN198@Rasterize@2:

; 747  : 			int x1 = (int)(((*it).first & 0xffffffff) - 0x40000000 + xsub);

	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN149@Rasterize@2
$LN197@Rasterize@2:

; 748  : 			int x2 = (int)(((*it).second & 0xffffffff) - 0x40000000 + xsub);

	mov	ebx, DWORD PTR [ebx]
	jmp	SHORT $LN169@Rasterize@2
$LN18@Rasterize@2:

; 759  : 				{
; 760  : 					*dst += ((first+1)<<3) - x1;
; 761  : 					dst += 2;
; 762  : 
; 763  : 					while(++first < last)

	mov	ebx, DWORD PTR _last$129710[esp+72]
	mov	dl, cl
	add	dl, dl
	add	dl, dl
	add	dl, dl
	sub	dl, BYTE PTR _x1$129704[esp+72]
	inc	ecx
	add	dl, 8
	add	BYTE PTR [eax], dl
	add	eax, 2
	cmp	ecx, ebx
	jge	SHORT $LN15@Rasterize@2
	mov	edx, ebx
	sub	edx, ecx
	npad	2
$LL16@Rasterize@2:

; 764  : 					{
; 765  : 						*dst += 0x08;

	add	BYTE PTR [eax], 8

; 766  : 						dst += 2;

	add	eax, 2
	sub	edx, 1
	jne	SHORT $LL16@Rasterize@2
$LN15@Rasterize@2:

; 767  : 					}
; 768  : 
; 769  : 					*dst += x2 - (last<<3);

	mov	cl, BYTE PTR _x2$129706[esp+72]
	add	bl, bl
	add	bl, bl
	add	bl, bl
	sub	cl, bl
	add	BYTE PTR [eax], cl
$LN21@Rasterize@2:
	mov	eax, DWORD PTR _it$129695[esp+72]
	test	eax, eax
	jne	SHORT $LN196@Rasterize@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN96@Rasterize@2:

; 743  : 
; 744  : 		for(; it!=itEnd; ++it)

	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN83@Rasterize@2
	call	__invalid_parameter_noinfo
$LN83@Rasterize@2:
	mov	ebx, DWORD PTR _it$129695[esp+72]
	add	ebp, 16					; 00000010H
	jmp	$LL89@Rasterize@2
$LN196@Rasterize@2:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN96@Rasterize@2
$LN24@Rasterize@2:

; 738  : 
; 739  : 	for(int i = countof(pOutline)-1; i >= 0; i--)

	sub	DWORD PTR _i$129691[esp+72], 1
	jns	$LN25@Rasterize@2

; 770  : 				}
; 771  : 			}
; 772  : 		}
; 773  : 	}
; 774  : 
; 775  : 	// Do some gaussian blur magic
; 776  : 	if (fGaussianBlur > 0)

	fldz
	fld	QWORD PTR _fGaussianBlur$[esp+68]
	fcom	ST(1)
	fnstsw	ax
	fstp	ST(1)
	test	ah, 65					; 00000041H
	jne	$LN223@Rasterize@2

; 777  : 	{
; 778  : 		GaussianKernel filter(fGaussianBlur);

	sub	esp, 8
	lea	esi, DWORD PTR _filter$129718[esp+80]
	fstp	QWORD PTR [esp]
	call	??0GaussianKernel@@QAE@N@Z		; GaussianKernel::GaussianKernel
	mov	DWORD PTR __$EHRec$[esp+80], 0

; 779  : 		if (mOverlayWidth >= filter.width && mOverlayHeight >= filter.width)

	mov	ecx, DWORD PTR [edi+116]
	mov	edx, DWORD PTR _filter$129718[esp+76]
	cmp	ecx, edx
	jl	$LN13@Rasterize@2
	mov	eax, DWORD PTR [edi+120]
	cmp	eax, edx
	jl	$LN13@Rasterize@2

; 780  : 		{
; 781  : 			int pitch = mOverlayWidth*2;

	lea	ebp, DWORD PTR [ecx+ecx]

; 782  : 
; 783  : 			byte *tmp = new byte[pitch*mOverlayHeight];

	imul	eax, ebp
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ebx, eax
	add	esp, 4

; 784  : 			if(!tmp) return(false);

	test	ebx, ebx
	jne	SHORT $LN12@Rasterize@2
	mov	DWORD PTR __$EHRec$[esp+80], -1
	mov	eax, DWORD PTR _filter$129718[esp+72]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN190@Rasterize@2:
	xor	al, al

; 827  : 		}
; 828  : 	}
; 829  : 
; 830  : 	return true;
; 831  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+72]
	mov	DWORD PTR fs:0, ecx
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 60					; 0000003cH
	ret	20					; 00000014H
$LN12@Rasterize@2:

; 785  : 
; 786  : 			int border = !mWideOutline.empty() ? 1 : 0;

	mov	eax, DWORD PTR [edi+84]
	sub	eax, DWORD PTR [edi+80]

; 787  : 
; 788  : 			byte *src = mpOverlayBuffer + border;
; 789  : 
; 790  : 			SeparableFilterX<2>(src, tmp, mOverlayWidth, mOverlayHeight, pitch, filter.kernel, filter.width, filter.divisor);

	mov	ecx, DWORD PTR _filter$129718[esp+80]
	mov	esi, DWORD PTR [edi+112]
	mov	edx, DWORD PTR _filter$129718[esp+76]
	and	eax, -16				; fffffff0H
	neg	eax
	sbb	eax, eax
	push	ecx
	mov	ecx, DWORD PTR [edi+116]
	neg	eax
	add	esi, eax
	mov	eax, DWORD PTR _filter$129718[esp+76]
	push	edx
	push	eax
	mov	eax, DWORD PTR [edi+120]
	push	ebp
	push	ecx
	push	ebx
	mov	ecx, esi
	call	??$SeparableFilterX@$01@@YAXPAE0HHHPAHHH@Z ; SeparableFilterX<2>

; 791  : 			SeparableFilterY<2>(tmp, src, mOverlayWidth, mOverlayHeight, pitch, filter.kernel, filter.width, filter.divisor);

	mov	edx, DWORD PTR _filter$129718[esp+104]
	mov	eax, DWORD PTR _filter$129718[esp+100]
	mov	ecx, DWORD PTR _filter$129718[esp+96]
	push	edx
	mov	edx, DWORD PTR [edi+120]
	push	eax
	mov	eax, DWORD PTR [edi+116]
	push	ecx
	push	ebp
	push	edx
	push	esi
	mov	edx, ebx
	call	??$SeparableFilterY@$01@@YAXPAE0HHHPAHHH@Z ; SeparableFilterY<2>

; 792  : 
; 793  : 			delete[] tmp;

	push	ebx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 52					; 00000034H
$LN13@Rasterize@2:

; 794  : 		}
; 795  : 	}

	mov	DWORD PTR __$EHRec$[esp+80], -1
	mov	eax, DWORD PTR _filter$129718[esp+72]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
	jmp	SHORT $LN178@Rasterize@2
$LN223@Rasterize@2:

; 770  : 				}
; 771  : 			}
; 772  : 		}
; 773  : 	}
; 774  : 
; 775  : 	// Do some gaussian blur magic
; 776  : 	if (fGaussianBlur > 0)

	fstp	ST(0)

; 794  : 		}
; 795  : 	}

$LN178@Rasterize@2:

; 796  : 
; 797  : 	// If we're blurring, do a 3x3 box blur
; 798  : 	// Can't do it on subpictures smaller than 3x3 pixels
; 799  : 	for (int pass = 0; pass < fBlur; pass++)

	cmp	DWORD PTR _fBlur$[esp+68], 0
	mov	DWORD PTR _pass$129751[esp+72], 0
	jle	$LN9@Rasterize@2
$LN11@Rasterize@2:

; 800  : 	{
; 801  : 		if(mOverlayWidth >= 3 && mOverlayHeight >= 3)

	mov	ecx, DWORD PTR [edi+116]
	cmp	ecx, 3
	jl	$LN10@Rasterize@2
	mov	eax, DWORD PTR [edi+120]
	cmp	eax, 3
	jl	$LN10@Rasterize@2

; 802  : 		{
; 803  : 			int pitch = mOverlayWidth*2;

	lea	esi, DWORD PTR [ecx+ecx]

; 804  : 
; 805  : 			byte* tmp = new byte[pitch*mOverlayHeight];

	imul	eax, esi
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ebx, eax
	add	esp, 4
	mov	DWORD PTR _tmp$129757[esp+72], ebx

; 806  : 			if(!tmp) return(false);

	test	ebx, ebx
	je	$LN190@Rasterize@2

; 807  : 
; 808  : 			memcpy(tmp, mpOverlayBuffer, pitch*mOverlayHeight);

	mov	ecx, DWORD PTR [edi+120]
	mov	edx, DWORD PTR [edi+112]
	imul	ecx, esi
	push	ecx
	push	edx
	push	ebx
	call	_memcpy

; 809  : 
; 810  : 			int border = !mWideOutline.empty() ? 1 : 0;

	mov	edx, DWORD PTR [edi+84]
	sub	edx, DWORD PTR [edi+80]

; 811  : 
; 812  : 			// This could be done in a separated way and win some speed
; 813  : 			for(int j = 1; j < mOverlayHeight-1; j++)

	mov	eax, DWORD PTR [edi+120]
	and	edx, -16				; fffffff0H
	add	esp, 12					; 0000000cH
	neg	edx
	sbb	edx, edx
	neg	edx
	dec	eax
	cmp	eax, 1
	mov	DWORD PTR _border$129761[esp+72], edx
	mov	DWORD PTR _j$129762[esp+68], 1
	jle	$LN4@Rasterize@2
	lea	ecx, DWORD PTR [edx+ebx]
	mov	eax, 2
	lea	ecx, DWORD PTR [ecx+esi+2]
	sub	eax, esi
	mov	DWORD PTR tv1570[esp+68], esi
	mov	DWORD PTR tv1631[esp+72], ecx
	mov	DWORD PTR tv1661[esp+72], eax
$LN6@Rasterize@2:

; 814  : 			{
; 815  : 				byte* src = tmp + pitch*j + 2 + border;
; 816  : 				byte* dst = mpOverlayBuffer + pitch*j + 2 + border;

	mov	eax, DWORD PTR tv1570[esp+68]
	mov	ebx, DWORD PTR [edi+112]
	add	eax, edx
	lea	eax, DWORD PTR [eax+ebx+2]
	mov	DWORD PTR _dst$129767[esp+68], eax

; 817  : 
; 818  : 				for(int i = 1; i < mOverlayWidth-1; i++, src+=2, dst+=2)

	mov	eax, DWORD PTR [edi+116]
	mov	ebp, 1
	dec	eax
	cmp	eax, ebp
	jle	SHORT $LN5@Rasterize@2
	mov	edx, DWORD PTR tv1661[esp+72]
	lea	eax, DWORD PTR [edx+ecx]
	npad	6
$LL3@Rasterize@2:

; 819  : 				{
; 820  : 					*dst = (src[-2-pitch] + (src[-pitch]<<1) + src[+2-pitch]
; 821  : 						+ (src[-2]<<1) + (src[0]<<2) + (src[+2]<<1)
; 822  : 						+ src[-2+pitch] + (src[+pitch]<<1) + src[+2+pitch]) >> 4;

	movzx	ebx, BYTE PTR [esi+ecx]
	movzx	edx, BYTE PTR [eax+esi]
	add	edx, ebx
	movzx	ebx, BYTE PTR [esi+eax-4]
	add	edx, ebx
	movzx	ebx, BYTE PTR [eax-2]
	add	edx, ebx
	movzx	ebx, BYTE PTR [ecx]
	lea	edx, DWORD PTR [edx+ebx*2]
	movzx	ebx, BYTE PTR [esi+ecx+2]
	lea	ebx, DWORD PTR [ebx+edx*2]
	movzx	edx, BYTE PTR [esi+ecx-2]
	add	ebx, edx
	movzx	edx, BYTE PTR [eax-4]
	add	ebx, edx
	movzx	edx, BYTE PTR [eax]
	add	ebx, edx
	mov	edx, DWORD PTR _dst$129767[esp+68]
	sar	ebx, 4
	mov	BYTE PTR [edx], bl
	add	edx, 2
	mov	DWORD PTR _dst$129767[esp+68], edx
	mov	edx, DWORD PTR [edi+116]
	inc	ebp
	dec	edx
	add	ecx, 2
	add	eax, 2
	cmp	ebp, edx
	jl	SHORT $LL3@Rasterize@2
	mov	edx, DWORD PTR _border$129761[esp+72]
	mov	ecx, DWORD PTR tv1631[esp+72]
$LN5@Rasterize@2:
	mov	eax, DWORD PTR _j$129762[esp+68]
	mov	ebx, DWORD PTR [edi+120]
	add	DWORD PTR tv1570[esp+68], esi
	inc	eax
	add	ecx, esi
	dec	ebx
	cmp	eax, ebx
	mov	DWORD PTR _j$129762[esp+68], eax
	mov	DWORD PTR tv1631[esp+72], ecx
	jl	$LN6@Rasterize@2

; 811  : 
; 812  : 			// This could be done in a separated way and win some speed
; 813  : 			for(int j = 1; j < mOverlayHeight-1; j++)

	mov	ebx, DWORD PTR _tmp$129757[esp+72]
$LN4@Rasterize@2:

; 823  : 				}
; 824  : 			}
; 825  : 
; 826  : 			delete [] tmp;

	push	ebx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN10@Rasterize@2:
	mov	eax, DWORD PTR _pass$129751[esp+72]
	inc	eax
	cmp	eax, DWORD PTR _fBlur$[esp+68]
	mov	DWORD PTR _pass$129751[esp+72], eax
	jl	$LN11@Rasterize@2

; 806  : 			if(!tmp) return(false);

	jmp	SHORT $LN9@Rasterize@2
$LN30@Rasterize@2:

; 692  : 	{
; 693  : 		mOverlayWidth = mOverlayHeight = 0;

	mov	DWORD PTR [edi+120], ebp
	mov	DWORD PTR [edi+116], ebp
$LN9@Rasterize@2:

; 827  : 		}
; 828  : 	}
; 829  : 
; 830  : 	return true;
; 831  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+72]
	pop	esi
	pop	ebp
	mov	al, 1
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 60					; 0000003cH
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Rasterize@Rasterizer@@QAE_NHHHN@Z$0:
	lea	eax, DWORD PTR _filter$129718[ebp]
	jmp	??1GaussianKernel@@QAE@XZ		; GaussianKernel::~GaussianKernel
__ehhandler$?Rasterize@Rasterizer@@QAE_NHHHN@Z:
	mov	eax, OFFSET __ehfuncinfo$?Rasterize@Rasterizer@@QAE_NHHHN@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Rasterize@Rasterizer@@QAE_NHHHN@Z ENDP			; Rasterizer::Rasterize
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 110  : 		}

	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN21@length_err
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN21@length_err:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	BYTE PTR [esi+16], al
	mov	ecx, esi
	pop	esi
	jmp	??1exception@std@@UAE@XZ		; std::exception::~exception
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@U_Undefined_move_tag@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00AAV?$allocator@U?$pair@_K_K@std@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T295308 = -4						; size = 1
__Last$ = 8						; size = 4
__Cat$295311 = 12					; size = 1
__Dest$ = 12						; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninit_move@PAU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@U_Undefined_move_tag@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00AAV?$allocator@U?$pair@_K_K@std@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> >,std::_Undefined_move_tag>, COMDAT
; __First$ = edx

; 204  : 	{	// move defaults to copy if there is not a more effecient way

	push	ecx

; 205  : 	return _STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al);

	mov	ecx, DWORD PTR __Cat$295311[esp]
	mov	BYTE PTR $T295308[esp+4], 0
	mov	eax, DWORD PTR $T295308[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+12]
	call	??$_Uninit_copy@PAU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >

; 206  : 	}

	add	esp, 16					; 00000010H
	ret	0
??$_Uninit_move@PAU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@U_Undefined_move_tag@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00AAV?$allocator@U?$pair@_K_K@std@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> >,std::_Undefined_move_tag>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@PAU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@stdext@@YAPAU?$pair@_K_K@std@@PAU12@00AAV?$allocator@U?$pair@_K_K@std@@@2@@Z
_TEXT	SEGMENT
$T295407 = -4						; size = 1
__Last$ = 8						; size = 4
__Cat$295410 = 12					; size = 1
__Dest$ = 12						; size = 4
??$_Unchecked_uninitialized_move@PAU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@stdext@@YAPAU?$pair@_K_K@std@@PAU12@00AAV?$allocator@U?$pair@_K_K@std@@@2@@Z PROC ; stdext::_Unchecked_uninitialized_move<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >, COMDAT
; __First$ = edx

; 849  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 850  : 		return (_STD _Uninit_move(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest, _Al,
; 851  : 			_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$295410[esp]
	mov	BYTE PTR $T295407[esp+4], 0
	mov	eax, DWORD PTR $T295407[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+12]
	call	??$_Uninit_copy@PAU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >

; 852  : 	}

	add	esp, 16					; 00000010H
	ret	0
??$_Unchecked_uninitialized_move@PAU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@stdext@@YAPAU?$pair@_K_K@std@@PAU12@00AAV?$allocator@U?$pair@_K_K@std@@@2@@Z ENDP ; stdext::_Unchecked_uninitialized_move<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Unchecked_uninitialized_move@V?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@PAU?$pair@_K_K@2@V?$allocator@U?$pair@_K_K@std@@@2@@stdext@@YAPAU?$pair@_K_K@std@@V?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@0PAU12@AAV?$allocator@U?$pair@_K_K@std@@@2@@Z
_TEXT	SEGMENT
$T295519 = -4						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Cat$295522 = 24					; size = 1
__Dest$ = 24						; size = 4
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@PAU?$pair@_K_K@2@V?$allocator@U?$pair@_K_K@std@@@2@@stdext@@YAPAU?$pair@_K_K@std@@V?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@0PAU12@AAV?$allocator@U?$pair@_K_K@std@@@2@@Z PROC ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >, COMDAT

; 849  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 850  : 		return (_STD _Uninit_move(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest, _Al,
; 851  : 			_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	mov	ecx, DWORD PTR __Cat$295522[esp]
	mov	edx, DWORD PTR __First$[esp+4]
	mov	BYTE PTR $T295519[esp+4], 0
	mov	eax, DWORD PTR $T295519[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+16]
	call	??$_Uninit_copy@PAU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >

; 852  : 	}

	add	esp, 16					; 00000010H
	ret	0
??$_Unchecked_uninitialized_move@V?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@PAU?$pair@_K_K@2@V?$allocator@U?$pair@_K_K@std@@@2@@stdext@@YAPAU?$pair@_K_K@std@@V?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@0PAU12@AAV?$allocator@U?$pair@_K_K@std@@@2@@Z ENDP ; stdext::_Unchecked_uninitialized_move<std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Umove@PAU?$pair@_K_K@std@@@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEPAU?$pair@_K_K@1@PAU21@00@Z
_TEXT	SEGMENT
$T295656 = -4						; size = 1
__Last$ = 8						; size = 4
__Cat$295659 = 12					; size = 1
__Ptr$ = 12						; size = 4
??$_Umove@PAU?$pair@_K_K@std@@@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEPAU?$pair@_K_K@1@PAU21@00@Z PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Umove<std::pair<unsigned __int64,unsigned __int64> *>, COMDAT
; __First$ = edx

; 1150 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1151 : 		{	// move initializing [_First, _Last), using allocator
; 1152 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1153 : 			_Ptr, this->_Alval));

	mov	ecx, DWORD PTR __Cat$295659[esp]
	mov	BYTE PTR $T295656[esp+4], 0
	mov	eax, DWORD PTR $T295656[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+12]
	call	??$_Uninit_copy@PAU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >

; 1154 : 		}

	add	esp, 16					; 00000010H
	ret	8
??$_Umove@PAU?$pair@_K_K@std@@@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEPAU?$pair@_K_K@1@PAU21@00@Z ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Umove<std::pair<unsigned __int64,unsigned __int64> *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Umove@V?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEPAU?$pair@_K_K@1@V?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@1@0PAU21@@Z
_TEXT	SEGMENT
$T295812 = -4						; size = 1
__Cat$295815 = 8					; size = 1
__Ptr$ = 8						; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
??$_Umove@V?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEPAU?$pair@_K_K@1@V?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@1@0PAU21@@Z PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Umove<std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > > >, COMDAT

; 1150 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ecx

; 1151 : 		{	// move initializing [_First, _Last), using allocator
; 1152 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1153 : 			_Ptr, this->_Alval));

	mov	ecx, DWORD PTR __Cat$295815[esp]
	mov	edx, DWORD PTR __First$[esp+4]
	mov	BYTE PTR $T295812[esp+4], 0
	mov	eax, DWORD PTR $T295812[esp+4]
	push	eax
	mov	eax, DWORD PTR __Ptr$[esp+4]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Last$[esp+16]
	call	??$_Uninit_copy@PAU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >

; 1154 : 		}

	add	esp, 16					; 00000010H
	ret	20					; 00000014H
??$_Umove@V?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEPAU?$pair@_K_K@1@V?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@1@0PAU21@@Z ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Umove<std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?erase@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@0@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__First_arg$ = 16					; size = 8
__Last_arg$ = 24					; size = 8
?erase@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@0@Z PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::erase, COMDAT

; 1033 : 		{	// erase [_First, _Last)

	push	ebx
	mov	ebx, DWORD PTR _this$[esp]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+4]
	push	esi
	push	edi

; 1034 : 		iterator _First = _Make_iter(_First_arg);

	mov	DWORD PTR [ebp], 0
	test	ebx, ebx
	je	SHORT $LN11@erase@2
	mov	eax, DWORD PTR __First_arg$[esp+16]
	cmp	DWORD PTR [ebx+12], eax
	ja	SHORT $LN11@erase@2
	cmp	eax, DWORD PTR [ebx+16]
	jbe	SHORT $LN10@erase@2
$LN11@erase@2:
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR __First_arg$[esp+16]
$LN10@erase@2:

; 1035 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	esi, DWORD PTR __Last_arg$[esp+16]
	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [ebp], ecx
	mov	DWORD PTR [ebp+4], eax
	cmp	DWORD PTR [ebx+12], esi
	ja	SHORT $LN30@erase@2
	cmp	esi, DWORD PTR [ebx+16]
	jbe	SHORT $LN29@erase@2
$LN30@erase@2:
	call	__invalid_parameter_noinfo
	mov	esi, DWORD PTR __Last_arg$[esp+16]
$LN29@erase@2:

; 1036 : 
; 1037 : 		if (_First != _Last)

	mov	eax, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN47@erase@2
	cmp	eax, ecx
	je	SHORT $LN46@erase@2
$LN47@erase@2:
	call	__invalid_parameter_noinfo
$LN46@erase@2:
	mov	ecx, DWORD PTR [ebp+4]
	cmp	ecx, esi
	je	SHORT $LN82@erase@2

; 1038 : 			{	// worth doing, copy down over hole
; 1039 : 
; 1040 :  #if _HAS_ITERATOR_DEBUGGING
; 1041 : 			if (_Last < _First || _First._Mycont != this
; 1042 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1043 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));
; 1046 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1047 : 
; 1048 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1049 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1050 : 				_VEC_ITER_BASE(_First));

	mov	edi, DWORD PTR [ebx+16]
	mov	edx, edi
	sub	edx, esi
	sar	edx, 4
	shl	edx, 4
	add	edx, ecx
	mov	eax, esi
	cmp	esi, edi
	je	SHORT $LN75@erase@2
	sub	ecx, esi
	npad	3
$LL77@erase@2:
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [ecx+eax], esi
	mov	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+eax+4], esi
	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+eax+8], esi
	mov	esi, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+eax+12], esi
	add	eax, 16					; 00000010H
	cmp	eax, edi
	jne	SHORT $LL77@erase@2
$LN75@erase@2:

; 1051 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1052 : 
; 1053 : 			_Destroy(_Ptr, _Mylast);
; 1054 : 			_Mylast = _Ptr;

	mov	DWORD PTR [ebx+16], edx
$LN82@erase@2:

; 1055 : 			}
; 1056 : #if _HAS_ITERATOR_DEBUGGING
; 1057 :         return (iterator(_First._Myptr, this));
; 1058 : #else
; 1059 : 		return (_First);
; 1060 : #endif
; 1061 : 		}

	pop	edi
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx
	ret	24					; 00000018H
?erase@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@0@Z ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
??E?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator++, COMDAT
; _this$ = esi
; ___$ReturnUdt$ = edi

; 355  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ecx

; 356  : 		++*this;

	test	eax, eax
	jne	SHORT $LN23@operator@23
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN19@operator@23
$LN23@operator@23:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN20@operator@23
$LN19@operator@23:
	xor	eax, eax
$LN20@operator@23:
	mov	edx, DWORD PTR [esi+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN24@operator@23
	call	__invalid_parameter_noinfo
$LN24@operator@23:
	add	DWORD PTR [esi+4], 16			; 00000010H

; 357  : 		return (_Tmp);

	mov	eax, edi

; 358  : 		}

	ret	0
??E?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?clear@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
$T296199 = -12						; size = 8
?clear@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXXZ PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::clear, COMDAT
; _this$ = esi

; 1064 : 		{	// erase all

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp

; 1065 : 		erase(begin(), end());

	mov	ebp, DWORD PTR [esi+16]
	push	edi
	cmp	DWORD PTR [esi+12], ebp
	jbe	SHORT $LN9@clear@2
	call	__invalid_parameter_noinfo
$LN9@clear@2:
	mov	edi, DWORD PTR [esi+12]
	mov	ebx, DWORD PTR [esi]
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN28@clear@2
	call	__invalid_parameter_noinfo
$LN28@clear@2:
	mov	eax, DWORD PTR [esi]
	push	ebp
	push	ebx
	push	edi
	push	eax
	lea	eax, DWORD PTR $T296199[esp+44]
	push	eax
	push	esi
	call	?erase@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@0@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::erase

; 1066 : 		}

	pop	edi
	pop	ebp
	pop	ebx
	add	esp, 16					; 00000010H
	ret	0
?clear@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXXZ ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7logic_error@std@@6B@
	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $LN24@scalar@12
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN24@scalar@12:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	ecx, esi
	mov	BYTE PTR [esi+16], al
	call	??1exception@std@@UAE@XZ		; std::exception::~exception
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $LN34@scalar@12
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN34@scalar@12:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T317445 = -80						; size = 28
$T317444 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ PROC	; std::vector<int,std::allocator<int> >::_Xlen, COMDAT

; 1257 : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 72					; 00000048H

; 1258 : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T317445[esp+92]
	mov	DWORD PTR $T317445[esp+116], 15		; 0000000fH
	mov	DWORD PTR $T317445[esp+112], 0
	mov	BYTE PTR $T317445[esp+96], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T317445[esp+84]
	push	eax
	lea	ecx, DWORD PTR $T317444[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T317444[esp+88]
	push	ecx
	mov	DWORD PTR $T317444[esp+92], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen:
$LN44@Xlen:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T317445[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ENDP	; std::vector<int,std::allocator<int> >::_Xlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z
_TEXT	SEGMENT
__Newvec$132602 = 8					; size = 4
_this$ = 8						; size = 4
__Tmp$132614 = 12					; size = 4
__Val$ = 12						; size = 4
__Where$ = 16						; size = 8
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z PROC ; std::vector<int,std::allocator<int> >::_Insert_n, COMDAT

; 1158 : 		{	// insert _Count * _Val at _Where

	push	ecx
	mov	edx, DWORD PTR __Val$[esp]
	push	ebx
	mov	ebx, DWORD PTR _this$[esp+4]

; 1159 : 
; 1160 :  #if _HAS_ITERATOR_DEBUGGING
; 1161 : 		if (_Where._Mycont != this
; 1162 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1163 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1164 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1165 : 
; 1166 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR [ebx+12]
	push	ebp
	push	esi
	push	edi
	test	ecx, ecx
	jne	SHORT $LN27@Insert_n
	xor	ebp, ebp
	jmp	SHORT $LN174@Insert_n
$LN27@Insert_n:
	mov	ebp, DWORD PTR [ebx+20]
	sub	ebp, ecx
	sar	ebp, 2
$LN174@Insert_n:

; 1167 : 
; 1168 : 		if (_Count == 0)
; 1169 : 			;
; 1170 : 		else if (max_size() - size() < _Count)

	mov	esi, DWORD PTR [ebx+16]
	mov	eax, esi
	sub	eax, ecx
	sar	eax, 2
	mov	ecx, 1073741823				; 3fffffffH
	sub	ecx, eax
	cmp	ecx, 1
	jae	SHORT $LN10@Insert_n

; 1171 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN176@Insert_n:
$LN10@Insert_n:

; 1172 : 		else if (_Capacity < size() + _Count)

	inc	eax
	cmp	ebp, eax
	jae	$LN8@Insert_n

; 1173 : 			{	// not enough room, reallocate
; 1174 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1175 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, ebp
	shr	ecx, 1
	mov	edx, 1073741823				; 3fffffffH
	sub	edx, ecx
	cmp	edx, ebp
	jae	SHORT $LN15@Insert_n
	xor	ebp, ebp
	jmp	SHORT $LN16@Insert_n
$LN15@Insert_n:
	add	ebp, ecx
$LN16@Insert_n:

; 1176 : 			if (_Capacity < size() + _Count)

	cmp	ebp, eax
	jae	SHORT $LN7@Insert_n

; 1177 : 				_Capacity = size() + _Count;

	mov	ebp, eax
$LN7@Insert_n:

; 1178 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, ebp
	call	?allocate@?$allocator@H@std@@QAEPAHI@Z	; std::allocator<int>::allocate

; 1179 : 			pointer _Ptr = _Newvec;
; 1180 : 
; 1181 : 			_TRY_BEGIN
; 1182 : 			_Ptr = _Umove(_Myfirst, _VEC_ITER_BASE(_Where),
; 1183 : 				_Newvec);	// copy prefix

	mov	esi, DWORD PTR [ebx+12]
	mov	edx, eax
	mov	eax, DWORD PTR __Where$[esp+20]
	sub	eax, esi
	sar	eax, 2
	lea	ecx, DWORD PTR [eax*4]
	mov	DWORD PTR __Newvec$132602[esp+16], edx
	lea	edi, DWORD PTR [ecx+edx]
	test	eax, eax
	jbe	SHORT $LN77@Insert_n
	push	ecx
	push	esi
	push	ecx
	push	edx
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN77@Insert_n:

; 1184 : 			_Ptr = _Ufill(_Ptr, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Val$[esp+16]
	mov	esi, 1
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1185 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

	mov	ecx, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR __Where$[esp+20]
	sub	ecx, edx
	sar	ecx, 2
	test	ecx, ecx
	jbe	SHORT $LN108@Insert_n
	add	ecx, ecx
	add	ecx, ecx
	push	ecx
	push	edx
	push	ecx
	push	eax
	call	_memmove_s
	add	esp, 16					; 00000010H
$LN108@Insert_n:

; 1186 : 			_CATCH_ALL
; 1187 : 			_Destroy(_Newvec, _Ptr);
; 1188 : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 1189 : 			_RERAISE;
; 1190 : 			_CATCH_END
; 1191 : 
; 1192 : 			_Count += size();

	mov	eax, DWORD PTR [ebx+12]
	mov	esi, DWORD PTR [ebx+16]
	sub	esi, eax
	sar	esi, 2
	inc	esi

; 1193 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN115@Insert_n

; 1194 : 				{	// destroy and deallocate old array
; 1195 : 				_Destroy(_Myfirst, _Mylast);
; 1196 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN115@Insert_n:

; 1197 : 				}
; 1198 : 
; 1199 :  #if _HAS_ITERATOR_DEBUGGING
; 1200 : 			this->_Orphan_all();
; 1201 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1202 : 
; 1203 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Newvec$132602[esp+16]
	lea	ecx, DWORD PTR [eax+ebp*4]

; 1204 : 			_Mylast = _Newvec + _Count;

	lea	edx, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [ebx+20], ecx
	mov	DWORD PTR [ebx+16], edx

; 1205 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [ebx+12], eax

; 1247 : 			}
; 1248 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	16					; 00000010H
$LN8@Insert_n:

; 1206 : 			}
; 1207 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR __Where$[esp+20]

; 1208 : 			{	// new stuff spills off end
; 1209 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ebp, DWORD PTR [edx]
	mov	eax, esi
	sub	eax, ecx
	sar	eax, 2
	cmp	eax, 1

; 1210 : 
; 1211 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1212 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, esi
	jae	SHORT $LN3@Insert_n
	lea	edx, DWORD PTR [ecx+4]
	mov	edi, ecx
	mov	DWORD PTR __Tmp$132614[esp+16], ebp
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>

; 1213 : 
; 1214 : 			_TRY_BEGIN
; 1215 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1216 : 				_Tmp);	// insert new stuff off end

	mov	edi, DWORD PTR [ebx+16]
	mov	ecx, edi
	sub	ecx, DWORD PTR __Where$[esp+20]
	mov	esi, 1
	sar	ecx, 2
	sub	esi, ecx
	lea	edx, DWORD PTR __Tmp$132614[esp+16]
	call	?_Ufill@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAHIABH@Z ; std::vector<int,std::allocator<int> >::_Ufill

; 1217 : 			_CATCH_ALL
; 1218 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1219 : 			_RERAISE;
; 1220 : 			_CATCH_END
; 1221 : 
; 1222 : 			_Mylast += _Count;

	add	DWORD PTR [ebx+16], 4
	mov	ebx, DWORD PTR [ebx+16]

; 1223 : 
; 1224 :  #if _HAS_ITERATOR_DEBUGGING
; 1225 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1226 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1227 : 
; 1228 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1229 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[esp+20]
	lea	ecx, DWORD PTR [ebx-4]
	cmp	eax, ecx
	je	SHORT $LN163@Insert_n
$LL129@Insert_n:
	mov	DWORD PTR [eax], ebp
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL129@Insert_n

; 1247 : 			}
; 1248 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	16					; 00000010H
$LN3@Insert_n:

; 1230 : 			}
; 1231 : 		else
; 1232 : 			{	// new stuff can all be assigned
; 1233 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1234 : 
; 1235 : 			pointer _Oldend = _Mylast;
; 1236 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1237 : 				_Mylast);	// copy suffix

	lea	edi, DWORD PTR [esi-4]
	mov	edx, esi
	call	??$_Umove@PAH@?$vector@HV?$allocator@H@std@@@std@@IAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove<int *>
	mov	DWORD PTR [ebx+16], eax

; 1238 : 
; 1239 :  #if _HAS_ITERATOR_DEBUGGING
; 1240 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1241 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1242 : 
; 1243 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1244 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Where$[esp+20]
	sub	edi, eax
	sar	edi, 2
	test	edi, edi
	jle	SHORT $LN150@Insert_n
	lea	ecx, DWORD PTR [edi*4]
	push	ecx
	push	eax
	push	ecx
	sub	esi, ecx
	push	esi
	call	_memmove_s
	mov	eax, DWORD PTR __Where$[esp+36]
	add	esp, 16					; 00000010H
$LN150@Insert_n:

; 1245 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1246 : 				_Tmp);	// insert into hole

	lea	ecx, DWORD PTR [eax+4]
	cmp	eax, ecx
	je	SHORT $LN163@Insert_n
	npad	1
$LL165@Insert_n:
	mov	DWORD PTR [eax], ebp
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $LL165@Insert_n
$LN163@Insert_n:

; 1247 : 			}
; 1248 : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	pop	ecx
	ret	16					; 00000010H
$LN175@Insert_n:
?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Insert_n
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z PROC	; std::vector<int,std::allocator<int> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = edi

; 1107 : 		{	// allocate array with _Capacity elements

	push	ecx

; 1108 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1109 : 		if (_Capacity == 0)
; 1110 : 			return (false);
; 1111 : 		else if (max_size() < _Capacity)

	cmp	edi, 1073741823				; 3fffffffH
	jbe	SHORT $LN2@Buy

; 1112 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@HV?$allocator@H@std@@@std@@KAXXZ ; std::vector<int,std::allocator<int> >::_Xlen
$LN18@Buy:
$LN2@Buy:

; 1113 : 		else
; 1114 : 			{	// nonempty array, allocate storage
; 1115 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, edi
	call	?allocate@?$allocator@H@std@@QAEPAHI@Z	; std::allocator<int>::allocate
	mov	DWORD PTR [esi+12], eax

; 1116 : 			_Mylast = _Myfirst;

	mov	DWORD PTR [esi+16], eax

; 1117 : 			_Myend = _Myfirst + _Capacity;

	lea	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [esi+20], eax

; 1118 : 			}
; 1119 : 		return (true);

	mov	al, 1
	pop	ecx

; 1120 : 		}

	ret	0
$LN17@Buy:
?_Buy@?$vector@HV?$allocator@H@std@@@std@@IAE_NI@Z ENDP	; std::vector<int,std::allocator<int> >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z
_TEXT	SEGMENT
__Tmp$318598 = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
__Where$ = 16						; size = 8
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z PROC ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = eax

; 875  : 		{	// insert _Val at _Where

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, eax

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [esi+16]
	push	edi
	mov	edi, DWORD PTR [esi+12]
	mov	ecx, eax
	sub	ecx, edi
	test	ecx, -4					; fffffffcH
	jne	SHORT $LN3@insert
	xor	ebx, ebx
	jmp	SHORT $LN4@insert
$LN3@insert:
	cmp	edi, eax
	jbe	SHORT $LN13@insert
	call	__invalid_parameter_noinfo
$LN13@insert:
	mov	ecx, DWORD PTR __Where$[esp+24]
	mov	eax, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN29@insert
	cmp	ecx, eax
	je	SHORT $LN28@insert
$LN29@insert:
	call	__invalid_parameter_noinfo
$LN28@insert:
	mov	ebx, DWORD PTR __Where$[esp+28]
	sub	ebx, edi
	sar	ebx, 2
$LN4@insert:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Where$[esp+28]
	mov	eax, DWORD PTR __Where$[esp+24]
	mov	ecx, DWORD PTR __Val$[esp+24]
	push	edx
	push	eax
	push	ecx
	push	esi
	call	?_Insert_n@?$vector@HV?$allocator@H@std@@@std@@IAEXV?$_Vector_const_iterator@HV?$allocator@H@std@@@2@IABH@Z ; std::vector<int,std::allocator<int> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edi, DWORD PTR [esi+12]
	cmp	edi, DWORD PTR [esi+16]
	jbe	SHORT $LN43@insert
	call	__invalid_parameter_noinfo
$LN43@insert:
	mov	esi, DWORD PTR [esi]
	mov	ebp, esi
	mov	DWORD PTR __Tmp$318598[esp+32], edi
	test	esi, esi
	jne	SHORT $LN85@insert
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN76@insert:
	lea	edi, DWORD PTR [edi+ebx*4]
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN63@insert
	test	esi, esi
	je	SHORT $LN81@insert
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN82@insert
$LN85@insert:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN76@insert
$LN81@insert:
	xor	esi, esi
$LN82@insert:
	cmp	edi, DWORD PTR [esi+12]
	jae	SHORT $LN62@insert
$LN63@insert:
	call	__invalid_parameter_noinfo
$LN62@insert:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	DWORD PTR [eax+4], edi

; 879  : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ebp
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	16					; 00000010H
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@KAXXZ
_TEXT	SEGMENT
$T318604 = -84						; size = 28
$T318603 = -56						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@KAXXZ PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Xlen, COMDAT

; 1257 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?_Xlen@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 76					; 0000004cH

; 1258 : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T318604[esp+96]
	mov	DWORD PTR $T318604[esp+120], 15		; 0000000fH
	mov	DWORD PTR $T318604[esp+116], 0
	mov	BYTE PTR $T318604[esp+100], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	eax, DWORD PTR $T318604[esp+88]
	push	eax
	lea	ecx, DWORD PTR $T318603[esp+92]
	mov	DWORD PTR __$EHRec$[esp+100], 0
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T318603[esp+92]
	push	ecx
	mov	DWORD PTR $T318603[esp+96], OFFSET ??_7length_error@std@@6B@
	call	__CxxThrowException@8
$LN45@Xlen@2:
$LN44@Xlen@2:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T318604[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Xlen@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@KAXXZ:
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@KAXXZ ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Xlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAE_NI@Z PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Buy, COMDAT
; _this$ = edi
; __Capacity$ = eax

; 1107 : 		{	// allocate array with _Capacity elements

	push	esi
	mov	esi, eax

; 1108 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;
; 1109 : 		if (_Capacity == 0)
; 1110 : 			return (false);
; 1111 : 		else if (max_size() < _Capacity)

	cmp	esi, 268435455				; 0fffffffH
	jbe	SHORT $LN2@Buy@2

; 1112 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@KAXXZ ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Xlen
$LN18@Buy@2:
$LN2@Buy@2:

; 1113 : 		else
; 1114 : 			{	// nonempty array, allocate storage
; 1115 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	ecx, esi
	call	?allocate@?$allocator@U?$pair@_K_K@std@@@std@@QAEPAU?$pair@_K_K@2@I@Z ; std::allocator<std::pair<unsigned __int64,unsigned __int64> >::allocate

; 1116 : 			_Mylast = _Myfirst;
; 1117 : 			_Myend = _Myfirst + _Capacity;

	shl	esi, 4
	add	esi, eax
	mov	DWORD PTR [edi+12], eax
	mov	DWORD PTR [edi+16], eax
	mov	DWORD PTR [edi+20], esi

; 1118 : 			}
; 1119 : 		return (true);

	mov	al, 1

; 1120 : 		}

	pop	esi
	ret	0
$LN17@Buy@2:
?_Buy@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAE_NI@Z ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T318948 = -8						; size = 8
__Right$ = 8						; size = 4
??4?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator=, COMDAT
; _this$ = eax

; 563  : 		{	// assign _Right

	sub	esp, 8
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Right$[esp+12]
	push	esi
	push	edi
	mov	edi, eax

; 564  : 		if (this != &_Right)

	cmp	edi, ebp
	je	$LN1@operator@25

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	esi, DWORD PTR [ebp+16]
	mov	ebx, DWORD PTR [ebp+12]
	mov	ecx, esi
	sub	ecx, ebx
	sar	ecx, 4
	test	ecx, ecx
	jne	SHORT $LN8@operator@25

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ebp, DWORD PTR [edi+16]
	cmp	DWORD PTR [edi+12], ebp
	jbe	SHORT $LN22@operator@25
	call	__invalid_parameter_noinfo
$LN22@operator@25:
	mov	esi, DWORD PTR [edi+12]
	mov	ebx, DWORD PTR [edi]
	cmp	esi, DWORD PTR [edi+16]
	jbe	SHORT $LN41@operator@25
	call	__invalid_parameter_noinfo
$LN41@operator@25:
	mov	eax, DWORD PTR [edi]
	push	ebp
	push	ebx
	push	esi
	push	eax
	lea	eax, DWORD PTR $T318948[esp+40]
	push	eax
	push	edi
	call	?erase@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@0@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::erase

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, edi

; 599  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	4
$LN8@operator@25:

; 573  : 			else if (_Right.size() <= size())

	mov	edx, DWORD PTR [edi+12]
	mov	eax, DWORD PTR [edi+16]
	sub	eax, edx
	sar	eax, 4
	cmp	ecx, eax
	ja	SHORT $LN6@operator@25

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, ebx
	call	??$unchecked_copy@PAU?$pair@_K_K@std@@PAU12@@stdext@@YAPAU?$pair@_K_K@std@@PAU12@00@Z ; stdext::unchecked_copy<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *>

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old
; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR [ebp+16]
	sub	ecx, DWORD PTR [ebp+12]

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, edi
	sar	ecx, 4
	shl	ecx, 4
	add	ecx, DWORD PTR [edi+12]
	mov	DWORD PTR [edi+16], ecx

; 599  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	4
$LN6@operator@25:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	xor	ebx, ebx
	cmp	edx, ebx
	jne	SHORT $LN64@operator@25
	xor	esi, esi
	jmp	SHORT $LN65@operator@25
$LN64@operator@25:
	mov	esi, DWORD PTR [edi+20]
	sub	esi, edx
	sar	esi, 4
$LN65@operator@25:
	cmp	ecx, esi
	ja	SHORT $LN4@operator@25

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR [ebp+12]
	shl	eax, 4
	add	eax, ecx
	mov	esi, eax

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	call	??$unchecked_copy@PAU?$pair@_K_K@std@@PAU12@@stdext@@YAPAU?$pair@_K_K@std@@PAU12@00@Z ; stdext::unchecked_copy<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *>

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR [edi+16]
	mov	eax, DWORD PTR [ebp+16]
	push	edx
	push	eax
	mov	edx, esi

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	call	??$_Ucopy@PAU?$pair@_K_K@std@@@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEPAU?$pair@_K_K@1@PAU21@00@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Ucopy<std::pair<unsigned __int64,unsigned __int64> *>
	mov	DWORD PTR [edi+16], eax

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, edi

; 599  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	4
$LN4@operator@25:

; 585  : 				}
; 586  : 			else
; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	cmp	edx, ebx
	je	SHORT $LN68@operator@25

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);
; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN68@operator@25:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	eax, DWORD PTR [ebp+16]
	sub	eax, DWORD PTR [ebp+12]
	mov	DWORD PTR [edi+12], ebx
	sar	eax, 4
	mov	DWORD PTR [edi+16], ebx
	mov	DWORD PTR [edi+20], ebx
	cmp	eax, ebx
	je	SHORT $LN84@operator@25
	call	?_Buy@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAE_NI@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Buy
	test	al, al
	je	SHORT $LN84@operator@25

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [ebp+16]
	push	ecx
	push	edx
	mov	edx, DWORD PTR [ebp+12]
	call	??$_Ucopy@PAU?$pair@_K_K@std@@@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEPAU?$pair@_K_K@1@PAU21@00@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Ucopy<std::pair<unsigned __int64,unsigned __int64> *>
	mov	DWORD PTR [edi+16], eax
$LN84@operator@25:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, edi
$LN1@operator@25:

; 599  : 		}

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 8
	ret	4
??4?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::operator=
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__catchsym$??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@ABV01@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@ABV01@@Z$5
__ehfuncinfo$??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T319232 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Cat$319375 = 8					; size = 1
_this$ = 8						; size = 4
$T319372 = 12						; size = 1
__Right$ = 12						; size = 4
??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@ABV01@@Z PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >, COMDAT

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _this$[ebp]
	mov	DWORD PTR __$EHRec$[ebp], esp
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN19@vector@3
	mov	DWORD PTR [eax], edi
	jmp	SHORT $LN20@vector@3
$LN19@vector@3:
	xor	eax, eax
$LN20@vector@3:
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR __$EHRec$[ebp+12], ecx

; 501  : 		if (_Buy(_Right.size()))

	mov	esi, DWORD PTR [ebx+16]
	sub	esi, DWORD PTR [ebx+12]
	mov	DWORD PTR [edi+12], ecx
	sar	esi, 4
	mov	DWORD PTR [edi+16], ecx
	mov	DWORD PTR [edi+20], ecx
	cmp	esi, ecx
	je	SHORT $LN8@vector@3
	cmp	esi, 268435455				; 0fffffffH
	jbe	SHORT $LN46@vector@3
	call	?_Xlen@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@KAXXZ ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Xlen
$LN113@vector@3:
$LN46@vector@3:
	mov	ecx, esi
	call	?allocate@?$allocator@U?$pair@_K_K@std@@@std@@QAEPAU?$pair@_K_K@2@I@Z ; std::allocator<std::pair<unsigned __int64,unsigned __int64> >::allocate
	shl	esi, 4
	add	esi, eax
	mov	DWORD PTR [edi+12], eax
	mov	DWORD PTR [edi+16], eax
	mov	DWORD PTR [edi+20], esi

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR $T319232[ebp], eax
	cmp	DWORD PTR [ebx+12], eax
	jbe	SHORT $LN61@vector@3
	call	__invalid_parameter_noinfo
$LN61@vector@3:
	mov	esi, DWORD PTR [ebx+12]
	cmp	esi, DWORD PTR [ebx+16]
	jbe	SHORT $LN78@vector@3
	call	__invalid_parameter_noinfo
$LN78@vector@3:
	mov	edx, DWORD PTR __Cat$319375[ebp]
	mov	eax, DWORD PTR [edi+12]
	mov	BYTE PTR $T319372[ebp], 0
	mov	ecx, DWORD PTR $T319372[ebp]
	push	ecx
	push	edx
	mov	edx, DWORD PTR $T319232[ebp]
	push	esi
	call	??$_Uninit_copy@PBU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAPAU?$pair@_K_K@0@PBU10@0PAU10@AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned __int64,unsigned __int64> const *,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [edi+16], eax
$LN8@vector@3:

; 507  : 			_CATCH_END
; 508  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	esi, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXXZ ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN114@vector@3:
$LN112@vector@3:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@ABV01@@Z$2:
	mov	eax, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ
__ehhandler$??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@ABV01@@Z ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
; Function compile flags: /Ogtpy
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
$T319412 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = edi

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [edi+12]
	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR __Val$[esp+8]
	push	esi
	test	ecx, ecx
	jne	SHORT $LN9@push_back
	xor	eax, eax
	jmp	SHORT $LN10@push_back
$LN9@push_back:
	mov	eax, DWORD PTR [edi+20]
	sub	eax, ecx
	sar	eax, 2
$LN10@push_back:
	mov	esi, DWORD PTR [edi+16]
	mov	edx, esi
	sub	edx, ecx
	sar	edx, 2
	cmp	edx, eax
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi], eax
	add	esi, 4
	mov	DWORD PTR [edi+16], esi

; 824  : 		}

	pop	esi
	pop	ebx
	add	esp, 8
	ret	4
$LN2@push_back:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	cmp	ecx, esi
	jbe	SHORT $LN40@push_back
	call	__invalid_parameter_noinfo
$LN40@push_back:
	mov	eax, DWORD PTR [edi]
	push	esi
	push	eax
	push	ebx
	lea	ecx, DWORD PTR $T319412[esp+28]
	push	ecx
	mov	eax, edi
	call	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert

; 824  : 		}

	pop	esi
	pop	ebx
	add	esp, 8
	ret	4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT

; 470  : 		{	// construct empty vector

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, DWORD PTR _this$[esp+12]
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN13@vector@4
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@4
$LN13@vector@4:
	xor	eax, eax
$LN14@vector@4:
	mov	DWORD PTR [esi], eax

; 471  : 		_Buy(0);

	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx

; 472  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Ogtpy
;	COMDAT ?swap@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
?swap@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXAAV12@@Z PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::swap, COMDAT
; _this$ = eax
; __Right$ = edx

; 1069 : 		{	// exchange contents with _Right

	push	ebx
	push	esi
	push	edi

; 1070 : 		if (this == &_Right)

	cmp	eax, edx
	je	SHORT $LN24@swap@5

; 1071 : 			;	// same object, do nothing
; 1072 : 		else if (this->_Alval == _Right._Alval)
; 1073 : 			{	// same allocator, swap control information
; 1074 : 
; 1075 :  #if _HAS_ITERATOR_DEBUGGING
; 1076 : 			this->_Swap_all(_Right);
; 1077 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1078 : 
; 1079 : 			this->_Swap_aux(_Right);

	mov	esi, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [edx], ecx
	mov	esi, DWORD PTR [eax]
	cmp	esi, ecx
	je	SHORT $LN15@swap@5
	mov	ebx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [esi]
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [ecx], edi
$LN15@swap@5:

; 1080 : 
; 1081 : 			std::swap(_Myfirst, _Right._Myfirst);

	lea	ecx, DWORD PTR [edx+12]
	lea	esi, DWORD PTR [eax+12]
	cmp	esi, ecx
	je	SHORT $LN18@swap@5
	mov	ebx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [esi]
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [ecx], edi
$LN18@swap@5:

; 1082 : 			std::swap(_Mylast, _Right._Mylast);

	lea	ecx, DWORD PTR [edx+16]
	lea	esi, DWORD PTR [eax+16]
	cmp	esi, ecx
	je	SHORT $LN21@swap@5
	mov	ebx, DWORD PTR [ecx]
	mov	edi, DWORD PTR [esi]
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [ecx], edi
$LN21@swap@5:

; 1083 : 			std::swap(_Myend, _Right._Myend);

	lea	ecx, DWORD PTR [edx+20]
	add	eax, 20					; 00000014H
	cmp	eax, ecx
	je	SHORT $LN24@swap@5
	mov	esi, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [ecx], edx
$LN24@swap@5:

; 1084 : 			}
; 1085 : 		else
; 1086 : 			{	// different allocator, do multiple assigns
; 1087 : 			this->_Swap_aux(_Right);
; 1088 : 
; 1089 : 			_Myt _Ts = *this;
; 1090 : 
; 1091 : 			*this = _Right;
; 1092 : 			_Right = _Ts;
; 1093 : 			}
; 1094 : 		}

	pop	edi
	pop	esi
	pop	ebx
	ret	0
?swap@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXAAV12@@Z ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::swap
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$?reserve@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?reserve@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?reserve@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXI@Z$0
__tryblocktable$?reserve@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?reserve@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXI@Z$2
__ehfuncinfo$?reserve@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?reserve@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?reserve@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Ptr$131680 = -24					; size = 4
$T320293 = -20						; size = 1
$T320094 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Cat$320296 = 8					; size = 1
__Count$ = 8						; size = 4
?reserve@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXI@Z PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::reserve, COMDAT
; _this$ = ecx

; 602  : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?reserve@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 603  : 		if (max_size() < _Count)

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __$EHRec$[ebp], esp
	cmp	ecx, 268435455				; 0fffffffH
	jbe	SHORT $LN5@reserve

; 604  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@KAXXZ ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Xlen
$LN101@reserve:
$LN5@reserve:

; 605  : 		else if (capacity() < _Count)

	mov	edx, DWORD PTR [edi+12]
	test	edx, edx
	jne	SHORT $LN20@reserve
	xor	eax, eax
	jmp	SHORT $LN21@reserve
$LN20@reserve:
	mov	eax, DWORD PTR [edi+20]
	sub	eax, edx
	sar	eax, 4
$LN21@reserve:
	cmp	eax, ecx
	jae	SHORT $LN3@reserve

; 606  : 			{	// not enough room, reallocate
; 607  : 			pointer _Ptr = this->_Alval.allocate(_Count);

	call	?allocate@?$allocator@U?$pair@_K_K@std@@@std@@QAEPAU?$pair@_K_K@2@I@Z ; std::allocator<std::pair<unsigned __int64,unsigned __int64> >::allocate

; 608  : 
; 609  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 610  : 			_Umove(begin(), end(), _Ptr);

	mov	esi, DWORD PTR [edi+16]
	mov	ebx, eax
	mov	DWORD PTR __Ptr$131680[ebp], ebx
	cmp	DWORD PTR [edi+12], esi
	jbe	SHORT $LN28@reserve
	call	__invalid_parameter_noinfo
$LN28@reserve:
	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR $T320094[ebp], eax
	cmp	eax, DWORD PTR [edi+16]
	jbe	SHORT $LN47@reserve
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR $T320094[ebp]
$LN47@reserve:
	mov	edx, DWORD PTR __Cat$320296[ebp]
	mov	BYTE PTR $T320293[ebp], 0
	mov	ecx, DWORD PTR $T320293[ebp]
	push	ecx
	push	edx
	push	eax
	mov	eax, ebx
	mov	edx, esi
	call	??$_Uninit_copy@PAU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 614  : 			_CATCH_END
; 615  : 
; 616  : 			size_type _Size = size();

	mov	eax, DWORD PTR [edi+12]
	mov	esi, DWORD PTR [edi+16]
	sub	esi, eax
	add	esp, 12					; 0000000cH
	sar	esi, 4

; 617  : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN96@reserve

; 618  : 				{	// destroy and deallocate old array
; 619  : 				_Destroy(_Myfirst, _Mylast);
; 620  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN96@reserve:

; 621  : 				}
; 622  : 
; 623  :  #if _HAS_ITERATOR_DEBUGGING
; 624  : 			this->_Orphan_all();
; 625  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 626  : 
; 627  : 			_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 4
	add	eax, ebx

; 628  : 			_Mylast = _Ptr + _Size;

	shl	esi, 4
	add	esi, ebx
	mov	DWORD PTR [edi+20], eax
	mov	DWORD PTR [edi+16], esi

; 629  : 			_Myfirst = _Ptr;

	mov	DWORD PTR [edi+12], ebx
$LN3@reserve:

; 630  : 			}
; 631  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
__catch$?reserve@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXI@Z$0:

; 611  : 			_CATCH_ALL
; 612  : 			this->_Alval.deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Ptr$131680[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 613  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN102@reserve:
$LN100@reserve:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXI@Z:
	mov	eax, OFFSET __ehfuncinfo$?reserve@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?reserve@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXI@Z ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::reserve
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >, COMDAT

; 470  : 		{	// construct empty vector

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	push	esi
	mov	esi, DWORD PTR _this$[esp+12]
	push	4
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN13@vector@5
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN14@vector@5
$LN13@vector@5:
	xor	eax, eax
$LN14@vector@5:
	mov	DWORD PTR [esi], eax

; 471  : 		_Buy(0);

	mov	DWORD PTR [esi+12], ecx
	mov	DWORD PTR [esi+16], ecx
	mov	DWORD PTR [esi+20], ecx

; 472  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	eax, esi
	mov	DWORD PTR fs:0, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	jmp	??1?$_Vector_val@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ
__ehhandler$??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
PUBLIC	??0Rasterizer@@QAE@XZ				; Rasterizer::Rasterizer
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
xdata$x	SEGMENT
__unwindtable$??0Rasterizer@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Rasterizer@@QAE@XZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0Rasterizer@@QAE@XZ$0
	DD	01H
	DD	FLAT:__unwindfunclet$??0Rasterizer@@QAE@XZ$5
__ehfuncinfo$??0Rasterizer@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0Rasterizer@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File d:\-=svn=-\svplayer\src\subtitles\rasterizer.cpp
xdata$x	ENDS
;	COMDAT ??0Rasterizer@@QAE@XZ
_TEXT	SEGMENT
$T321038 = -20						; size = 4
$T320789 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0Rasterizer@@QAE@XZ PROC				; Rasterizer::Rasterizer, COMDAT

; 41   : {

	mov	eax, DWORD PTR fs:0
	push	-1
	push	__ehhandler$??0Rasterizer@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, DWORD PTR _this$[esp+24]
	push	edi
	xor	ebx, ebx
	push	4
	mov	DWORD PTR [esi], OFFSET ??_7Rasterizer@@6B@
	mov	DWORD PTR [esi+24], ebx
	mov	DWORD PTR [esi+28], ebx
	mov	DWORD PTR [esi+32], ebx
	lea	edi, DWORD PTR [esi+44]
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN21@Rasterizer@2
	mov	DWORD PTR [eax], edi
	jmp	SHORT $LN22@Rasterizer@2
$LN21@Rasterizer@2:
	xor	eax, eax
$LN22@Rasterizer@2:
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+12], ebx
	mov	DWORD PTR [edi+16], ebx
	mov	DWORD PTR [edi+20], ebx
	push	4
	mov	DWORD PTR __$EHRec$[esp+44], 1
	lea	edi, DWORD PTR [esi+68]
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebx
	je	SHORT $LN81@Rasterizer@2
	mov	DWORD PTR [eax], edi
	jmp	SHORT $LN82@Rasterizer@2
$LN81@Rasterizer@2:
	xor	eax, eax
$LN82@Rasterizer@2:
	mov	DWORD PTR [edi], eax

; 42   : 	mOverlayWidth = mOverlayHeight = 0;
; 43   : 	mPathOffsetX = mPathOffsetY = 0;
; 44   : 	mOffsetX = mOffsetY = 0;
; 45   : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	DWORD PTR [edi+12], ebx
	mov	DWORD PTR [edi+16], ebx
	mov	DWORD PTR [edi+20], ebx
	mov	DWORD PTR [esi+112], ebx
	mov	DWORD PTR [esi+120], ebx
	mov	DWORD PTR [esi+116], ebx
	mov	DWORD PTR [esi+128], ebx
	mov	DWORD PTR [esi+124], ebx
	mov	DWORD PTR [esi+136], ebx
	mov	DWORD PTR [esi+132], ebx
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Rasterizer@@QAE@XZ$2:
	mov	eax, DWORD PTR $T320789[ebp]
	jmp	??1?$_Vector_val@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ
__unwindfunclet$??0Rasterizer@@QAE@XZ$0:
	mov	eax, DWORD PTR _this$[ebp-4]
	add	eax, 44					; 0000002cH
	push	eax
	call	??1?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::~vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
	ret	0
__unwindfunclet$??0Rasterizer@@QAE@XZ$5:
	mov	eax, DWORD PTR $T321038[ebp]
	jmp	??1?$_Vector_val@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ
__ehhandler$??0Rasterizer@@QAE@XZ:
	mov	eax, OFFSET __ehfuncinfo$??0Rasterizer@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Rasterizer@@QAE@XZ ENDP				; Rasterizer::Rasterizer
PUBLIC	?ScanConvert@Rasterizer@ssf@@QAE_NAAVGlyphPath@2@ABVCRect@@@Z ; ssf::Rasterizer::ScanConvert
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?ScanConvert@Rasterizer@ssf@@QAE_NAAVGlyphPath@2@ABVCRect@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ScanConvert@Rasterizer@ssf@@QAE_NAAVGlyphPath@2@ABVCRect@@@Z$0
__ehfuncinfo$?ScanConvert@Rasterizer@ssf@@QAE_NAAVGlyphPath@2@ABVCRect@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ScanConvert@Rasterizer@ssf@@QAE_NAAVGlyphPath@2@ABVCRect@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File d:\-=svn=-\svplayer\src\subtitles\libssf\rasterizer.cpp
xdata$x	ENDS
;	COMDAT ?ScanConvert@Rasterizer@ssf@@QAE_NAAVGlyphPath@2@ABVCRect@@@Z
_TEXT	SEGMENT
_lastmoveto$ = -100					; size = 4
_miny$ = -100						; size = 4
_x1$134159 = -96					; size = 4
_type$ = -96						; size = 4
$T338261 = -92						; size = 4
_j$133578 = -92						; size = 4
_itX1$134151 = -88					; size = 8
$T337499 = -88						; size = 4
$T337498 = -88						; size = 4
$T337494 = -88						; size = 8
_s$134170 = -80						; size = 16
$T337500 = -80						; size = 8
$T338615 = -60						; size = 8
$T337501 = -60						; size = 8
$T337829 = -52						; size = 8
$T337502 = -52						; size = 8
_itX2$134157 = -44					; size = 8
$T337503 = -44						; size = 8
_heap$ = -36						; size = 24
__$EHRec$ = -12						; size = 12
tv1699 = 8						; size = 4
_y$133973 = 8						; size = 4
_minx$ = 8						; size = 4
_this$ = 8						; size = 4
tv1697 = 12						; size = 4
_count$133977 = 12					; size = 4
_path$ = 12						; size = 4
?ScanConvert@Rasterizer@ssf@@QAE_NAAVGlyphPath@2@ABVCRect@@@Z PROC ; ssf::Rasterizer::ScanConvert, COMDAT
; _bbox$ = ecx

; 186  : 	{

	push	-1
	push	__ehhandler$?ScanConvert@Rasterizer@ssf@@QAE_NAAVGlyphPath@2@ABVCRect@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax

; 187  : 		// Drop any outlines we may have.
; 188  : 
; 189  : 		mOutline.RemoveAll();
; 190  : 		mWideOutline.RemoveAll();
; 191  : 
; 192  : 		if(path.types.IsEmpty() || path.points.IsEmpty() || bbox.IsRectEmpty())

	mov	eax, DWORD PTR _path$[esp+8]
	mov	DWORD PTR fs:0, esp
	sub	esp, 88					; 00000058H
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+104]
	push	esi
	xor	esi, esi
	mov	DWORD PTR [ebp+40], esi
	mov	DWORD PTR [ebp+60], esi
	push	edi
	mov	edi, ecx
	cmp	DWORD PTR [eax+8], esi
	je	$LN29@ScanConver
	cmp	DWORD PTR [eax+24], esi
	je	$LN29@ScanConver
	push	edi
	call	DWORD PTR __imp__IsRectEmpty@4
	test	eax, eax
	jne	$LN29@ScanConver

; 193  : 		{
; 194  : 			mPathOffsetX = mPathOffsetY = 0;
; 195  : 			mWidth = mHeight = 0;
; 196  : 			return 0;
; 197  : 		}
; 198  : 
; 199  : 		int minx = (bbox.left >> FONT_SCALE) & ~((1<<FONT_SCALE)-1);

	mov	eax, DWORD PTR [edi]

; 200  : 		int miny = (bbox.top >> FONT_SCALE) & ~((1<<FONT_SCALE)-1);

	mov	ecx, DWORD PTR [edi+4]

; 201  : 		int maxx = (bbox.right + ((1<<FONT_SCALE)-1)) >> FONT_SCALE;

	mov	esi, DWORD PTR [edi+8]

; 202  : 		int maxy = (bbox.bottom + ((1<<FONT_SCALE)-1)) >> FONT_SCALE;

	mov	ebx, DWORD PTR [edi+12]
	sar	eax, 3
	and	eax, -8					; fffffff8H
	sar	ecx, 3
	mov	DWORD PTR _minx$[esp+112], eax
	and	ecx, -8					; fffffff8H

; 203  : 
; 204  : 		path.MovePoints(CPoint(-minx*(1<<FONT_SCALE), -miny*(1<<FONT_SCALE)));

	neg	eax
	mov	DWORD PTR _miny$[esp+116], ecx
	add	eax, eax
	neg	ecx
	add	eax, eax
	add	ecx, ecx
	add	eax, eax
	add	ecx, ecx
	mov	DWORD PTR $T337494[esp+116], eax
	mov	eax, DWORD PTR _path$[esp+112]
	add	ecx, ecx
	add	esi, 7
	add	ebx, 7
	lea	edi, DWORD PTR $T337494[esp+116]
	sar	esi, 3
	sar	ebx, 3
	mov	DWORD PTR $T337494[esp+120], ecx
	call	?MovePoints@GlyphPath@ssf@@QAEXABVCPoint@@@Z ; ssf::GlyphPath::MovePoints

; 205  : 
; 206  : 		if(minx > maxx || miny > maxy)

	mov	eax, DWORD PTR _minx$[esp+112]
	cmp	eax, esi
	jg	$LN27@ScanConver
	mov	ecx, DWORD PTR _miny$[esp+116]
	cmp	ecx, ebx
	jg	$LN27@ScanConver

; 211  : 		}
; 212  : 
; 213  : 		mWidth = maxx + 1 - minx;

	sub	esi, eax

; 214  : 		mHeight = maxy + 1 - miny;

	sub	ebx, ecx
	inc	esi
	inc	ebx

; 215  : 
; 216  : 		mPathOffsetX = minx;
; 217  : 		mPathOffsetY = miny;
; 218  : 
; 219  : 		// Initialize edge buffer.  We use edge 0 as a sentinel.
; 220  : 
; 221  : 		mEdgeNext = 1;
; 222  : 		mEdgeHeapSize = 0x10000;
; 223  : 		mpEdgeBuffer = (Edge*)malloc(sizeof(Edge)*mEdgeHeapSize);

	push	524288					; 00080000H
	mov	DWORD PTR [ebp+24], esi
	mov	DWORD PTR [ebp+28], ebx
	mov	DWORD PTR [ebp+124], eax
	mov	DWORD PTR [ebp+128], ecx
	mov	DWORD PTR [ebp+104], 1
	mov	DWORD PTR [ebp+100], 65536		; 00010000H
	call	_malloc
	mov	DWORD PTR [ebp+96], eax

; 224  : 
; 225  : 		// Initialize scanline list.
; 226  : 
; 227  : 		mpScanBuffer = new unsigned int[mHeight];

	mov	eax, DWORD PTR [ebp+28]
	xor	ecx, ecx
	add	esp, 4
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 228  : 		memset(mpScanBuffer, 0, mHeight*sizeof(unsigned int));

	mov	ecx, DWORD PTR [ebp+28]
	add	ecx, ecx
	add	esp, 4
	add	ecx, ecx
	push	ecx
	xor	edi, edi
	push	edi
	push	eax
	mov	DWORD PTR [ebp+108], eax
	call	_memset

; 229  : 
; 230  : 		// Scan convert the outline.  Yuck, Bezier curves....
; 231  : 
; 232  : 		// Unfortunately, Windows 95/98 GDI has a bad habit of giving us text
; 233  : 		// paths with all but the first figure left open, so we can't rely
; 234  : 		// on the PT_CLOSEFIGURE flag being used appropriately.
; 235  : 
; 236  : 		fFirstSet = false;
; 237  : 		firstp.x = firstp.y = 0;
; 238  : 		lastp.x = lastp.y = 0;
; 239  : 
; 240  : 		int lastmoveto = -1;
; 241  : 
; 242  : 		BYTE* type = path.types.GetData();

	mov	eax, DWORD PTR _path$[esp+124]
	mov	BYTE PTR [ebp+4], 0
	mov	DWORD PTR [ebp+12], edi
	mov	DWORD PTR [ebp+8], edi
	mov	DWORD PTR [ebp+20], edi
	mov	DWORD PTR [ebp+16], edi

; 243  : 		POINT* pt = path.points.GetData();
; 244  : 
; 245  : 		for(size_t i = 0, j = path.types.GetCount(); i < j; i++)

	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [eax+20]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lastmoveto$[esp+116], -1
	mov	DWORD PTR _type$[esp+116], edx
	mov	DWORD PTR _j$133578[esp+116], ecx
	cmp	ecx, edi
	jbe	$LN15@ScanConver
	lea	eax, DWORD PTR [esi+8]
	lea	edx, DWORD PTR [esi+16]
	lea	ebx, DWORD PTR [esi-8]
	mov	DWORD PTR tv1697[esp+112], eax
	mov	DWORD PTR tv1699[esp+112], edx
$LN26@ScanConver:

; 246  : 		{
; 247  : 			switch(type[i] & ~PT_CLOSEFIGURE)

	mov	eax, DWORD PTR _type$[esp+116]
	movzx	eax, BYTE PTR [edi+eax]
	and	eax, -2					; fffffffeH
	sub	eax, 2
	je	$LN19@ScanConver
	sub	eax, 2
	je	SHORT $LN17@ScanConver
	sub	eax, 2
	jne	$LN25@ScanConver

; 248  : 			{
; 249  : 			case PT_MOVETO:
; 250  : 				if(lastmoveto >= 0 && firstp != lastp) _EvaluateLine(lastp, firstp);

	cmp	DWORD PTR _lastmoveto$[esp+116], eax
	jl	SHORT $LN20@ScanConver
	mov	ecx, DWORD PTR [ebp+20]
	mov	edx, DWORD PTR [ebp+16]
	push	ecx
	push	edx
	lea	ecx, DWORD PTR [ebp+8]
	call	??9CPoint@@QBEHUtagPOINT@@@Z		; CPoint::operator!=
	test	eax, eax
	je	SHORT $LN20@ScanConver
	mov	eax, DWORD PTR [ebp+12]
	mov	ecx, DWORD PTR [ebp+8]
	mov	edx, DWORD PTR [ebp+20]
	push	eax
	mov	eax, DWORD PTR [ebp+16]
	push	ecx
	push	edx
	push	eax
	mov	ecx, ebp
	call	?_EvaluateLine@Rasterizer@ssf@@AAEXVCPoint@@0@Z ; ssf::Rasterizer::_EvaluateLine
$LN20@ScanConver:

; 251  : 				lastmoveto = i;
; 252  : 				fFirstSet = false;

	mov	BYTE PTR [ebp+4], 0

; 253  : 				lastp = pt[i];

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ebp+16], ecx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR _lastmoveto$[esp+116], edi
	mov	DWORD PTR [ebp+20], edx

; 254  : 				break;

	jmp	$LN25@ScanConver
$LN17@ScanConver:

; 257  : 				break;
; 258  : 			case PT_BEZIERTO:
; 259  : 				if(j - (i-1) >= 4) _EvaluateBezier(pt[i-1], pt[i], pt[i+1], pt[i+2]);

	sub	ecx, edi
	inc	ecx
	cmp	ecx, 4
	jb	SHORT $LN16@ScanConver
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR $T337500[esp+116], eax
	mov	eax, DWORD PTR tv1697[esp+112]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T337500[esp+120], ecx
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR $T337501[esp+116], edx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR $T337501[esp+120], eax
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR $T337502[esp+116], ecx
	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR $T337502[esp+120], edx
	lea	edx, DWORD PTR $T337500[esp+116]
	push	edx
	mov	DWORD PTR $T337503[esp+120], eax
	mov	DWORD PTR $T337503[esp+124], ecx
	lea	eax, DWORD PTR $T337501[esp+120]
	push	eax
	lea	ecx, DWORD PTR $T337502[esp+124]
	push	ecx
	lea	edx, DWORD PTR $T337503[esp+128]
	push	edx
	mov	ecx, ebp
	call	?_EvaluateBezier@Rasterizer@ssf@@AAEXABVCPoint@@000@Z ; ssf::Rasterizer::_EvaluateBezier
$LN16@ScanConver:

; 260  : 				i += 2;

	mov	eax, 16					; 00000010H
	add	DWORD PTR tv1699[esp+112], eax
	add	DWORD PTR tv1697[esp+112], eax
	add	edi, 2
	add	esi, eax
	add	ebx, eax

; 261  : 				break;

	jmp	SHORT $LN25@ScanConver
$LN19@ScanConver:

; 255  : 			case PT_LINETO:
; 256  : 				if(j - (i-1) >= 2) _EvaluateLine(pt[i-1], pt[i]);

	sub	ecx, edi
	inc	ecx
	cmp	ecx, 2
	jb	SHORT $LN25@ScanConver
	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR [ebx]
	mov	edx, DWORD PTR [ebx+4]
	mov	DWORD PTR $T337498[esp+124], esp
	sub	esp, 8
	mov	eax, esp
	mov	DWORD PTR [eax], ecx
	mov	ecx, ebp
	mov	DWORD PTR $T337499[esp+132], esp
	mov	DWORD PTR [eax+4], edx
	call	?_EvaluateLine@Rasterizer@ssf@@AAEXVCPoint@@0@Z ; ssf::Rasterizer::_EvaluateLine
$LN25@ScanConver:
	mov	edx, DWORD PTR tv1699[esp+112]
	mov	ecx, DWORD PTR _j$133578[esp+116]
	add	DWORD PTR tv1697[esp+112], 8
	inc	edi
	add	edx, 8
	add	esi, 8
	add	ebx, 8
	mov	DWORD PTR tv1699[esp+112], edx
	cmp	edi, ecx
	jb	$LN26@ScanConver

; 262  : 			}
; 263  : 		}
; 264  : 
; 265  : 		if(lastmoveto >= 0 && firstp != lastp) _EvaluateLine(lastp, firstp);

	cmp	DWORD PTR _lastmoveto$[esp+116], 0
	jl	SHORT $LN15@ScanConver
	mov	eax, DWORD PTR [ebp+16]
	mov	ecx, DWORD PTR [ebp+20]
	cmp	DWORD PTR [ebp+8], eax
	jne	SHORT $LN68@ScanConver
	cmp	DWORD PTR [ebp+12], ecx
	je	SHORT $LN15@ScanConver
$LN68@ScanConver:
	mov	eax, DWORD PTR [ebp+12]
	mov	ecx, DWORD PTR [ebp+8]
	mov	edx, DWORD PTR [ebp+20]
	push	eax
	mov	eax, DWORD PTR [ebp+16]
	push	ecx
	push	edx
	push	eax
	mov	ecx, ebp
	call	?_EvaluateLine@Rasterizer@ssf@@AAEXVCPoint@@0@Z ; ssf::Rasterizer::_EvaluateLine
$LN15@ScanConver:

; 266  : 
; 267  : 		// Convert the edges to spans.  We couldn't do this before because some of
; 268  : 		// the regions may have winding numbers >+1 and it would have been a pain
; 269  : 		// to try to adjust the spans on the fly.  We use one heap to detangle
; 270  : 		// a scanline's worth of edges from the singly-linked lists, and another
; 271  : 		// to collect the actual scans.
; 272  : 
; 273  : 		std::vector<int> heap;

	lea	ecx, DWORD PTR _heap$[esp+116]
	push	ecx
	call	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[esp+124], ebx

; 274  : 
; 275  : 		mOutline.SetCount(0, mEdgeNext / 2);

	mov	eax, DWORD PTR [ebp+104]
	lea	esi, DWORD PTR [ebp+32]
	shr	eax, 1
	xor	edi, edi
	call	?SetCount@?$Array@TSpan@Rasterizer@ssf@@@ssf@@QAEXII@Z ; ssf::Array<ssf::Rasterizer::Span>::SetCount

; 276  : 
; 277  : 		for(int y = 0; y < mHeight; y++)

	cmp	DWORD PTR [ebp+28], ebx
	mov	DWORD PTR _y$133973[esp+112], ebx
	jle	$LN12@ScanConver
$LN14@ScanConver:

; 278  : 		{
; 279  : 			int count = 0;
; 280  : 
; 281  : 			// Detangle scanline into edge heap.
; 282  : 
; 283  : 			for(unsigned int ptr = mpScanBuffer[y]; ptr; ptr = mpEdgeBuffer[ptr].next)

	mov	eax, DWORD PTR _y$133973[esp+112]
	mov	edx, DWORD PTR [ebp+108]
	mov	esi, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR _heap$[esp+132]
	mov	DWORD PTR _count$133977[esp+112], 0
	test	esi, esi
	je	SHORT $LN9@ScanConver
$LN11@ScanConver:

; 284  : 			{
; 285  : 				heap.push_back(mpEdgeBuffer[ptr].posandflag);

	mov	edx, DWORD PTR _heap$[esp+128]
	mov	ecx, DWORD PTR [ebp+96]
	lea	edi, DWORD PTR [ecx+esi*8+4]
	test	edx, edx
	jne	SHORT $LN78@ScanConver
	xor	ecx, ecx
	jmp	SHORT $LN79@ScanConver
$LN78@ScanConver:
	mov	ecx, DWORD PTR _heap$[esp+136]
	sub	ecx, edx
	sar	ecx, 2
$LN79@ScanConver:
	mov	ebx, eax
	sub	ebx, edx
	sar	ebx, 2
	cmp	ebx, ecx
	jae	SHORT $LN71@ScanConver
	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR [eax], edx
	add	eax, 4
	mov	DWORD PTR _heap$[esp+132], eax
	jmp	SHORT $LN10@ScanConver
$LN71@ScanConver:
	mov	ebx, eax
	cmp	edx, eax
	jbe	SHORT $LN109@ScanConver
	call	__invalid_parameter_noinfo
$LN109@ScanConver:
	mov	eax, DWORD PTR _heap$[esp+116]
	push	ebx
	push	eax
	push	edi
	lea	eax, DWORD PTR $T337829[esp+128]
	push	eax
	lea	eax, DWORD PTR _heap$[esp+132]
	call	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
	mov	eax, DWORD PTR _heap$[esp+132]
$LN10@ScanConver:
	mov	ecx, DWORD PTR [ebp+96]
	mov	esi, DWORD PTR [ecx+esi*8]
	test	esi, esi
	jne	SHORT $LN11@ScanConver
$LN9@ScanConver:

; 286  : 			}
; 287  : 
; 288  : 			// Sort edge heap.  Note that we conveniently made the opening edges
; 289  : 			// one more than closing edges at the same spot, so we won't have any
; 290  : 			// problems with abutting spans.
; 291  : 
; 292  : 			std::sort(heap.begin(), heap.end());

	mov	ecx, DWORD PTR _heap$[esp+128]
	mov	ebx, eax
	cmp	ecx, eax
	jbe	SHORT $LN128@ScanConver
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR _heap$[esp+132]
	mov	ecx, DWORD PTR _heap$[esp+128]
$LN128@ScanConver:
	mov	edi, DWORD PTR _heap$[esp+116]
	mov	esi, ecx
	cmp	ecx, eax
	jbe	SHORT $LN147@ScanConver
	call	__invalid_parameter_noinfo
$LN147@ScanConver:
	test	edi, edi
	je	SHORT $LN167@ScanConver
	cmp	edi, DWORD PTR _heap$[esp+116]
	je	SHORT $LN166@ScanConver
$LN167@ScanConver:
	call	__invalid_parameter_noinfo
$LN166@ScanConver:
	mov	edx, ebx
	sub	edx, esi
	sar	edx, 2
	push	edx
	push	ebx
	push	esi
	call	??$_Sort@PAHH@std@@YAXPAH0H@Z		; std::_Sort<int *,int>

; 293  : 
; 294  : 			// Process edges and add spans.  Since we only check for a non-zero
; 295  : 			// winding number, it doesn't matter which way the outlines go!
; 296  : 
; 297  : 			std::vector<int>::iterator itX1 = heap.begin();

	mov	ecx, DWORD PTR _heap$[esp+140]
	mov	eax, DWORD PTR _heap$[esp+144]
	add	esp, 12					; 0000000cH
	mov	esi, ecx
	cmp	ecx, eax
	jbe	SHORT $LN193@ScanConver
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR _heap$[esp+132]
	mov	ecx, DWORD PTR _heap$[esp+128]
$LN193@ScanConver:
	mov	edi, DWORD PTR _heap$[esp+116]
	mov	DWORD PTR _itX1$134151[esp+116], edi
	mov	DWORD PTR _itX1$134151[esp+120], esi

; 298  : 			std::vector<int>::iterator itX2 = heap.end();

	mov	DWORD PTR $T338261[esp+116], eax
	cmp	ecx, eax
	jbe	SHORT $LN212@ScanConver
	call	__invalid_parameter_noinfo
$LN212@ScanConver:
	mov	eax, DWORD PTR _heap$[esp+116]
	mov	DWORD PTR _itX2$134157[esp+116], eax

; 299  : 
; 300  : 			int x1, x2;
; 301  : 
; 302  : 			for(; itX1 != itX2; ++itX1)

$LL235@ScanConver:
	test	edi, edi
	je	SHORT $LN250@ScanConver
	cmp	edi, DWORD PTR _itX2$134157[esp+116]
	je	SHORT $LN249@ScanConver
$LN250@ScanConver:
	call	__invalid_parameter_noinfo
$LN249@ScanConver:
	cmp	esi, DWORD PTR $T338261[esp+116]
	je	$LN6@ScanConver

; 303  : 			{
; 304  : 				int x = *itX1;

	test	edi, edi
	jne	SHORT $LN340@ScanConver
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN275@ScanConver:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN262@ScanConver
	call	__invalid_parameter_noinfo
$LN262@ScanConver:

; 305  : 
; 306  : 				if(!count) 

	cmp	DWORD PTR _count$133977[esp+112], 0
	mov	ecx, DWORD PTR [esi]
	jne	SHORT $LN343@ScanConver

; 307  : 				{
; 308  : 					x1 = x >> 1;

	mov	ebx, ecx
	sar	ebx, 1
	mov	DWORD PTR _x1$134159[esp+116], ebx
	jmp	SHORT $LN5@ScanConver
$LN340@ScanConver:

; 303  : 			{
; 304  : 				int x = *itX1;

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN275@ScanConver
$LN343@ScanConver:

; 307  : 				{
; 308  : 					x1 = x >> 1;

	mov	ebx, DWORD PTR _x1$134159[esp+116]
$LN5@ScanConver:

; 309  : 				}
; 310  : 
; 311  : 				if(x&1) ++count;

	test	cl, 1
	je	SHORT $LN4@ScanConver
	inc	DWORD PTR _count$133977[esp+112]
	jmp	SHORT $LN3@ScanConver
$LN4@ScanConver:

; 312  : 				else --count;

	dec	DWORD PTR _count$133977[esp+112]
$LN3@ScanConver:

; 313  : 
; 314  : 				if(!count)

	cmp	DWORD PTR _count$133977[esp+112], 0
	jne	$LN7@ScanConver

; 315  : 				{
; 316  : 					x2 = x >> 1;

	sar	ecx, 1

; 317  : 
; 318  : 					if(x2 > x1)

	cmp	ecx, ebx
	jle	$LN7@ScanConver

; 319  : 					{
; 320  : 						Span s(x1, y, x2, y);

	mov	eax, DWORD PTR _y$133973[esp+112]

; 321  : 						s.first += 0x4000000040000000i64;
; 322  : 						s.second += 0x4000000040000000i64;
; 323  : 						mOutline.Add(s);

	mov	esi, DWORD PTR [ebp+40]
	add	ebx, 1073741824				; 40000000H
	mov	edx, eax
	adc	eax, 1073741824				; 40000000H
	add	ecx, 1073741824				; 40000000H
	adc	edx, 1073741824				; 40000000H
	lea	edi, DWORD PTR [esi+1]
	mov	DWORD PTR _s$134170[esp+120], eax
	mov	DWORD PTR _s$134170[esp+124], ecx
	mov	DWORD PTR _s$134170[esp+128], edx
	cmp	edi, DWORD PTR [ebp+44]
	jbe	SHORT $LN282@ScanConver
	mov	eax, DWORD PTR [ebp+48]
	cmp	eax, esi
	ja	SHORT $LN287@ScanConver
	mov	eax, esi
$LN287@ScanConver:
	mov	ecx, DWORD PTR [ebp+36]
	add	eax, edi
	mov	DWORD PTR [ebp+44], eax
	shl	eax, 4
	push	16					; 00000010H
	push	eax
	test	ecx, ecx
	je	SHORT $LN288@ScanConver
	push	ecx
	call	__aligned_realloc
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN289@ScanConver
$LN288@ScanConver:
	call	__aligned_malloc
	add	esp, 8
$LN289@ScanConver:
	mov	edx, DWORD PTR _s$134170[esp+128]
	mov	ecx, DWORD PTR _s$134170[esp+124]
	mov	DWORD PTR [ebp+36], eax
	mov	eax, DWORD PTR _s$134170[esp+120]
$LN282@ScanConver:
	shl	esi, 4
	add	esi, DWORD PTR [ebp+36]
	mov	DWORD PTR [ebp+40], edi
	mov	edi, DWORD PTR _itX1$134151[esp+116]
	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+12], edx
	mov	esi, DWORD PTR _itX1$134151[esp+120]
$LN7@ScanConver:

; 299  : 
; 300  : 			int x1, x2;
; 301  : 
; 302  : 			for(; itX1 != itX2; ++itX1)

	test	edi, edi
	jne	SHORT $LN339@ScanConver
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN242@ScanConver:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN229@ScanConver
	call	__invalid_parameter_noinfo
$LN229@ScanConver:
	add	esi, 4
	mov	DWORD PTR _itX1$134151[esp+120], esi
	jmp	$LL235@ScanConver
$LN339@ScanConver:
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN242@ScanConver
$LN6@ScanConver:

; 324  : 					}
; 325  : 				}
; 326  : 			}
; 327  : 
; 328  : 			heap.clear();

	mov	ecx, DWORD PTR _heap$[esp+132]
	mov	eax, DWORD PTR _heap$[esp+128]
	mov	ebx, ecx
	cmp	eax, ecx
	jbe	SHORT $LN298@ScanConver
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR _heap$[esp+132]
	mov	eax, DWORD PTR _heap$[esp+128]
$LN298@ScanConver:
	mov	esi, DWORD PTR _heap$[esp+116]
	mov	edi, eax
	cmp	eax, ecx
	jbe	SHORT $LN317@ScanConver
	call	__invalid_parameter_noinfo
$LN317@ScanConver:
	mov	ecx, DWORD PTR _heap$[esp+116]
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edx, DWORD PTR $T338615[esp+132]
	push	edx
	lea	esi, DWORD PTR _heap$[esp+136]
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase
	mov	eax, DWORD PTR _y$133973[esp+112]
	inc	eax
	cmp	eax, DWORD PTR [ebp+28]
	mov	DWORD PTR _y$133973[esp+112], eax
	jl	$LN14@ScanConver
$LN12@ScanConver:

; 329  : 		}
; 330  : 
; 331  : 		// Dump the edge and scan buffers, since we no longer need them.
; 332  : 
; 333  : 		free(mpEdgeBuffer);

	mov	eax, DWORD PTR [ebp+96]
	push	eax
	call	_free

; 334  : 		delete [] mpScanBuffer;

	mov	ebp, DWORD PTR [ebp+108]
	add	esp, 4
	push	ebp
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 335  : 
; 336  : 		// All done!
; 337  : 
; 338  : 		return true;

	lea	ecx, DWORD PTR _heap$[esp+116]
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+128], -1
	call	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
	mov	al, 1

; 339  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+116]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 100				; 00000064H
	ret	8
$LN27@ScanConver:

; 207  : 		{
; 208  : 			mWidth = mHeight = 0;

	xor	eax, eax
	mov	DWORD PTR [ebp+28], eax
	mov	DWORD PTR [ebp+24], eax

; 209  : 			mPathOffsetX = mPathOffsetY = 0;

	mov	DWORD PTR [ebp+128], eax
	mov	DWORD PTR [ebp+124], eax

; 210  : 			return true;

	mov	al, 1

; 339  : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+116]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 100				; 00000064H
	ret	8
$LN29@ScanConver:
	mov	ecx, DWORD PTR __$EHRec$[esp+116]
	pop	edi
	mov	DWORD PTR [ebp+128], esi
	mov	DWORD PTR [ebp+124], esi
	mov	DWORD PTR [ebp+28], esi
	mov	DWORD PTR [ebp+24], esi
	pop	esi
	pop	ebp
	xor	al, al
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 100				; 00000064H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ScanConvert@Rasterizer@ssf@@QAE_NAAVGlyphPath@2@ABVCRect@@@Z$0:
	lea	eax, DWORD PTR _heap$[ebp]
	push	eax
	call	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
	ret	0
__ehhandler$?ScanConvert@Rasterizer@ssf@@QAE_NAAVGlyphPath@2@ABVCRect@@@Z:
	mov	eax, OFFSET __ehfuncinfo$?ScanConvert@Rasterizer@ssf@@QAE_NAAVGlyphPath@2@ABVCRect@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ScanConvert@Rasterizer@ssf@@QAE_NAAVGlyphPath@2@ABVCRect@@@Z ENDP ; ssf::Rasterizer::ScanConvert
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?_Insert_n@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@IABU?$pair@_K_K@2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$?_Insert_n@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@IABU?$pair@_K_K@2@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@IABU?$pair@_K_K@2@@Z$0
__catchsym$?_Insert_n@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@IABU?$pair@_K_K@2@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@IABU?$pair@_K_K@2@@Z$2
__tryblocktable$?_Insert_n@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@IABU?$pair@_K_K@2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@IABU?$pair@_K_K@2@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@IABU?$pair@_K_K@2@@Z$5
__ehfuncinfo$?_Insert_n@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@IABU?$pair@_K_K@2@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@IABU?$pair@_K_K@2@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@IABU?$pair@_K_K@2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@IABU?$pair@_K_K@2@@Z
_TEXT	SEGMENT
__Tmp$132548 = -44					; size = 16
__Tmp$132530 = -44					; size = 16
$T354081 = -28						; size = 1
$T354045 = -28						; size = 1
__Newvec$132518 = -24					; size = 4
__$EHRec$ = -16						; size = 16
$T354292 = 8						; size = 1
__Cat$354295 = 8					; size = 1
$T354245 = 8						; size = 1
__Cat$354248 = 8					; size = 1
__Cat$354084 = 8					; size = 1
__Cat$354048 = 8					; size = 1
__Val$ = 8						; size = 4
__Where$ = 12						; size = 8
?_Insert_n@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@IABU?$pair@_K_K@2@@Z PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Insert_n, COMDAT
; _this$ = ecx

; 1158 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@IABU?$pair@_K_K@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	mov	esi, ecx

; 1159 : 
; 1160 :  #if _HAS_ITERATOR_DEBUGGING
; 1161 : 		if (_Where._Mycont != this
; 1162 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1163 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1164 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1165 : 
; 1166 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR [esi+12]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	test	ecx, ecx
	jne	SHORT $LN27@Insert_n@2
	xor	ebx, ebx
	jmp	SHORT $LN125@Insert_n@2
$LN27@Insert_n@2:
	mov	ebx, DWORD PTR [esi+20]
	sub	ebx, ecx
	sar	ebx, 4
$LN125@Insert_n@2:

; 1167 : 
; 1168 : 		if (_Count == 0)
; 1169 : 			;
; 1170 : 		else if (max_size() - size() < _Count)

	mov	edi, DWORD PTR [esi+16]
	mov	eax, edi
	sub	eax, ecx
	sar	eax, 4
	mov	ecx, 268435455				; 0fffffffH
	sub	ecx, eax
	cmp	ecx, 1
	jae	SHORT $LN10@Insert_n@2

; 1171 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@KAXXZ ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Xlen
$LN129@Insert_n@2:
$LN10@Insert_n@2:

; 1172 : 		else if (_Capacity < size() + _Count)

	lea	ecx, DWORD PTR [eax+1]
	cmp	ebx, ecx
	jae	$LN8@Insert_n@2

; 1173 : 			{	// not enough room, reallocate
; 1174 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1175 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ebx
	shr	eax, 1
	mov	edx, 268435455				; 0fffffffH
	sub	edx, eax
	cmp	edx, ebx
	jae	SHORT $LN15@Insert_n@2
	xor	ebx, ebx
	jmp	SHORT $LN16@Insert_n@2
$LN15@Insert_n@2:
	add	ebx, eax
$LN16@Insert_n@2:

; 1176 : 			if (_Capacity < size() + _Count)

	cmp	ebx, ecx
	jae	SHORT $LN7@Insert_n@2

; 1177 : 				_Capacity = size() + _Count;

	mov	ebx, ecx
$LN7@Insert_n@2:

; 1178 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, ebx
	call	?allocate@?$allocator@U?$pair@_K_K@std@@@std@@QAEPAU?$pair@_K_K@2@I@Z ; std::allocator<std::pair<unsigned __int64,unsigned __int64> >::allocate

; 1179 : 			pointer _Ptr = _Newvec;
; 1180 : 
; 1181 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1182 : 			_Ptr = _Umove(_Myfirst, _VEC_ITER_BASE(_Where),
; 1183 : 				_Newvec);	// copy prefix

	mov	ecx, DWORD PTR [esi+12]
	mov	BYTE PTR $T354045[ebp], 0
	mov	edx, DWORD PTR $T354045[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$354048[ebp]
	push	edx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	DWORD PTR __Newvec$132518[ebp], eax
	call	??$_Uninit_copy@PAU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >

; 1184 : 			_Ptr = _Ufill(_Ptr, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Cat$354084[ebp]
	mov	edx, DWORD PTR __Val$[ebp]
	mov	edi, eax
	add	esp, 12					; 0000000cH
	mov	BYTE PTR $T354081[ebp], 0
	mov	eax, DWORD PTR $T354081[ebp]
	push	eax
	push	ecx
	push	edi
	mov	ecx, 1
	call	??$_Uninit_fill_n@PAU?$pair@_K_K@std@@IU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAXPAU?$pair@_K_K@0@IABU10@AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<unsigned __int64,unsigned __int64> *,unsigned int,std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >

; 1185 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

	mov	edx, DWORD PTR [esi+16]
	add	esp, 12					; 0000000cH
	mov	BYTE PTR $T354245[ebp], 0
	mov	eax, DWORD PTR $T354245[ebp]
	mov	ecx, DWORD PTR __Cat$354248[ebp]
	push	eax
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	ecx
	add	edi, 16					; 00000010H
	push	eax
	mov	eax, edi
	call	??$_Uninit_copy@PAU?$pair@_K_K@std@@PAU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAPAU?$pair@_K_K@0@PAU10@00AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
	mov	DWORD PTR __$EHRec$[ebp+12], -1

; 1190 : 			_CATCH_END
; 1191 : 
; 1192 : 			_Count += size();

	mov	eax, DWORD PTR [esi+12]
	mov	edi, DWORD PTR [esi+16]
	sub	edi, eax
	sar	edi, 4
	add	esp, 12					; 0000000cH
	inc	edi

; 1193 : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $LN115@Insert_n@2

; 1194 : 				{	// destroy and deallocate old array
; 1195 : 				_Destroy(_Myfirst, _Mylast);
; 1196 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN115@Insert_n@2:

; 1197 : 				}
; 1198 : 
; 1199 :  #if _HAS_ITERATOR_DEBUGGING
; 1200 : 			this->_Orphan_all();
; 1201 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1202 : 
; 1203 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Newvec$132518[ebp]
	shl	ebx, 4
	add	ebx, eax

; 1204 : 			_Mylast = _Newvec + _Count;

	shl	edi, 4
	add	edi, eax
	mov	DWORD PTR [esi+20], ebx
	mov	DWORD PTR [esi+16], edi

; 1205 : 			_Myfirst = _Newvec;

	mov	DWORD PTR [esi+12], eax

; 1247 : 			}
; 1248 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
__catch$?_Insert_n@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@IABU?$pair@_K_K@2@@Z$0:

; 1186 : 			_CATCH_ALL
; 1187 : 			_Destroy(_Newvec, _Ptr);
; 1188 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Newvec$132518[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
__catch$?_Insert_n@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@IABU?$pair@_K_K@2@@Z$2:

; 1189 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN130@Insert_n@2:
$LN8@Insert_n@2:

; 1206 : 			}
; 1207 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	edx, DWORD PTR __Where$[ebp+4]
	mov	eax, edi
	sub	eax, edx
	sar	eax, 4
	cmp	eax, 1

; 1208 : 			{	// new stuff spills off end
; 1209 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$132530[ebp], ecx
	jae	SHORT $LN3@Insert_n@2
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$132530[ebp+4], ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$132530[ebp+8], ecx

; 1210 : 
; 1211 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1212 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	ecx, DWORD PTR [edx+16]
	push	ecx
	push	edi
	mov	DWORD PTR __Tmp$132530[ebp+12], eax
	call	??$_Umove@PAU?$pair@_K_K@std@@@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEPAU?$pair@_K_K@1@PAU21@00@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Umove<std::pair<unsigned __int64,unsigned __int64> *>

; 1213 : 
; 1214 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1215 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1216 : 				_Tmp);	// insert new stuff off end

	mov	eax, DWORD PTR [esi+16]
	mov	edx, eax
	sub	edx, DWORD PTR __Where$[ebp+4]
	mov	ecx, 1
	sar	edx, 4
	sub	ecx, edx
	mov	BYTE PTR $T354292[ebp], 0
	mov	edx, DWORD PTR $T354292[ebp]
	push	edx
	mov	edx, DWORD PTR __Cat$354295[ebp]
	push	edx
	push	eax
	lea	edx, DWORD PTR __Tmp$132530[ebp]
	call	??$_Uninit_fill_n@PAU?$pair@_K_K@std@@IU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAXPAU?$pair@_K_K@0@IABU10@AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<unsigned __int64,unsigned __int64> *,unsigned int,std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >

; 1217 : 			_CATCH_ALL
; 1218 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 1219 : 			_RERAISE;
; 1220 : 			_CATCH_END
; 1221 : 
; 1222 : 			_Mylast += _Count;
; 1223 : 
; 1224 :  #if _HAS_ITERATOR_DEBUGGING
; 1225 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1226 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1227 : 
; 1228 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1229 : 				_Tmp);	// insert up to old end

	mov	eax, DWORD PTR __Where$[ebp+4]
	add	esp, 12					; 0000000cH
	add	DWORD PTR [esi+16], 16			; 00000010H
	mov	esi, DWORD PTR [esi+16]
	lea	edx, DWORD PTR [esi-16]

; 1230 : 			}
; 1231 : 		else

	jmp	SHORT $LN128@Insert_n@2
$LN3@Insert_n@2:

; 1232 : 			{	// new stuff can all be assigned
; 1233 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$132548[ebp+4], edx
	mov	edx, DWORD PTR [eax+12]

; 1234 : 
; 1235 : 			pointer _Oldend = _Mylast;
; 1236 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1237 : 				_Mylast);	// copy suffix

	push	edi
	mov	DWORD PTR __Tmp$132548[ebp+12], edx
	lea	ebx, DWORD PTR [edi-16]
	push	edi
	mov	edx, ebx
	mov	DWORD PTR __Tmp$132548[ebp+8], ecx
	call	??$_Umove@PAU?$pair@_K_K@std@@@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEPAU?$pair@_K_K@1@PAU21@00@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Umove<std::pair<unsigned __int64,unsigned __int64> *>
	mov	DWORD PTR [esi+16], eax

; 1238 : 
; 1239 :  #if _HAS_ITERATOR_DEBUGGING
; 1240 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1241 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1242 : 
; 1243 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1244 : 				_Oldend);	// copy hole

	mov	esi, DWORD PTR __Where$[ebp+4]
	mov	edx, edi
	mov	ecx, ebx
	call	??$_Unchecked_move_backward@PAU?$pair@_K_K@std@@PAU12@@stdext@@YAPAU?$pair@_K_K@std@@PAU12@00@Z ; stdext::_Unchecked_move_backward<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> *>

; 1245 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1246 : 				_Tmp);	// insert into hole

	mov	eax, DWORD PTR __Where$[ebp+4]
	lea	edx, DWORD PTR [eax+16]
$LN128@Insert_n@2:
	push	eax
	lea	ecx, DWORD PTR __Tmp$132548[ebp]
	call	??$fill@PAU?$pair@_K_K@std@@U12@@std@@YAXPAU?$pair@_K_K@0@0ABU10@@Z ; std::fill<std::pair<unsigned __int64,unsigned __int64> *,std::pair<unsigned __int64,unsigned __int64> >

; 1247 : 			}
; 1248 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	add	esp, 4
	pop	edi
	pop	esi
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN127@Insert_n@2:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@IABU?$pair@_K_K@2@@Z:
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@IABU?$pair@_K_K@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@IABU?$pair@_K_K@2@@Z ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@ABU?$pair@_K_K@2@@Z
_TEXT	SEGMENT
__Tmp$354601 = -8					; size = 8
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
__Where$ = 16						; size = 8
?insert@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@ABU?$pair@_K_K@2@@Z PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::insert, COMDAT
; _this$ = eax

; 875  : 		{	// insert _Val at _Where

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, eax

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	eax, DWORD PTR [esi+16]
	mov	ebx, DWORD PTR [esi+12]
	mov	ecx, eax
	sub	ecx, ebx
	push	edi
	test	ecx, -16				; fffffff0H
	jne	SHORT $LN3@insert@2
	xor	edi, edi
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	cmp	ebx, eax
	jbe	SHORT $LN13@insert@2
	call	__invalid_parameter_noinfo
$LN13@insert@2:
	mov	ecx, DWORD PTR __Where$[esp+24]
	mov	eax, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN29@insert@2
	cmp	ecx, eax
	je	SHORT $LN28@insert@2
$LN29@insert@2:
	call	__invalid_parameter_noinfo
$LN28@insert@2:
	mov	edi, DWORD PTR __Where$[esp+28]
	sub	edi, ebx
	sar	edi, 4
$LN4@insert@2:

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Where$[esp+28]
	mov	eax, DWORD PTR __Where$[esp+24]
	mov	ecx, DWORD PTR __Val$[esp+24]
	push	edx
	push	eax
	push	ecx
	mov	ecx, esi
	call	?_Insert_n@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@IAEXV?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@IABU?$pair@_K_K@2@@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	ebx, DWORD PTR [esi+12]
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN43@insert@2
	call	__invalid_parameter_noinfo
$LN43@insert@2:
	mov	esi, DWORD PTR [esi]
	mov	ebp, esi
	mov	DWORD PTR __Tmp$354601[esp+32], ebx
	test	esi, esi
	jne	SHORT $LN85@insert@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN76@insert@2:
	shl	edi, 4
	add	edi, ebx
	cmp	edi, DWORD PTR [eax+16]
	ja	SHORT $LN63@insert@2
	test	esi, esi
	je	SHORT $LN81@insert@2
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN82@insert@2
$LN85@insert@2:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN76@insert@2
$LN81@insert@2:
	xor	esi, esi
$LN82@insert@2:
	cmp	edi, DWORD PTR [esi+12]
	jae	SHORT $LN62@insert@2
$LN63@insert@2:
	call	__invalid_parameter_noinfo
$LN62@insert@2:
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+24]
	mov	DWORD PTR [eax+4], edi

; 879  : 		}

	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ebp
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	16					; 00000010H
?insert@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@ABU?$pair@_K_K@2@@Z ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::insert
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXABU?$pair@_K_K@2@@Z
_TEXT	SEGMENT
$T354608 = -8						; size = 8
$T354639 = 8						; size = 1
__Cat$354642 = 8					; size = 1
__Val$ = 8						; size = 4
?push_back@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXABU?$pair@_K_K@2@@Z PROC ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::push_back, COMDAT
; _this$ = edi

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR [edi+12]
	sub	esp, 8
	push	ebx
	mov	ebx, DWORD PTR __Val$[esp+8]
	push	esi
	test	ecx, ecx
	jne	SHORT $LN9@push_back@2
	xor	eax, eax
	jmp	SHORT $LN10@push_back@2
$LN9@push_back@2:
	mov	eax, DWORD PTR [edi+20]
	sub	eax, ecx
	sar	eax, 4
$LN10@push_back@2:
	mov	esi, DWORD PTR [edi+16]
	mov	edx, esi
	sub	edx, ecx
	sar	edx, 4
	cmp	edx, eax
	jae	SHORT $LN2@push_back@2

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	BYTE PTR $T354639[esp+12], 0
	mov	eax, DWORD PTR $T354639[esp+12]
	mov	ecx, DWORD PTR __Cat$354642[esp+12]
	push	eax
	push	ecx
	push	esi
	mov	edx, ebx
	mov	ecx, 1
	call	??$_Uninit_fill_n@PAU?$pair@_K_K@std@@IU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAXPAU?$pair@_K_K@0@IABU10@AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<unsigned __int64,unsigned __int64> *,unsigned int,std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
	add	esp, 12					; 0000000cH
	add	esi, 16					; 00000010H
	mov	DWORD PTR [edi+16], esi

; 824  : 		}

	pop	esi
	pop	ebx
	add	esp, 8
	ret	4
$LN2@push_back@2:

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else
; 823  : 			insert(end(), _Val);

	cmp	ecx, esi
	jbe	SHORT $LN23@push_back@2
	call	__invalid_parameter_noinfo
$LN23@push_back@2:
	mov	eax, DWORD PTR [edi]
	push	esi
	push	eax
	push	ebx
	lea	edx, DWORD PTR $T354608[esp+28]
	push	edx
	mov	eax, edi
	call	?insert@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@ABU?$pair@_K_K@2@@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::insert

; 824  : 		}

	pop	esi
	pop	ebx
	add	esp, 8
	ret	4
?push_back@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXABU?$pair@_K_K@2@@Z ENDP ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::push_back
_TEXT	ENDS
PUBLIC	?_OverlapRegion@Rasterizer@@CAXAAV?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@0HH@Z ; Rasterizer::_OverlapRegion
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?_OverlapRegion@Rasterizer@@CAXAAV?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@0HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_OverlapRegion@Rasterizer@@CAXAAV?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@0HH@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_OverlapRegion@Rasterizer@@CAXAAV?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@0HH@Z$0
__ehfuncinfo$?_OverlapRegion@Rasterizer@@CAXAAV?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@0HH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_OverlapRegion@Rasterizer@@CAXAAV?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@0HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File d:\-=svn=-\svplayer\src\subtitles\rasterizer.cpp
xdata$x	ENDS
;	COMDAT ?_OverlapRegion@Rasterizer@@CAXAAV?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@0HH@Z
_TEXT	SEGMENT
_itA$ = -180						; size = 8
_itB$ = -172						; size = 8
_offset1$ = -164					; size = 8
_x2$129595 = -156					; size = 8
_x2$129622 = -148					; size = 8
$T355114 = -140						; size = 4
$T355260 = -136						; size = 4
_offset2$ = -132					; size = 8
_itAE$ = -124						; size = 8
_itBE$ = -116						; size = 8
$T354730 = -108						; size = 16
$T354728 = -108						; size = 16
_temp$ = -92						; size = 24
_x1$129621 = -68					; size = 8
_x1$129594 = -60					; size = 8
$T354722 = -52						; size = 8
$T354725 = -44						; size = 8
$T354724 = -36						; size = 16
__$EHRec$ = -12						; size = 12
_dst$ = 8						; size = 4
_dx$ = 12						; size = 4
_dy$ = 16						; size = 4
?_OverlapRegion@Rasterizer@@CAXAAV?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@0HH@Z PROC ; Rasterizer::_OverlapRegion, COMDAT
; _src$ = ecx

; 544  : {

	push	-1
	push	__ehhandler$?_OverlapRegion@Rasterizer@@CAXAAV?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@0HH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 172				; 000000acH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR _dst$[esp+196]

; 545  : 	tSpanBuffer temp;

	push	4
	mov	esi, ecx
	call	??2@YAPAXI@Z				; operator new
	xor	ecx, ecx
	add	esp, 4
	cmp	eax, ecx
	je	SHORT $LN52@OverlapReg@2
	lea	edx, DWORD PTR _temp$[esp+200]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN53@OverlapReg@2
$LN52@OverlapReg@2:
	xor	eax, eax
$LN53@OverlapReg@2:
	mov	DWORD PTR _temp$[esp+200], eax
	mov	DWORD PTR _temp$[esp+212], ecx
	mov	DWORD PTR _temp$[esp+216], ecx
	mov	DWORD PTR _temp$[esp+220], ecx
	mov	DWORD PTR __$EHRec$[esp+208], 1

; 546  : 
; 547  : 	temp.reserve(dst.size() + src.size());

	mov	eax, DWORD PTR [edi+16]
	mov	ecx, DWORD PTR [esi+16]
	sub	eax, DWORD PTR [edi+12]
	sub	ecx, DWORD PTR [esi+12]
	sar	eax, 4
	sar	ecx, 4
	add	eax, ecx
	push	eax
	lea	ecx, DWORD PTR _temp$[esp+204]
	call	?reserve@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXI@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::reserve

; 548  : 
; 549  : 	dst.swap(temp);

	lea	edx, DWORD PTR _temp$[esp+200]
	mov	eax, edi
	call	?swap@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXAAV12@@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::swap

; 550  : 
; 551  : 	tSpanBuffer::iterator itA = temp.begin();

	mov	eax, DWORD PTR _temp$[esp+212]
	mov	ecx, DWORD PTR _temp$[esp+216]
	mov	ebx, eax
	cmp	eax, ecx
	jbe	SHORT $LN110@OverlapReg@2
	call	__invalid_parameter_noinfo
	mov	ecx, DWORD PTR _temp$[esp+216]
	mov	eax, DWORD PTR _temp$[esp+212]
$LN110@OverlapReg@2:
	mov	edx, DWORD PTR _temp$[esp+200]
	mov	DWORD PTR _itA$[esp+200], edx
	mov	DWORD PTR _itA$[esp+204], ebx

; 552  : 	tSpanBuffer::iterator itAE = temp.end();

	mov	DWORD PTR $T355114[esp+200], ecx
	cmp	eax, ecx
	jbe	SHORT $LN129@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN129@OverlapReg@2:

; 553  : 	tSpanBuffer::iterator itB = src.begin();

	mov	ebx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR _temp$[esp+200]
	mov	DWORD PTR _itAE$[esp+200], eax
	cmp	ebx, DWORD PTR [esi+16]
	jbe	SHORT $LN148@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN148@OverlapReg@2:

; 554  : 	tSpanBuffer::iterator itBE = src.end();

	mov	eax, DWORD PTR [esi+16]
	mov	edi, DWORD PTR [esi]
	mov	DWORD PTR _itB$[esp+200], edi
	mov	ebp, ebx
	mov	DWORD PTR $T355260[esp+200], eax
	cmp	DWORD PTR [esi+12], eax
	jbe	SHORT $LN167@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN167@OverlapReg@2:

; 555  : 
; 556  : 	// Don't worry -- even if dy<0 this will still work! // G: hehe, the evil twin :)
; 557  : 
; 558  : 	unsigned __int64 offset1 = (((__int64)dy)<<32) - dx;

	mov	eax, DWORD PTR _dy$[esp+196]
	mov	ecx, DWORD PTR [esi]
	push	1
	cdq
	push	0
	push	edx
	push	eax
	mov	DWORD PTR _itBE$[esp+216], ecx
	call	__allmul
	mov	ecx, eax
	mov	eax, DWORD PTR _dx$[esp+196]
	mov	esi, edx
	cdq
	mov	ebx, ecx
	sub	ebx, eax
	mov	DWORD PTR _offset1$[esp+200], ebx
	mov	ebx, esi
	sbb	ebx, edx

; 559  : 	unsigned __int64 offset2 = (((__int64)dy)<<32) + dx;

	add	eax, ecx
	adc	edx, esi
	mov	DWORD PTR _offset1$[esp+204], ebx
	mov	DWORD PTR _offset2$[esp+200], eax
	mov	DWORD PTR _offset2$[esp+204], edx
$LN1014@OverlapReg@2:

; 560  : 
; 561  : 	while(itA != itAE && itB != itBE)

	mov	eax, DWORD PTR _itA$[esp+200]
	mov	esi, DWORD PTR _itA$[esp+204]
	test	eax, eax
	je	SHORT $LN185@OverlapReg@2
	cmp	eax, DWORD PTR _itAE$[esp+200]
	je	SHORT $LN184@OverlapReg@2
$LN185@OverlapReg@2:
	call	__invalid_parameter_noinfo
$LN184@OverlapReg@2:
	cmp	esi, DWORD PTR $T355114[esp+200]
	je	$LL4@OverlapReg@2
	test	edi, edi
	je	SHORT $LN198@OverlapReg@2
	cmp	edi, DWORD PTR _itBE$[esp+200]
	je	SHORT $LN197@OverlapReg@2
$LN198@OverlapReg@2:
	call	__invalid_parameter_noinfo
$LN197@OverlapReg@2:
	cmp	ebp, DWORD PTR $T355260[esp+200]
	je	$LL4@OverlapReg@2

; 562  : 	{
; 563  : 		if((*itB).first + offset1 < (*itA).first)

	test	edi, edi
	jne	$LN983@OverlapReg@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN223@OverlapReg@2:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN210@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN210@OverlapReg@2:
	mov	eax, DWORD PTR _itA$[esp+200]
	test	eax, eax
	jne	$LN982@OverlapReg@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN243@OverlapReg@2:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN230@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN230@OverlapReg@2:
	mov	ecx, DWORD PTR [ebp]
	add	ecx, DWORD PTR _offset1$[esp+200]
	mov	eax, DWORD PTR [ebp+4]
	adc	eax, ebx
	cmp	eax, DWORD PTR [esi+4]
	ja	$LN34@OverlapReg@2
	jb	SHORT $LN990@OverlapReg@2
	cmp	ecx, DWORD PTR [esi]
	jae	$LN34@OverlapReg@2
$LN990@OverlapReg@2:

; 564  : 		{
; 565  : 			// B span is earlier.  Use it.
; 566  : 
; 567  : 			unsigned __int64 x1 = (*itB).first + offset1;

	test	edi, edi
	jne	$LN981@OverlapReg@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN263@OverlapReg@2:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN250@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN250@OverlapReg@2:
	mov	eax, DWORD PTR [ebp]
	add	eax, DWORD PTR _offset1$[esp+200]
	mov	DWORD PTR _x1$129594[esp+200], eax
	mov	eax, DWORD PTR [ebp+4]
	adc	eax, ebx
	mov	DWORD PTR _x1$129594[esp+204], eax

; 568  : 			unsigned __int64 x2 = (*itB).second + offset2;

	test	edi, edi
	jne	$LN980@OverlapReg@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN283@OverlapReg@2:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN270@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN270@OverlapReg@2:
	mov	eax, DWORD PTR [ebp+8]
	add	eax, DWORD PTR _offset2$[esp+200]
	mov	edi, DWORD PTR [ebp+12]
	adc	edi, DWORD PTR _offset2$[esp+204]
	mov	DWORD PTR _x2$129595[esp+200], eax

; 569  : 
; 570  : 			++itB;

	mov	eax, DWORD PTR _itB$[esp+200]
	mov	DWORD PTR _x2$129595[esp+204], edi
	test	eax, eax
	jne	$LN979@OverlapReg@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN303@OverlapReg@2:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN290@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN290@OverlapReg@2:
	add	ebp, 16					; 00000010H
	npad	3
$LL33@OverlapReg@2:

; 571  : 
; 572  : 			// B spans don't overlap, so begin merge loop with A first.
; 573  : 
; 574  : 			for(;;)
; 575  : 			{
; 576  : 				// If we run out of A spans or the A span doesn't overlap,
; 577  : 				// then the next B span can't either (because B spans don't
; 578  : 				// overlap) and we exit.
; 579  : 
; 580  : 				if(itA == itAE || (*itA).first > x2)

	mov	esi, DWORD PTR _itA$[esp+200]
	test	esi, esi
	je	SHORT $LN309@OverlapReg@2
	cmp	esi, DWORD PTR _itAE$[esp+200]
	je	SHORT $LN308@OverlapReg@2
$LN309@OverlapReg@2:
	call	__invalid_parameter_noinfo
$LN308@OverlapReg@2:
	mov	ebx, DWORD PTR _itA$[esp+204]
	cmp	ebx, DWORD PTR $T355114[esp+200]
	je	$LN949@OverlapReg@2
	test	esi, esi
	jne	$LN978@OverlapReg@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN334@OverlapReg@2:
	cmp	ebx, DWORD PTR [eax+16]
	jb	SHORT $LN321@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN321@OverlapReg@2:
	mov	edx, DWORD PTR [ebx+4]
	cmp	edx, edi
	ja	$LN949@OverlapReg@2
	jb	SHORT $LL29@OverlapReg@2
	mov	eax, DWORD PTR [ebx]
	cmp	eax, DWORD PTR _x2$129595[esp+200]
	ja	$LN949@OverlapReg@2
$LL29@OverlapReg@2:

; 581  : 					break;
; 582  : 
; 583  : 				do {x2 = _MAX(x2, (*itA++).second);}

	mov	esi, DWORD PTR _itA$[esp+200]
	mov	ebx, DWORD PTR _itA$[esp+204]
	test	esi, esi
	jne	$LN977@OverlapReg@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN356@OverlapReg@2:
	mov	ecx, DWORD PTR _itA$[esp+204]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN343@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN343@OverlapReg@2:
	add	DWORD PTR _itA$[esp+204], 16		; 00000010H
	test	esi, esi
	jne	$LN976@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN376@OverlapReg@2:
	cmp	ebx, DWORD PTR [esi+16]
	jb	SHORT $LN363@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN363@OverlapReg@2:
	cmp	edi, DWORD PTR [ebx+12]
	lea	eax, DWORD PTR [ebx+8]
	ja	SHORT $LN381@OverlapReg@2
	jb	SHORT $LN382@OverlapReg@2
	mov	edx, DWORD PTR _x2$129595[esp+200]
	cmp	edx, DWORD PTR [eax]
	jb	SHORT $LN382@OverlapReg@2
$LN381@OverlapReg@2:
	lea	eax, DWORD PTR _x2$129595[esp+200]
$LN382@OverlapReg@2:
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _x2$129595[esp+200], ecx
	mov	edi, DWORD PTR [eax+4]

; 584  : 				while(itA != itAE && (*itA).first <= x2);

	mov	eax, DWORD PTR _itA$[esp+200]
	mov	DWORD PTR _x2$129595[esp+204], edi
	test	eax, eax
	je	SHORT $LN388@OverlapReg@2
	cmp	eax, DWORD PTR _itAE$[esp+200]
	je	SHORT $LN387@OverlapReg@2
$LN388@OverlapReg@2:
	call	__invalid_parameter_noinfo
$LN387@OverlapReg@2:
	mov	edx, DWORD PTR _itA$[esp+204]
	cmp	edx, DWORD PTR $T355114[esp+200]
	je	SHORT $LN26@OverlapReg@2
	mov	eax, DWORD PTR _itA$[esp+200]
	test	eax, eax
	jne	$LN975@OverlapReg@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN413@OverlapReg@2:
	mov	ecx, DWORD PTR _itA$[esp+204]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN400@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN400@OverlapReg@2:
	mov	eax, DWORD PTR _itA$[esp+204]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, edi
	jb	$LL29@OverlapReg@2
	ja	SHORT $LN26@OverlapReg@2
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR _x2$129595[esp+200]
	jbe	$LL29@OverlapReg@2
$LN26@OverlapReg@2:

; 585  : 
; 586  : 				// If we run out of B spans or the B span doesn't overlap,
; 587  : 				// then the next A span can't either (because A spans don't
; 588  : 				// overlap) and we exit.
; 589  : 
; 590  : 				if(itB == itBE || (*itB).first + offset1 > x2)

	mov	eax, DWORD PTR _itB$[esp+200]
	test	eax, eax
	je	SHORT $LN419@OverlapReg@2
	cmp	eax, DWORD PTR _itBE$[esp+200]
	je	SHORT $LN418@OverlapReg@2
$LN419@OverlapReg@2:
	call	__invalid_parameter_noinfo
$LN418@OverlapReg@2:
	cmp	ebp, DWORD PTR $T355260[esp+200]
	je	$LN949@OverlapReg@2
	mov	eax, DWORD PTR _itB$[esp+200]
	test	eax, eax
	jne	$LN974@OverlapReg@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN444@OverlapReg@2:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN431@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN431@OverlapReg@2:
	mov	ecx, DWORD PTR [ebp]
	add	ecx, DWORD PTR _offset1$[esp+200]
	mov	eax, DWORD PTR [ebp+4]
	adc	eax, DWORD PTR _offset1$[esp+204]
	cmp	eax, edi
	ja	$LN949@OverlapReg@2
	jb	SHORT $LN23@OverlapReg@2
	cmp	ecx, DWORD PTR _x2$129595[esp+200]
	ja	$LN949@OverlapReg@2
$LN23@OverlapReg@2:

; 591  : 					break;
; 592  : 
; 593  : 				do {x2 = _MAX(x2, (*itB++).second + offset2);}

	mov	ebx, DWORD PTR _itB$[esp+200]
	mov	esi, ebp
	test	ebx, ebx
	jne	$LN973@OverlapReg@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN466@OverlapReg@2:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN453@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN453@OverlapReg@2:
	add	ebp, 16					; 00000010H
	test	ebx, ebx
	jne	$LN972@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN486@OverlapReg@2:
	cmp	esi, DWORD PTR [ebx+16]
	jb	SHORT $LN473@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN473@OverlapReg@2:
	mov	ecx, DWORD PTR [esi+8]
	add	ecx, DWORD PTR _offset2$[esp+200]
	mov	eax, DWORD PTR [esi+12]
	adc	eax, DWORD PTR _offset2$[esp+204]
	mov	DWORD PTR $T354722[esp+200], ecx
	mov	DWORD PTR $T354722[esp+204], eax
	cmp	edi, eax
	ja	SHORT $LN491@OverlapReg@2
	jb	SHORT $LN995@OverlapReg@2
	cmp	DWORD PTR _x2$129595[esp+200], ecx
	jae	SHORT $LN491@OverlapReg@2
$LN995@OverlapReg@2:
	lea	eax, DWORD PTR $T354722[esp+200]
	jmp	SHORT $LN492@OverlapReg@2
$LN983@OverlapReg@2:

; 562  : 	{
; 563  : 		if((*itB).first + offset1 < (*itA).first)

	mov	eax, DWORD PTR [edi]
	jmp	$LN223@OverlapReg@2
$LN982@OverlapReg@2:
	mov	eax, DWORD PTR [eax]
	jmp	$LN243@OverlapReg@2
$LN981@OverlapReg@2:

; 564  : 		{
; 565  : 			// B span is earlier.  Use it.
; 566  : 
; 567  : 			unsigned __int64 x1 = (*itB).first + offset1;

	mov	eax, DWORD PTR [edi]
	jmp	$LN263@OverlapReg@2
$LN980@OverlapReg@2:

; 568  : 			unsigned __int64 x2 = (*itB).second + offset2;

	mov	eax, DWORD PTR [edi]
	jmp	$LN283@OverlapReg@2
$LN979@OverlapReg@2:

; 569  : 
; 570  : 			++itB;

	mov	eax, DWORD PTR [eax]
	jmp	$LN303@OverlapReg@2
$LN978@OverlapReg@2:

; 571  : 
; 572  : 			// B spans don't overlap, so begin merge loop with A first.
; 573  : 
; 574  : 			for(;;)
; 575  : 			{
; 576  : 				// If we run out of A spans or the A span doesn't overlap,
; 577  : 				// then the next B span can't either (because B spans don't
; 578  : 				// overlap) and we exit.
; 579  : 
; 580  : 				if(itA == itAE || (*itA).first > x2)

	mov	eax, DWORD PTR [esi]
	jmp	$LN334@OverlapReg@2
$LN977@OverlapReg@2:

; 581  : 					break;
; 582  : 
; 583  : 				do {x2 = _MAX(x2, (*itA++).second);}

	mov	eax, DWORD PTR [esi]
	jmp	$LN356@OverlapReg@2
$LN976@OverlapReg@2:
	mov	esi, DWORD PTR [esi]
	jmp	$LN376@OverlapReg@2
$LN975@OverlapReg@2:

; 584  : 				while(itA != itAE && (*itA).first <= x2);

	mov	eax, DWORD PTR [eax]
	jmp	$LN413@OverlapReg@2
$LN974@OverlapReg@2:

; 585  : 
; 586  : 				// If we run out of B spans or the B span doesn't overlap,
; 587  : 				// then the next A span can't either (because A spans don't
; 588  : 				// overlap) and we exit.
; 589  : 
; 590  : 				if(itB == itBE || (*itB).first + offset1 > x2)

	mov	eax, DWORD PTR [eax]
	jmp	$LN444@OverlapReg@2
$LN973@OverlapReg@2:

; 591  : 					break;
; 592  : 
; 593  : 				do {x2 = _MAX(x2, (*itB++).second + offset2);}

	mov	eax, DWORD PTR [ebx]
	jmp	$LN466@OverlapReg@2
$LN972@OverlapReg@2:
	mov	ebx, DWORD PTR [ebx]
	jmp	$LN486@OverlapReg@2
$LN491@OverlapReg@2:
	lea	eax, DWORD PTR _x2$129595[esp+200]
$LN492@OverlapReg@2:
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _x2$129595[esp+200], ecx
	mov	edi, DWORD PTR [eax+4]

; 594  : 				while(itB != itBE && (*itB).first + offset1 <= x2);

	mov	eax, DWORD PTR _itB$[esp+200]
	mov	DWORD PTR _x2$129595[esp+204], edi
	test	eax, eax
	je	SHORT $LN498@OverlapReg@2
	cmp	eax, DWORD PTR _itBE$[esp+200]
	je	SHORT $LN497@OverlapReg@2
$LN498@OverlapReg@2:
	call	__invalid_parameter_noinfo
$LN497@OverlapReg@2:
	cmp	ebp, DWORD PTR $T355260[esp+200]
	je	$LL33@OverlapReg@2
	mov	eax, DWORD PTR _itB$[esp+200]
	test	eax, eax
	jne	SHORT $LN971@OverlapReg@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN523@OverlapReg@2:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN510@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN510@OverlapReg@2:
	mov	ecx, DWORD PTR [ebp]
	add	ecx, DWORD PTR _offset1$[esp+200]
	mov	eax, DWORD PTR [ebp+4]
	adc	eax, DWORD PTR _offset1$[esp+204]
	cmp	eax, edi
	jb	$LN23@OverlapReg@2
	ja	$LL33@OverlapReg@2
	cmp	ecx, DWORD PTR _x2$129595[esp+200]
	jbe	$LN23@OverlapReg@2

; 595  : 			}

	jmp	$LL33@OverlapReg@2
$LN971@OverlapReg@2:

; 594  : 				while(itB != itBE && (*itB).first + offset1 <= x2);

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN523@OverlapReg@2
$LN949@OverlapReg@2:

; 596  : 
; 597  : 			// Flush span.
; 598  : 
; 599  : 			dst.push_back(tSpan(x1, x2));	

	mov	edx, DWORD PTR _x1$129594[esp+200]
	mov	eax, DWORD PTR _x1$129594[esp+204]
	mov	ecx, DWORD PTR _x2$129595[esp+200]
	mov	DWORD PTR $T354724[esp+200], edx
	lea	edx, DWORD PTR $T354724[esp+200]
	mov	DWORD PTR $T354724[esp+212], edi

; 634  : 
; 635  : 			// Flush span.
; 636  : 
; 637  : 			dst.push_back(tSpan(x1, x2));	

	mov	edi, DWORD PTR _dst$[esp+196]
	push	edx
	mov	DWORD PTR $T354724[esp+208], eax
	mov	DWORD PTR $T354724[esp+212], ecx
	call	?push_back@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXABU?$pair@_K_K@2@@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::push_back
	mov	edi, DWORD PTR _itB$[esp+200]
	mov	ebx, DWORD PTR _offset1$[esp+204]
	jmp	$LN1014@OverlapReg@2
$LN34@OverlapReg@2:

; 600  : 		}
; 601  : 		else
; 602  : 		{
; 603  : 			// A span is earlier.  Use it.
; 604  : 
; 605  : 			unsigned __int64 x1 = (*itA).first;

	mov	eax, DWORD PTR _itA$[esp+200]
	test	eax, eax
	jne	$LN970@OverlapReg@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN545@OverlapReg@2:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN532@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN532@OverlapReg@2:
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR _x1$129621[esp+200], eax

; 606  : 			unsigned __int64 x2 = (*itA).second;

	mov	eax, DWORD PTR _itA$[esp+200]
	mov	DWORD PTR _x1$129621[esp+204], ecx
	test	eax, eax
	jne	$LN969@OverlapReg@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN565@OverlapReg@2:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN552@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN552@OverlapReg@2:
	mov	esi, DWORD PTR _itA$[esp+204]

; 607  : 
; 608  : 			++itA;

	mov	eax, DWORD PTR _itA$[esp+200]
	mov	edx, DWORD PTR [esi+8]
	mov	edi, DWORD PTR [esi+12]
	mov	DWORD PTR _x2$129622[esp+200], edx
	mov	DWORD PTR _x2$129622[esp+204], edi
	test	eax, eax
	jne	$LN968@OverlapReg@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN585@OverlapReg@2:
	cmp	esi, DWORD PTR [eax+16]
	jb	SHORT $LN572@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN572@OverlapReg@2:
	add	esi, 16					; 00000010H
	mov	DWORD PTR _itA$[esp+204], esi
$LL18@OverlapReg@2:

; 609  : 
; 610  : 			// A spans don't overlap, so begin merge loop with B first.
; 611  : 
; 612  : 			for(;;)
; 613  : 			{
; 614  : 				// If we run out of B spans or the B span doesn't overlap,
; 615  : 				// then the next A span can't either (because A spans don't
; 616  : 				// overlap) and we exit.
; 617  : 
; 618  : 				if(itB == itBE || (*itB).first + offset1 > x2)

	mov	esi, DWORD PTR _itB$[esp+200]
	test	esi, esi
	je	SHORT $LN591@OverlapReg@2
	cmp	esi, DWORD PTR _itBE$[esp+200]
	je	SHORT $LN590@OverlapReg@2
$LN591@OverlapReg@2:
	call	__invalid_parameter_noinfo
$LN590@OverlapReg@2:
	cmp	ebp, DWORD PTR $T355260[esp+200]
	je	$LN951@OverlapReg@2
	test	esi, esi
	jne	$LN967@OverlapReg@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN616@OverlapReg@2:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN603@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN603@OverlapReg@2:
	mov	ecx, DWORD PTR [ebp]
	add	ecx, DWORD PTR _offset1$[esp+200]
	mov	eax, DWORD PTR [ebp+4]
	adc	eax, DWORD PTR _offset1$[esp+204]
	cmp	eax, edi
	ja	$LN951@OverlapReg@2
	jb	SHORT $LL14@OverlapReg@2
	cmp	ecx, DWORD PTR _x2$129622[esp+200]
	ja	$LN951@OverlapReg@2
	npad	4
$LL14@OverlapReg@2:

; 619  : 					break;
; 620  : 
; 621  : 				do {x2 = _MAX(x2, (*itB++).second + offset2);}

	mov	ebx, DWORD PTR _itB$[esp+200]
	mov	esi, ebp
	test	ebx, ebx
	jne	SHORT $LN966@OverlapReg@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN638@OverlapReg@2:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN625@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN625@OverlapReg@2:
	add	ebp, 16					; 00000010H
	test	ebx, ebx
	jne	SHORT $LN965@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN658@OverlapReg@2:
	cmp	esi, DWORD PTR [ebx+16]
	jb	SHORT $LN645@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN645@OverlapReg@2:
	mov	ecx, DWORD PTR [esi+8]
	add	ecx, DWORD PTR _offset2$[esp+200]
	mov	eax, DWORD PTR [esi+12]
	adc	eax, DWORD PTR _offset2$[esp+204]
	mov	DWORD PTR $T354725[esp+200], ecx
	mov	DWORD PTR $T354725[esp+204], eax
	cmp	edi, eax
	ja	SHORT $LN663@OverlapReg@2
	jb	SHORT $LN998@OverlapReg@2
	cmp	DWORD PTR _x2$129622[esp+200], ecx
	jae	SHORT $LN663@OverlapReg@2
$LN998@OverlapReg@2:
	lea	eax, DWORD PTR $T354725[esp+200]
	jmp	SHORT $LN664@OverlapReg@2
$LN970@OverlapReg@2:

; 600  : 		}
; 601  : 		else
; 602  : 		{
; 603  : 			// A span is earlier.  Use it.
; 604  : 
; 605  : 			unsigned __int64 x1 = (*itA).first;

	mov	eax, DWORD PTR [eax]
	jmp	$LN545@OverlapReg@2
$LN969@OverlapReg@2:

; 606  : 			unsigned __int64 x2 = (*itA).second;

	mov	eax, DWORD PTR [eax]
	jmp	$LN565@OverlapReg@2
$LN968@OverlapReg@2:

; 607  : 
; 608  : 			++itA;

	mov	eax, DWORD PTR [eax]
	jmp	$LN585@OverlapReg@2
$LN967@OverlapReg@2:

; 609  : 
; 610  : 			// A spans don't overlap, so begin merge loop with B first.
; 611  : 
; 612  : 			for(;;)
; 613  : 			{
; 614  : 				// If we run out of B spans or the B span doesn't overlap,
; 615  : 				// then the next A span can't either (because A spans don't
; 616  : 				// overlap) and we exit.
; 617  : 
; 618  : 				if(itB == itBE || (*itB).first + offset1 > x2)

	mov	eax, DWORD PTR [esi]
	jmp	$LN616@OverlapReg@2
$LN966@OverlapReg@2:

; 619  : 					break;
; 620  : 
; 621  : 				do {x2 = _MAX(x2, (*itB++).second + offset2);}

	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $LN638@OverlapReg@2
$LN965@OverlapReg@2:
	mov	ebx, DWORD PTR [ebx]
	jmp	SHORT $LN658@OverlapReg@2
$LN663@OverlapReg@2:
	lea	eax, DWORD PTR _x2$129622[esp+200]
$LN664@OverlapReg@2:
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _x2$129622[esp+200], ecx
	mov	edi, DWORD PTR [eax+4]

; 622  : 				while(itB != itBE && (*itB).first + offset1 <= x2);

	mov	eax, DWORD PTR _itB$[esp+200]
	mov	DWORD PTR _x2$129622[esp+204], edi
	test	eax, eax
	je	SHORT $LN670@OverlapReg@2
	cmp	eax, DWORD PTR _itBE$[esp+200]
	je	SHORT $LN669@OverlapReg@2
$LN670@OverlapReg@2:
	call	__invalid_parameter_noinfo
$LN669@OverlapReg@2:
	cmp	ebp, DWORD PTR $T355260[esp+200]
	je	SHORT $LN11@OverlapReg@2
	mov	eax, DWORD PTR _itB$[esp+200]
	test	eax, eax
	jne	$LN964@OverlapReg@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN695@OverlapReg@2:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN682@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN682@OverlapReg@2:
	mov	ecx, DWORD PTR [ebp]
	add	ecx, DWORD PTR _offset1$[esp+200]
	mov	eax, DWORD PTR [ebp+4]
	adc	eax, DWORD PTR _offset1$[esp+204]
	cmp	eax, edi
	jb	$LL14@OverlapReg@2
	ja	SHORT $LN11@OverlapReg@2
	cmp	ecx, DWORD PTR _x2$129622[esp+200]
	jbe	$LL14@OverlapReg@2
$LN11@OverlapReg@2:

; 623  : 
; 624  : 				// If we run out of A spans or the A span doesn't overlap,
; 625  : 				// then the next B span can't either (because B spans don't
; 626  : 				// overlap) and we exit.
; 627  : 
; 628  : 				if(itA == itAE || (*itA).first > x2)

	mov	eax, DWORD PTR _itA$[esp+200]
	test	eax, eax
	je	SHORT $LN701@OverlapReg@2
	cmp	eax, DWORD PTR _itAE$[esp+200]
	je	SHORT $LN700@OverlapReg@2
$LN701@OverlapReg@2:
	call	__invalid_parameter_noinfo
$LN700@OverlapReg@2:
	mov	edx, DWORD PTR $T355114[esp+200]
	cmp	DWORD PTR _itA$[esp+204], edx
	je	$LN951@OverlapReg@2
	mov	eax, DWORD PTR _itA$[esp+200]
	test	eax, eax
	jne	$LN963@OverlapReg@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN726@OverlapReg@2:
	mov	ecx, DWORD PTR _itA$[esp+204]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN713@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN713@OverlapReg@2:
	mov	edx, DWORD PTR _itA$[esp+204]
	mov	eax, DWORD PTR [edx+4]
	cmp	eax, edi
	ja	$LN951@OverlapReg@2
	jb	SHORT $LN8@OverlapReg@2
	mov	ecx, edx
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _x2$129622[esp+200]
	ja	$LN951@OverlapReg@2
$LN8@OverlapReg@2:

; 629  : 					break;
; 630  : 
; 631  : 				do {x2 = _MAX(x2, (*itA++).second);}

	mov	esi, DWORD PTR _itA$[esp+200]
	mov	ebx, DWORD PTR _itA$[esp+204]
	test	esi, esi
	jne	$LN962@OverlapReg@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN748@OverlapReg@2:
	mov	ecx, DWORD PTR _itA$[esp+204]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN735@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN735@OverlapReg@2:
	add	DWORD PTR _itA$[esp+204], 16		; 00000010H
	test	esi, esi
	jne	$LN961@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN768@OverlapReg@2:
	cmp	ebx, DWORD PTR [esi+16]
	jb	SHORT $LN755@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN755@OverlapReg@2:
	cmp	edi, DWORD PTR [ebx+12]
	lea	eax, DWORD PTR [ebx+8]
	ja	SHORT $LN773@OverlapReg@2
	jb	SHORT $LN774@OverlapReg@2
	mov	edx, DWORD PTR _x2$129622[esp+200]
	cmp	edx, DWORD PTR [eax]
	jb	SHORT $LN774@OverlapReg@2
$LN773@OverlapReg@2:
	lea	eax, DWORD PTR _x2$129622[esp+200]
$LN774@OverlapReg@2:
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _x2$129622[esp+200], ecx
	mov	edi, DWORD PTR [eax+4]

; 632  : 				while(itA != itAE && (*itA).first <= x2);

	mov	eax, DWORD PTR _itA$[esp+200]
	mov	DWORD PTR _x2$129622[esp+204], edi
	test	eax, eax
	je	SHORT $LN780@OverlapReg@2
	cmp	eax, DWORD PTR _itAE$[esp+200]
	je	SHORT $LN779@OverlapReg@2
$LN780@OverlapReg@2:
	call	__invalid_parameter_noinfo
$LN779@OverlapReg@2:
	mov	edx, DWORD PTR _itA$[esp+204]
	cmp	edx, DWORD PTR $T355114[esp+200]
	je	$LL18@OverlapReg@2
	mov	eax, DWORD PTR _itA$[esp+200]
	test	eax, eax
	jne	SHORT $LN960@OverlapReg@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN805@OverlapReg@2:
	mov	ecx, DWORD PTR _itA$[esp+204]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN792@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN792@OverlapReg@2:
	mov	eax, DWORD PTR _itA$[esp+204]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, edi
	jb	$LN8@OverlapReg@2
	ja	$LL18@OverlapReg@2
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR _x2$129622[esp+200]
	jbe	$LN8@OverlapReg@2

; 633  : 			}

	jmp	$LL18@OverlapReg@2
$LN964@OverlapReg@2:

; 622  : 				while(itB != itBE && (*itB).first + offset1 <= x2);

	mov	eax, DWORD PTR [eax]
	jmp	$LN695@OverlapReg@2
$LN963@OverlapReg@2:

; 623  : 
; 624  : 				// If we run out of A spans or the A span doesn't overlap,
; 625  : 				// then the next B span can't either (because B spans don't
; 626  : 				// overlap) and we exit.
; 627  : 
; 628  : 				if(itA == itAE || (*itA).first > x2)

	mov	eax, DWORD PTR [eax]
	jmp	$LN726@OverlapReg@2
$LN962@OverlapReg@2:

; 629  : 					break;
; 630  : 
; 631  : 				do {x2 = _MAX(x2, (*itA++).second);}

	mov	eax, DWORD PTR [esi]
	jmp	$LN748@OverlapReg@2
$LN961@OverlapReg@2:
	mov	esi, DWORD PTR [esi]
	jmp	$LN768@OverlapReg@2
$LN960@OverlapReg@2:

; 632  : 				while(itA != itAE && (*itA).first <= x2);

	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN805@OverlapReg@2
$LN951@OverlapReg@2:

; 634  : 
; 635  : 			// Flush span.
; 636  : 
; 637  : 			dst.push_back(tSpan(x1, x2));	

	mov	ecx, DWORD PTR _x1$129621[esp+200]
	mov	edx, DWORD PTR _x1$129621[esp+204]
	mov	eax, DWORD PTR _x2$129622[esp+200]
	mov	DWORD PTR $T354728[esp+200], ecx
	lea	ecx, DWORD PTR $T354728[esp+200]
	mov	DWORD PTR $T354728[esp+212], edi
	mov	edi, DWORD PTR _dst$[esp+196]
	push	ecx
	mov	DWORD PTR $T354728[esp+208], edx
	mov	DWORD PTR $T354728[esp+212], eax
	call	?push_back@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXABU?$pair@_K_K@2@@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::push_back
	mov	edi, DWORD PTR _itB$[esp+200]
	mov	ebx, DWORD PTR _offset1$[esp+204]
	jmp	$LN1014@OverlapReg@2
$LL4@OverlapReg@2:

; 638  : 		}
; 639  : 	}
; 640  : 
; 641  : 	// Copy over leftover spans.
; 642  : 
; 643  : 	while(itA != itAE)

	mov	eax, DWORD PTR _itA$[esp+200]
	test	eax, eax
	je	SHORT $LN815@OverlapReg@2
	cmp	eax, DWORD PTR _itAE$[esp+200]
	je	SHORT $LN814@OverlapReg@2
$LN815@OverlapReg@2:
	call	__invalid_parameter_noinfo
$LN814@OverlapReg@2:
	cmp	esi, DWORD PTR $T355114[esp+200]
	je	SHORT $LL2@OverlapReg@2

; 644  : 		dst.push_back(*itA++);

	mov	esi, DWORD PTR _itA$[esp+200]
	mov	edi, DWORD PTR _itA$[esp+204]
	mov	ebx, edi
	test	esi, esi
	jne	SHORT $LN959@OverlapReg@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN842@OverlapReg@2:
	cmp	edi, DWORD PTR [eax+16]
	jb	SHORT $LN829@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN829@OverlapReg@2:
	add	edi, 16					; 00000010H
	mov	DWORD PTR _itA$[esp+204], edi
	test	esi, esi
	jne	SHORT $LN958@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN862@OverlapReg@2:
	cmp	ebx, DWORD PTR [esi+16]
	jb	SHORT $LN849@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN849@OverlapReg@2:
	mov	edi, DWORD PTR _dst$[esp+196]
	push	ebx
	call	?push_back@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXABU?$pair@_K_K@2@@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::push_back
	mov	edi, DWORD PTR _itB$[esp+200]
	mov	esi, DWORD PTR _itA$[esp+204]
	jmp	SHORT $LL4@OverlapReg@2
$LN959@OverlapReg@2:
	mov	eax, DWORD PTR [esi]
	jmp	SHORT $LN842@OverlapReg@2
$LN958@OverlapReg@2:
	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN862@OverlapReg@2
	npad	7
$LL2@OverlapReg@2:

; 645  : 
; 646  : 	while(itB != itBE)

	test	edi, edi
	je	SHORT $LN870@OverlapReg@2
	cmp	edi, DWORD PTR _itBE$[esp+200]
	je	SHORT $LN869@OverlapReg@2
$LN870@OverlapReg@2:
	call	__invalid_parameter_noinfo
$LN869@OverlapReg@2:
	cmp	ebp, DWORD PTR $T355260[esp+200]
	je	$LN1@OverlapReg@2

; 647  : 	{
; 648  : 		dst.push_back(tSpan((*itB).first + offset1, (*itB).second + offset2));	

	test	edi, edi
	jne	$LN957@OverlapReg@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN895@OverlapReg@2:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN882@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN882@OverlapReg@2:
	mov	esi, DWORD PTR [ebp+8]
	add	esi, DWORD PTR _offset2$[esp+200]
	mov	ebx, DWORD PTR [ebp+12]
	adc	ebx, DWORD PTR _offset2$[esp+204]
	test	edi, edi
	jne	SHORT $LN956@OverlapReg@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN915@OverlapReg@2:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN902@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN902@OverlapReg@2:
	mov	edx, DWORD PTR [ebp]
	add	edx, DWORD PTR _offset1$[esp+200]
	mov	eax, DWORD PTR [ebp+4]
	adc	eax, DWORD PTR _offset1$[esp+204]
	mov	edi, DWORD PTR _dst$[esp+196]
	lea	ecx, DWORD PTR $T354730[esp+200]
	push	ecx
	mov	DWORD PTR $T354730[esp+204], edx
	mov	DWORD PTR $T354730[esp+208], eax
	mov	DWORD PTR $T354730[esp+212], esi
	mov	DWORD PTR $T354730[esp+216], ebx
	call	?push_back@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXABU?$pair@_K_K@2@@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::push_back

; 649  : 		++itB;

	cmp	DWORD PTR _itB$[esp+200], 0
	jne	SHORT $LN955@OverlapReg@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN937@OverlapReg@2:
	cmp	ebp, DWORD PTR [eax+16]
	jb	SHORT $LN924@OverlapReg@2
	call	__invalid_parameter_noinfo
$LN924@OverlapReg@2:

; 650  : 	}

	mov	edi, DWORD PTR _itB$[esp+200]
	add	ebp, 16					; 00000010H
	jmp	$LL2@OverlapReg@2
$LN957@OverlapReg@2:

; 647  : 	{
; 648  : 		dst.push_back(tSpan((*itB).first + offset1, (*itB).second + offset2));	

	mov	eax, DWORD PTR [edi]
	jmp	$LN895@OverlapReg@2
$LN956@OverlapReg@2:
	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN915@OverlapReg@2
$LN955@OverlapReg@2:

; 649  : 		++itB;

	mov	edx, DWORD PTR _itB$[esp+200]
	mov	eax, DWORD PTR [edx]
	jmp	SHORT $LN937@OverlapReg@2
$LN1@OverlapReg@2:

; 651  : }

	lea	eax, DWORD PTR _temp$[esp+200]
	push	eax
	mov	DWORD PTR __$EHRec$[esp+212], -1
	call	??1?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::~vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
	mov	ecx, DWORD PTR __$EHRec$[esp+200]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 184				; 000000b8H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_OverlapRegion@Rasterizer@@CAXAAV?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@0HH@Z$1:
	lea	eax, DWORD PTR _temp$[ebp]
	jmp	??1?$_Vector_val@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ
__unwindfunclet$?_OverlapRegion@Rasterizer@@CAXAAV?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@0HH@Z$0:
	lea	eax, DWORD PTR _temp$[ebp]
	push	eax
	call	??1?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::~vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
	ret	0
__ehhandler$?_OverlapRegion@Rasterizer@@CAXAAV?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@0HH@Z:
	mov	eax, OFFSET __ehfuncinfo$?_OverlapRegion@Rasterizer@@CAXAAV?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@0HH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_OverlapRegion@Rasterizer@@CAXAAV?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@0HH@Z ENDP ; Rasterizer::_OverlapRegion
PUBLIC	?ScanConvert@Rasterizer@@QAE_NXZ		; Rasterizer::ScanConvert
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$?ScanConvert@Rasterizer@@QAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ScanConvert@Rasterizer@@QAE_NXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ScanConvert@Rasterizer@@QAE_NXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ScanConvert@Rasterizer@@QAE_NXZ$4
__ehfuncinfo$?ScanConvert@Rasterizer@@QAE_NXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?ScanConvert@Rasterizer@@QAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Ogtpy
; File d:\-=svn=-\svplayer\src\subtitles\rasterizer.cpp
xdata$x	ENDS
;	COMDAT ?ScanConvert@Rasterizer@@QAE_NXZ
_TEXT	SEGMENT
tv2301 = -124						; size = 4
$T359186 = -124						; size = 1
_maxx$ = -124						; size = 4
_count$129150 = -120					; size = 4
_lastmoveto$ = -120					; size = 4
_x2$129334 = -116					; size = 4
_maxy$ = -116						; size = 4
tv2250 = -112						; size = 4
$T358885 = -112						; size = 4
tv1573 = -108						; size = 4
__Cat$359189 = -108					; size = 1
_x1$129333 = -108					; size = 4
_miny$ = -108						; size = 4
_y$ = -104						; size = 8
$T357868 = -96						; size = 8
$T357670 = -96						; size = 8
_itX1$129325 = -96					; size = 8
$T357871 = -88						; size = 8
$T357673 = -88						; size = 8
_itX2$129331 = -88					; size = 8
$T358475 = -80						; size = 8
$T359175 = -72						; size = 8
$T359369 = -64						; size = 8
$T357509 = -56						; size = 16
_heap$ = -36						; size = 24
__$EHRec$ = -12						; size = 12
?ScanConvert@Rasterizer@@QAE_NXZ PROC			; Rasterizer::ScanConvert, COMDAT
; _this$ = ecx

; 350  : {

	push	-1
	push	__ehhandler$?ScanConvert@Rasterizer@@QAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	DWORD PTR fs:0, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 351  : 	int lastmoveto = -1;
; 352  : 	int i;
; 353  : 
; 354  : 	// Drop any outlines we may have.
; 355  : 
; 356  : 	mOutline.clear();

	mov	ebx, DWORD PTR [edi+60]
	lea	esi, DWORD PTR [edi+44]
	mov	DWORD PTR _lastmoveto$[esp+140], -1
	cmp	DWORD PTR [esi+12], ebx
	jbe	SHORT $LN56@ScanConver@2
	call	__invalid_parameter_noinfo
$LN56@ScanConver@2:
	mov	ebp, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR $T357670[esp+140], eax
	cmp	ebp, DWORD PTR [esi+16]
	jbe	SHORT $LN75@ScanConver@2
	call	__invalid_parameter_noinfo
$LN75@ScanConver@2:
	mov	ecx, DWORD PTR $T357670[esp+140]
	mov	eax, DWORD PTR [esi]
	push	ebx
	push	ecx
	push	ebp
	push	eax
	lea	edx, DWORD PTR $T357673[esp+156]
	push	edx
	push	esi
	call	?erase@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@0@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::erase

; 357  : 	mWideOutline.clear();

	mov	ebx, DWORD PTR [edi+84]
	cmp	DWORD PTR [edi+80], ebx
	lea	esi, DWORD PTR [edi+68]
	jbe	SHORT $LN96@ScanConver@2
	call	__invalid_parameter_noinfo
$LN96@ScanConver@2:
	mov	ebp, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR $T357868[esp+140], eax
	cmp	ebp, DWORD PTR [esi+16]
	jbe	SHORT $LN115@ScanConver@2
	call	__invalid_parameter_noinfo
$LN115@ScanConver@2:
	mov	ecx, DWORD PTR $T357868[esp+140]
	mov	eax, DWORD PTR [esi]
	push	ebx
	push	ecx
	push	ebp
	push	eax
	lea	edx, DWORD PTR $T357871[esp+156]
	push	edx
	push	esi
	call	?erase@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@0@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::erase

; 358  : 	mWideBorder = 0;
; 359  : 
; 360  : 	// Determine bounding box
; 361  : 
; 362  : 	if(!mPathPoints)

	mov	ebp, DWORD PTR [edi+32]
	xor	esi, esi
	mov	DWORD PTR [edi+92], esi
	cmp	ebp, esi
	jne	SHORT $LN44@ScanConver@2

; 363  : 	{
; 364  : 		mPathOffsetX = mPathOffsetY = 0;

	mov	DWORD PTR [edi+128], esi
	mov	DWORD PTR [edi+124], esi

; 365  : 		mWidth = mHeight = 0;

	mov	DWORD PTR [edi+40], esi
	mov	DWORD PTR [edi+36], esi

; 366  : 		return 0;

	xor	al, al

; 539  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+140]
	mov	DWORD PTR fs:0, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 124				; 0000007cH
	ret	0
$LN44@ScanConver@2:

; 367  : 	}
; 368  : 
; 369  : 	int minx = INT_MAX;
; 370  : 	int miny = INT_MAX;
; 371  : 	int maxx = INT_MIN;
; 372  : 	int maxy = INT_MIN;
; 373  : 
; 374  : 	for(i=0; i<mPathPoints; ++i)

	cmp	ebp, esi
	mov	edx, -2147483648			; 80000000H
	mov	eax, 2147483647				; 7fffffffH
	mov	ecx, eax
	mov	DWORD PTR _maxx$[esp+140], edx
	mov	DWORD PTR _maxy$[esp+140], edx
	jle	SHORT $LN41@ScanConver@2
	mov	ebx, DWORD PTR [edi+28]
	mov	edx, DWORD PTR [edi+32]
	mov	DWORD PTR tv2250[esp+140], ebx
	mov	DWORD PTR tv1573[esp+140], edx
	npad	1
$LL43@ScanConver@2:

; 375  : 	{
; 376  : 		int ix = mpPathPoints[i].x;

	mov	esi, DWORD PTR [ebx]

; 377  : 		int iy = mpPathPoints[i].y;
; 378  : 
; 379  : 		if(ix < minx) minx = ix;

	cmp	esi, eax
	mov	ebx, DWORD PTR [ebx+4]
	jge	SHORT $LN40@ScanConver@2
	mov	eax, esi
$LN40@ScanConver@2:

; 380  : 		if(ix > maxx) maxx = ix;

	cmp	esi, DWORD PTR _maxx$[esp+140]
	jle	SHORT $LN39@ScanConver@2
	mov	DWORD PTR _maxx$[esp+140], esi
$LN39@ScanConver@2:

; 381  : 		if(iy < miny) miny = iy;

	cmp	ebx, ecx
	jge	SHORT $LN38@ScanConver@2
	mov	ecx, ebx
$LN38@ScanConver@2:

; 382  : 		if(iy > maxy) maxy = iy;

	mov	edx, DWORD PTR _maxy$[esp+140]
	cmp	ebx, edx
	jle	SHORT $LN42@ScanConver@2
	mov	edx, ebx
	mov	DWORD PTR _maxy$[esp+140], edx
$LN42@ScanConver@2:
	mov	ebx, DWORD PTR tv2250[esp+140]
	add	ebx, 8
	sub	DWORD PTR tv1573[esp+140], 1
	mov	DWORD PTR tv2250[esp+140], ebx
	jne	SHORT $LL43@ScanConver@2
$LN41@ScanConver@2:

; 383  : 	}
; 384  : 
; 385  : 	minx = (minx >> 3) & ~7;

	sar	eax, 3
	and	eax, -8					; fffffff8H

; 386  : 	miny = (miny >> 3) & ~7;

	sar	ecx, 3
	and	ecx, -8					; fffffff8H
	mov	ebx, eax

; 387  : 	maxx = (maxx + 7) >> 3;

	mov	eax, DWORD PTR _maxx$[esp+140]
	mov	esi, ecx
	add	eax, 7

; 388  : 	maxy = (maxy + 7) >> 3;

	lea	ecx, DWORD PTR [edx+7]
	sar	eax, 3
	sar	ecx, 3

; 389  : 
; 390  : 	for(i=0; i<mPathPoints; ++i)

	xor	edx, edx
	mov	DWORD PTR _miny$[esp+140], esi
	test	ebp, ebp
	jle	SHORT $LN528@ScanConver@2
	npad	11
$LL36@ScanConver@2:
	mov	esi, DWORD PTR [edi+28]
	lea	esi, DWORD PTR [esi+edx*8]

; 391  : 	{
; 392  : 		mpPathPoints[i].x -= minx*8;

	lea	ebp, DWORD PTR [ebx*8]
	sub	DWORD PTR [esi], ebp

; 393  : 		mpPathPoints[i].y -= miny*8;

	mov	ebp, DWORD PTR _miny$[esp+140]
	mov	esi, DWORD PTR [edi+28]
	add	ebp, ebp
	add	ebp, ebp
	lea	esi, DWORD PTR [esi+edx*8+4]
	add	ebp, ebp
	sub	DWORD PTR [esi], ebp
	inc	edx
	cmp	edx, DWORD PTR [edi+32]
	jl	SHORT $LL36@ScanConver@2

; 389  : 
; 390  : 	for(i=0; i<mPathPoints; ++i)

	mov	esi, DWORD PTR _miny$[esp+140]
$LN528@ScanConver@2:
	xor	ebp, ebp

; 394  : 	}
; 395  : 
; 396  : 	if(minx > maxx || miny > maxy)

	cmp	ebx, eax
	jg	$LN32@ScanConver@2
	cmp	esi, ecx
	jg	$LN32@ScanConver@2

; 401  : 		return true;
; 402  : 	}
; 403  : 
; 404  : 	mWidth = maxx + 1 - minx;

	sub	eax, ebx

; 405  : 	mHeight = maxy + 1 - miny;

	sub	ecx, esi
	inc	eax
	inc	ecx

; 406  : 
; 407  : 	mPathOffsetX = minx;
; 408  : 	mPathOffsetY = miny;
; 409  : 
; 410  : 	// Initialize edge buffer.  We use edge 0 as a sentinel.
; 411  : 
; 412  : 	mEdgeNext = 1;
; 413  : 	mEdgeHeapSize = 2048;
; 414  : 	mpEdgeBuffer = (Edge*)malloc(sizeof(Edge)*mEdgeHeapSize);

	push	16384					; 00004000H
	mov	DWORD PTR [edi+36], eax
	mov	DWORD PTR [edi+40], ecx
	mov	DWORD PTR [edi+124], ebx
	mov	DWORD PTR [edi+128], esi
	mov	DWORD PTR [edi+104], 1
	mov	DWORD PTR [edi+100], 2048		; 00000800H
	call	_malloc
	mov	DWORD PTR [edi+96], eax

; 415  : 
; 416  : 	// Initialize scanline list.
; 417  : 
; 418  : 	mpScanBuffer = new unsigned int[mHeight];

	mov	eax, DWORD PTR [edi+40]
	xor	ecx, ecx
	add	esp, 4
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 419  : 	memset(mpScanBuffer, 0, mHeight*sizeof(unsigned int));

	mov	ecx, DWORD PTR [edi+40]
	add	ecx, ecx
	add	esp, 4
	add	ecx, ecx
	push	ecx
	push	ebp
	push	eax
	mov	DWORD PTR [edi+108], eax
	call	_memset
	add	esp, 12					; 0000000cH

; 420  : 
; 421  : 	// Scan convert the outline.  Yuck, Bezier curves....
; 422  : 
; 423  : 	// Unfortunately, Windows 95/98 GDI has a bad habit of giving us text
; 424  : 	// paths with all but the first figure left open, so we can't rely
; 425  : 	// on the PT_CLOSEFIGURE flag being used appropriately.
; 426  : 
; 427  : 	fFirstSet = false;
; 428  : 	firstp.x = firstp.y = 0;
; 429  : 	lastp.x = lastp.y = 0;
; 430  : 
; 431  : 	for(i=0; i<mPathPoints; ++i)

	xor	ebx, ebx
	cmp	DWORD PTR [edi+32], ebp
	mov	BYTE PTR [edi+4], 0
	mov	DWORD PTR [edi+12], ebp
	mov	DWORD PTR [edi+8], ebp
	mov	DWORD PTR [edi+20], ebp
	mov	DWORD PTR [edi+16], ebp
	jle	$LN15@ScanConver@2

; 401  : 		return true;
; 402  : 	}
; 403  : 
; 404  : 	mWidth = maxx + 1 - minx;

	mov	DWORD PTR tv2301[esp+140], -1
$LL31@ScanConver@2:

; 432  : 	{
; 433  : 		BYTE t = mpPathTypes[i] & ~PT_CLOSEFIGURE;

	mov	edx, DWORD PTR [edi+24]
	mov	al, BYTE PTR [ebx+edx]
	and	al, 254					; 000000feH

; 434  : 
; 435  : 		switch(t)

	movzx	eax, al
	add	eax, -2					; fffffffeH
	cmp	eax, 250				; 000000faH
	ja	$LN30@ScanConver@2
	movzx	eax, BYTE PTR $LN525@ScanConver@2[eax]
	jmp	DWORD PTR $LN534@ScanConver@2[eax*4]
$LN26@ScanConver@2:

; 436  : 		{
; 437  : 		case PT_MOVETO:
; 438  : 			if(lastmoveto >= 0 && firstp != lastp)

	cmp	DWORD PTR _lastmoveto$[esp+140], ebp
	jl	SHORT $LN25@ScanConver@2
	mov	eax, DWORD PTR [edi+16]
	mov	ecx, DWORD PTR [edi+20]
	cmp	DWORD PTR [edi+8], eax
	jne	SHORT $LN132@ScanConver@2
	cmp	DWORD PTR [edi+12], ecx
	je	SHORT $LN25@ScanConver@2
$LN132@ScanConver@2:

; 439  : 				_EvaluateLine(lastp.x, lastp.y, firstp.x, firstp.y);

	mov	ecx, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [edi+20]
	push	ecx
	mov	ecx, DWORD PTR [edi+16]
	push	edx
	push	eax
	push	ecx
	mov	ecx, edi
	call	?_EvaluateLine@Rasterizer@@AAEXHHHH@Z	; Rasterizer::_EvaluateLine
$LN25@ScanConver@2:

; 440  : 			lastmoveto = i;
; 441  : 			fFirstSet = false;
; 442  : 			lastp = mpPathPoints[i];

	mov	eax, DWORD PTR [edi+28]
	mov	BYTE PTR [edi+4], 0
	mov	edx, DWORD PTR [eax+ebx*8]
	mov	DWORD PTR [edi+16], edx
	mov	eax, DWORD PTR [eax+ebx*8+4]
	mov	DWORD PTR _lastmoveto$[esp+140], ebx
	mov	DWORD PTR [edi+20], eax

; 443  : 			break;

	jmp	SHORT $LN30@ScanConver@2
$LN23@ScanConver@2:

; 444  : 		case PT_MOVETONC:
; 445  : 			break;
; 446  : 		case PT_LINETO:
; 447  : 			if(mPathPoints - (i-1) >= 2) _EvaluateLine(i-1, i);

	mov	ecx, DWORD PTR [edi+32]
	sub	ecx, ebx
	inc	ecx
	cmp	ecx, 2
	jl	SHORT $LN30@ScanConver@2
	mov	edx, DWORD PTR [edi+28]
	mov	ecx, DWORD PTR [edx+ebx*8+4]
	lea	eax, DWORD PTR [edx+ebx*8]
	mov	edx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR [eax-4]
	push	edx
	mov	edx, DWORD PTR [eax-8]
	push	ecx
	push	edx
	mov	ecx, edi
	call	?_EvaluateLine@Rasterizer@@AAEXHHHH@Z	; Rasterizer::_EvaluateLine

; 448  : 			break;

	jmp	SHORT $LN30@ScanConver@2
$LN21@ScanConver@2:

; 449  : 		case PT_BEZIERTO:
; 450  : 			if(mPathPoints - (i-1) >= 4) _EvaluateBezier(i-1, false);

	mov	eax, DWORD PTR [edi+32]
	sub	eax, ebx
	inc	eax
	cmp	eax, 4
	jl	SHORT $LN20@ScanConver@2
	push	ebp
$LN531@ScanConver@2:
	mov	edx, DWORD PTR tv2301[esp+144]
	mov	esi, edi
	call	?_EvaluateBezier@Rasterizer@@AAEXH_N@Z	; Rasterizer::_EvaluateBezier
$LN20@ScanConver@2:

; 451  : 			i += 2;

	add	ebx, 2
	add	DWORD PTR tv2301[esp+140], 2

; 452  : 			break;

	jmp	SHORT $LN30@ScanConver@2
$LN19@ScanConver@2:

; 453  : 		case PT_BSPLINETO:
; 454  : 			if(mPathPoints - (i-1) >= 4) _EvaluateBezier(i-1, true);

	mov	ecx, DWORD PTR [edi+32]
	sub	ecx, ebx
	inc	ecx
	cmp	ecx, 4
	jl	SHORT $LN20@ScanConver@2
	push	1

; 455  : 			i += 2;
; 456  : 			break;

	jmp	SHORT $LN531@ScanConver@2
$LN17@ScanConver@2:

; 457  : 		case PT_BSPLINEPATCHTO:
; 458  : 			if(mPathPoints - (i-3) >= 4) _EvaluateBezier(i-3, true);

	mov	edx, DWORD PTR [edi+32]
	sub	edx, ebx
	add	edx, 3
	cmp	edx, 4
	jl	SHORT $LN30@ScanConver@2
	push	1
	lea	edx, DWORD PTR [ebx-3]
	mov	esi, edi
	call	?_EvaluateBezier@Rasterizer@@AAEXH_N@Z	; Rasterizer::_EvaluateBezier
$LN30@ScanConver@2:
	inc	DWORD PTR tv2301[esp+140]
	inc	ebx
	cmp	ebx, DWORD PTR [edi+32]
	jl	$LL31@ScanConver@2

; 459  : 			break;
; 460  : 		}
; 461  : 	}
; 462  : 
; 463  : 	if(lastmoveto >= 0 && firstp != lastp)

	cmp	DWORD PTR _lastmoveto$[esp+140], ebp
	jl	SHORT $LN15@ScanConver@2
	mov	eax, DWORD PTR [edi+16]
	mov	ecx, DWORD PTR [edi+20]
	cmp	DWORD PTR [edi+8], eax
	jne	SHORT $LN140@ScanConver@2
	cmp	DWORD PTR [edi+12], ecx
	je	SHORT $LN15@ScanConver@2
$LN140@ScanConver@2:

; 464  : 		_EvaluateLine(lastp.x, lastp.y, firstp.x, firstp.y);

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [edi+8]
	mov	edx, DWORD PTR [edi+20]
	push	eax
	mov	eax, DWORD PTR [edi+16]
	push	ecx
	push	edx
	push	eax
	mov	ecx, edi
	call	?_EvaluateLine@Rasterizer@@AAEXHHHH@Z	; Rasterizer::_EvaluateLine
$LN15@ScanConver@2:

; 465  : 
; 466  : 	// Free the path since we don't need it anymore.
; 467  : 
; 468  : 	_TrashPath();

	mov	eax, DWORD PTR [edi+24]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	eax, DWORD PTR [edi+28]
	add	esp, 4
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 469  : 
; 470  : 	// Convert the edges to spans.  We couldn't do this before because some of
; 471  : 	// the regions may have winding numbers >+1 and it would have been a pain
; 472  : 	// to try to adjust the spans on the fly.  We use one heap to detangle
; 473  : 	// a scanline's worth of edges from the singly-linked lists, and another
; 474  : 	// to collect the actual scans.
; 475  : 
; 476  : 	std::vector<int> heap;

	push	4
	mov	DWORD PTR [edi+24], ebp
	mov	DWORD PTR [edi+28], ebp
	mov	DWORD PTR [edi+32], ebp
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebp
	je	SHORT $LN156@ScanConver@2
	lea	ecx, DWORD PTR _heap$[esp+140]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN157@ScanConver@2
$LN156@ScanConver@2:
	xor	eax, eax
$LN157@ScanConver@2:
	mov	DWORD PTR _heap$[esp+140], eax
	mov	DWORD PTR _heap$[esp+152], ebp
	mov	DWORD PTR _heap$[esp+156], ebp
	mov	DWORD PTR _heap$[esp+160], ebp
	mov	DWORD PTR __$EHRec$[esp+148], 1

; 477  : 
; 478  : 	mOutline.reserve(mEdgeNext / 2);

	mov	edx, DWORD PTR [edi+104]
	shr	edx, 1
	push	edx
	lea	ecx, DWORD PTR [edi+44]
	call	?reserve@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAEXI@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::reserve

; 479  : 
; 480  : 	__int64 y = 0;
; 481  : 
; 482  : 	for(y=0; y<mHeight; ++y)

	cmp	DWORD PTR [edi+40], ebp
	mov	DWORD PTR _y$[esp+140], ebp
	mov	DWORD PTR _y$[esp+144], ebp
	jle	$LN526@ScanConver@2
$LL14@ScanConver@2:

; 483  : 	{
; 484  : 		int count = 0;
; 485  : 
; 486  : 		// Detangle scanline into edge heap.
; 487  : 
; 488  : 		for(unsigned ptr = (unsigned)(mpScanBuffer[y]&0xffffffff); ptr; ptr = mpEdgeBuffer[ptr].next)

	mov	eax, DWORD PTR [edi+108]
	mov	ecx, DWORD PTR _y$[esp+140]
	mov	esi, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _heap$[esp+156]
	mov	DWORD PTR _count$129150[esp+140], 0
	test	esi, esi
	je	SHORT $LN9@ScanConver@2
	npad	2
$LL11@ScanConver@2:

; 489  : 		{
; 490  : 			heap.push_back(mpEdgeBuffer[ptr].posandflag);

	mov	edx, DWORD PTR [edi+96]
	lea	ebp, DWORD PTR [edx+esi*8+4]
	mov	edx, DWORD PTR _heap$[esp+152]
	test	edx, edx
	jne	SHORT $LN212@ScanConver@2
	xor	ecx, ecx
	jmp	SHORT $LN213@ScanConver@2
$LN212@ScanConver@2:
	mov	ecx, DWORD PTR _heap$[esp+160]
	sub	ecx, edx
	sar	ecx, 2
$LN213@ScanConver@2:
	mov	ebx, eax
	sub	ebx, edx
	sar	ebx, 2
	cmp	ebx, ecx
	jae	SHORT $LN205@ScanConver@2
	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR [eax], ecx
	add	eax, 4
	mov	DWORD PTR _heap$[esp+156], eax
	jmp	SHORT $LN10@ScanConver@2
$LN205@ScanConver@2:
	mov	ebx, eax
	cmp	edx, eax
	jbe	SHORT $LN243@ScanConver@2
	call	__invalid_parameter_noinfo
$LN243@ScanConver@2:
	mov	eax, DWORD PTR _heap$[esp+140]
	push	ebx
	push	eax
	push	ebp
	lea	edx, DWORD PTR $T358475[esp+152]
	push	edx
	lea	eax, DWORD PTR _heap$[esp+156]
	call	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@ABH@Z ; std::vector<int,std::allocator<int> >::insert
	mov	eax, DWORD PTR _heap$[esp+156]
$LN10@ScanConver@2:
	mov	ecx, DWORD PTR [edi+96]
	mov	esi, DWORD PTR [ecx+esi*8]
	test	esi, esi
	jne	SHORT $LL11@ScanConver@2
$LN9@ScanConver@2:

; 491  : 		}
; 492  : 
; 493  : 		// Sort edge heap.  Note that we conveniently made the opening edges
; 494  : 		// one more than closing edges at the same spot, so we won't have any
; 495  : 		// problems with abutting spans.
; 496  : 
; 497  : 		std::sort(heap.begin(), heap.end()/*begin() + heap.size()*/);

	mov	ecx, DWORD PTR _heap$[esp+152]
	mov	ebp, eax
	cmp	ecx, eax
	jbe	SHORT $LN262@ScanConver@2
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR _heap$[esp+156]
	mov	ecx, DWORD PTR _heap$[esp+152]
$LN262@ScanConver@2:
	mov	ebx, DWORD PTR _heap$[esp+140]
	mov	esi, ecx
	cmp	ecx, eax
	jbe	SHORT $LN281@ScanConver@2
	call	__invalid_parameter_noinfo
$LN281@ScanConver@2:
	test	ebx, ebx
	je	SHORT $LN301@ScanConver@2
	cmp	ebx, DWORD PTR _heap$[esp+140]
	je	SHORT $LN300@ScanConver@2
$LN301@ScanConver@2:
	call	__invalid_parameter_noinfo
$LN300@ScanConver@2:
	mov	edx, ebp
	sub	edx, esi
	sar	edx, 2
	push	edx
	push	ebp
	push	esi
	call	??$_Sort@PAHH@std@@YAXPAH0H@Z		; std::_Sort<int *,int>

; 498  : 
; 499  : 		// Process edges and add spans.  Since we only check for a non-zero
; 500  : 		// winding number, it doesn't matter which way the outlines go!
; 501  : 
; 502  : 		std::vector<int>::iterator itX1 = heap.begin();

	mov	ecx, DWORD PTR _heap$[esp+164]
	mov	eax, DWORD PTR _heap$[esp+168]
	add	esp, 12					; 0000000cH
	mov	ebx, ecx
	cmp	ecx, eax
	jbe	SHORT $LN327@ScanConver@2
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR _heap$[esp+156]
	mov	ecx, DWORD PTR _heap$[esp+152]
$LN327@ScanConver@2:
	mov	esi, DWORD PTR _heap$[esp+140]
	mov	DWORD PTR _itX1$129325[esp+140], esi
	mov	DWORD PTR _itX1$129325[esp+144], ebx

; 503  : 		std::vector<int>::iterator itX2 = heap.end(); // begin() + heap.size();

	mov	DWORD PTR $T358885[esp+140], eax
	cmp	ecx, eax
	jbe	SHORT $LN346@ScanConver@2
	call	__invalid_parameter_noinfo
$LN346@ScanConver@2:
	mov	eax, DWORD PTR _heap$[esp+140]
	mov	DWORD PTR _itX2$129331[esp+140], eax
	npad	4

; 504  : 
; 505  : 		int x1, x2;
; 506  : 
; 507  : 		for(; itX1 != itX2; ++itX1)

$LL369@ScanConver@2:
	test	esi, esi
	je	SHORT $LN384@ScanConver@2
	cmp	esi, DWORD PTR _itX2$129331[esp+140]
	je	SHORT $LN383@ScanConver@2
$LN384@ScanConver@2:
	call	__invalid_parameter_noinfo
$LN383@ScanConver@2:
	cmp	ebx, DWORD PTR $T358885[esp+140]
	je	$LN6@ScanConver@2

; 508  : 		{
; 509  : 			int x = *itX1;

	test	esi, esi
	jne	SHORT $LN522@ScanConver@2
	call	__invalid_parameter_noinfo
$LN409@ScanConver@2:
	cmp	ebx, DWORD PTR [esi+16]
	jb	SHORT $LN396@ScanConver@2
	call	__invalid_parameter_noinfo
$LN396@ScanConver@2:

; 510  : 
; 511  : 			if(!count) 

	mov	edx, DWORD PTR _count$129150[esp+140]
	mov	eax, DWORD PTR [ebx]
	test	edx, edx
	jne	SHORT $LN5@ScanConver@2

; 512  : 				x1 = (x>>1);

	mov	ecx, eax
	sar	ecx, 1
	mov	DWORD PTR _x1$129333[esp+140], ecx
$LN5@ScanConver@2:

; 513  : 
; 514  : 			if(x&1) 

	test	al, 1
	je	SHORT $LN4@ScanConver@2

; 515  : 				++count;

	inc	edx

; 516  : 			else 

	jmp	SHORT $LN532@ScanConver@2
$LN522@ScanConver@2:

; 508  : 		{
; 509  : 			int x = *itX1;

	mov	esi, DWORD PTR [esi]
	jmp	SHORT $LN409@ScanConver@2
$LN4@ScanConver@2:

; 517  : 				--count;

	dec	edx
$LN532@ScanConver@2:
	mov	DWORD PTR _count$129150[esp+140], edx

; 518  : 
; 519  : 			if(!count)

	test	edx, edx
	jne	$LN7@ScanConver@2

; 520  : 			{
; 521  : 				x2 = (x>>1);

	sar	eax, 1

; 522  : 
; 523  : 				if(x2>x1)

	cmp	eax, DWORD PTR _x1$129333[esp+140]
	mov	DWORD PTR _x2$129334[esp+140], eax
	jle	$LN7@ScanConver@2

; 524  : 					mOutline.push_back(std::pair<__int64,__int64>((y<<32)+x1+0x4000000040000000i64, (y<<32)+x2+0x4000000040000000i64)); // G: damn Avery, this is evil! :)

	mov	ecx, DWORD PTR _y$[esp+144]
	push	1
	push	edx
	mov	edx, DWORD PTR _y$[esp+148]
	push	ecx
	push	edx
	call	__allmul
	mov	ebp, eax
	mov	eax, DWORD PTR _x1$129333[esp+140]
	mov	ebx, edx
	cdq
	mov	ecx, eax
	mov	eax, DWORD PTR _x2$129334[esp+140]
	add	ecx, ebp
	mov	esi, edx
	adc	esi, ebx
	add	ecx, 1073741824				; 40000000H
	adc	esi, 1073741824				; 40000000H
	cdq
	add	eax, ebp
	adc	edx, ebx
	add	eax, 1073741824				; 40000000H
	mov	DWORD PTR $T357509[esp+148], eax
	mov	eax, DWORD PTR [edi+56]
	adc	edx, 1073741824				; 40000000H
	mov	DWORD PTR $T357509[esp+140], ecx
	mov	DWORD PTR $T357509[esp+144], esi
	mov	DWORD PTR $T357509[esp+152], edx
	test	eax, eax
	jne	SHORT $LN424@ScanConver@2
	xor	ecx, ecx
	jmp	SHORT $LN425@ScanConver@2
$LN424@ScanConver@2:
	mov	ecx, DWORD PTR [edi+64]
	sub	ecx, eax
	sar	ecx, 4
$LN425@ScanConver@2:
	mov	esi, DWORD PTR [edi+60]
	lea	ebx, DWORD PTR [edi+44]
	mov	edx, esi
	sub	edx, eax
	sar	edx, 4
	cmp	edx, ecx
	jae	SHORT $LN417@ScanConver@2
	mov	ecx, DWORD PTR __Cat$359189[esp+140]
	mov	BYTE PTR $T359186[esp+140], 0
	mov	eax, DWORD PTR $T359186[esp+140]
	push	eax
	push	ecx
	push	esi
	lea	edx, DWORD PTR $T357509[esp+152]
	mov	ecx, 1
	call	??$_Uninit_fill_n@PAU?$pair@_K_K@std@@IU12@V?$allocator@U?$pair@_K_K@std@@@2@@std@@YAXPAU?$pair@_K_K@0@IABU10@AAV?$allocator@U?$pair@_K_K@std@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::pair<unsigned __int64,unsigned __int64> *,unsigned int,std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >
	add	esp, 12					; 0000000cH
	add	esi, 16					; 00000010H
	mov	DWORD PTR [ebx+16], esi
	jmp	SHORT $LN7@ScanConver@2
$LN417@ScanConver@2:
	cmp	eax, esi
	jbe	SHORT $LN438@ScanConver@2
	call	__invalid_parameter_noinfo
$LN438@ScanConver@2:
	mov	eax, DWORD PTR [ebx]
	push	esi
	push	eax
	lea	edx, DWORD PTR $T357509[esp+148]
	push	edx
	lea	eax, DWORD PTR $T359175[esp+152]
	push	eax
	mov	eax, ebx
	call	?insert@?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@QAE?AV?$_Vector_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@V?$_Vector_const_iterator@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@2@ABU?$pair@_K_K@2@@Z ; std::vector<std::pair<unsigned __int64,unsigned __int64>,std::allocator<std::pair<unsigned __int64,unsigned __int64> > >::insert
$LN7@ScanConver@2:
	mov	eax, DWORD PTR _itX1$129325[esp+140]
	test	eax, eax
	jne	SHORT $LN521@ScanConver@2
	call	__invalid_parameter_noinfo
	xor	eax, eax
$LN376@ScanConver@2:
	mov	ecx, DWORD PTR _itX1$129325[esp+144]
	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LN363@ScanConver@2

; 504  : 
; 505  : 		int x1, x2;
; 506  : 
; 507  : 		for(; itX1 != itX2; ++itX1)

	call	__invalid_parameter_noinfo
$LN363@ScanConver@2:
	add	DWORD PTR _itX1$129325[esp+144], 4
	mov	ebx, DWORD PTR _itX1$129325[esp+144]
	mov	esi, DWORD PTR _itX1$129325[esp+140]
	jmp	$LL369@ScanConver@2
$LN521@ScanConver@2:
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN376@ScanConver@2
$LN6@ScanConver@2:

; 525  : 			}
; 526  : 		}
; 527  : 
; 528  : 		heap.clear();

	mov	eax, DWORD PTR _heap$[esp+156]
	mov	ebx, DWORD PTR _heap$[esp+152]
	mov	ebp, eax
	cmp	ebx, eax
	jbe	SHORT $LN459@ScanConver@2
	call	__invalid_parameter_noinfo
	mov	eax, DWORD PTR _heap$[esp+156]
	mov	ebx, DWORD PTR _heap$[esp+152]
$LN459@ScanConver@2:
	mov	esi, DWORD PTR _heap$[esp+140]
	cmp	ebx, eax
	jbe	SHORT $LN478@ScanConver@2
	call	__invalid_parameter_noinfo
$LN478@ScanConver@2:
	mov	edx, DWORD PTR _heap$[esp+140]
	push	ebp
	push	esi
	push	ebx
	push	edx
	lea	eax, DWORD PTR $T359369[esp+156]
	push	eax
	lea	esi, DWORD PTR _heap$[esp+160]
	call	?erase@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@HV?$allocator@H@std@@@2@V?$_Vector_const_iterator@HV?$allocator@H@std@@@2@0@Z ; std::vector<int,std::allocator<int> >::erase
	add	DWORD PTR _y$[esp+140], 1
	mov	ecx, DWORD PTR _y$[esp+144]
	mov	eax, DWORD PTR [edi+40]
	adc	ecx, 0
	cdq
	cmp	ecx, edx
	mov	DWORD PTR _y$[esp+144], ecx
	jl	$LL14@ScanConver@2

; 479  : 
; 480  : 	__int64 y = 0;
; 481  : 
; 482  : 	for(y=0; y<mHeight; ++y)

	jg	SHORT $LN526@ScanConver@2
	cmp	DWORD PTR _y$[esp+140], eax
	jb	$LL14@ScanConver@2
$LN526@ScanConver@2:

; 529  : 	}
; 530  : 
; 531  : 	// Dump the edge and scan buffers, since we no longer need them.
; 532  : 
; 533  : 	free(mpEdgeBuffer);

	mov	ecx, DWORD PTR [edi+96]
	push	ecx
	call	_free

; 534  : 	delete [] mpScanBuffer;

	mov	edi, DWORD PTR [edi+108]
	add	esp, 4
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 535  : 
; 536  : 	// All done!
; 537  : 
; 538  : 	return true;

	mov	DWORD PTR __$EHRec$[esp+148], 2
	mov	eax, DWORD PTR _heap$[esp+152]
	xor	esi, esi
	cmp	eax, esi
	je	SHORT $LN497@ScanConver@2
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN497@ScanConver@2:
	mov	DWORD PTR __$EHRec$[esp+148], -1
	mov	edx, DWORD PTR _heap$[esp+140]
	push	edx
	mov	DWORD PTR _heap$[esp+156], esi
	mov	DWORD PTR _heap$[esp+160], esi
	mov	DWORD PTR _heap$[esp+164], esi
	call	??3@YAXPAX@Z				; operator delete
	jmp	SHORT $LN533@ScanConver@2
$LN32@ScanConver@2:

; 397  : 	{
; 398  : 		mWidth = mHeight = 0;
; 399  : 		mPathOffsetX = mPathOffsetY = 0;
; 400  : 		_TrashPath();

	mov	eax, DWORD PTR [edi+24]
	push	eax
	mov	DWORD PTR [edi+40], ebp
	mov	DWORD PTR [edi+36], ebp
	mov	DWORD PTR [edi+128], ebp
	mov	DWORD PTR [edi+124], ebp
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	ecx, DWORD PTR [edi+28]
	add	esp, 4
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	mov	DWORD PTR [edi+24], ebp
	mov	DWORD PTR [edi+28], ebp
	mov	DWORD PTR [edi+32], ebp
$LN533@ScanConver@2:

; 539  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+144]
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	mov	DWORD PTR fs:0, ecx
	pop	ebx
	add	esp, 124				; 0000007cH
	ret	0
	npad	3
$LN534@ScanConver@2:
	DD	$LN23@ScanConver@2
	DD	$LN21@ScanConver@2
	DD	$LN26@ScanConver@2
	DD	$LN17@ScanConver@2
	DD	$LN19@ScanConver@2
	DD	$LN30@ScanConver@2
$LN525@ScanConver@2:
	DB	0
	DB	5
	DB	1
	DB	5
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	5
	DB	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ScanConvert@Rasterizer@@QAE_NXZ$1:
	lea	eax, DWORD PTR _heap$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__unwindfunclet$?ScanConvert@Rasterizer@@QAE_NXZ$0:
	lea	eax, DWORD PTR _heap$[ebp]
	push	eax
	call	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
	ret	0
__unwindfunclet$?ScanConvert@Rasterizer@@QAE_NXZ$4:
	lea	eax, DWORD PTR _heap$[ebp]
	jmp	??1?$_Vector_val@HV?$allocator@H@std@@@std@@QAE@XZ
__ehhandler$?ScanConvert@Rasterizer@@QAE_NXZ:
	mov	eax, OFFSET __ehfuncinfo$?ScanConvert@Rasterizer@@QAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?ScanConvert@Rasterizer@@QAE_NXZ ENDP			; Rasterizer::ScanConvert
PUBLIC	?CreateWidenedRegion@Rasterizer@@QAE_NHH@Z	; Rasterizer::CreateWidenedRegion
; Function compile flags: /Ogtpy
;	COMDAT ?CreateWidenedRegion@Rasterizer@@QAE_NHH@Z
_TEXT	SEGMENT
tv175 = -8						; size = 4
tv184 = -4						; size = 4
tv216 = 8						; size = 4
_rx$ = 8						; size = 4
tv178 = 12						; size = 4
_ry$ = 12						; size = 4
?CreateWidenedRegion@Rasterizer@@QAE_NHH@Z PROC		; Rasterizer::CreateWidenedRegion, COMDAT
; _this$ = eax

; 654  : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	push	esi
	mov	esi, DWORD PTR _rx$[esp+20]
	push	edi
	mov	edi, DWORD PTR _ry$[esp+24]

; 655  : 	if(rx < 0) rx = 0;

	test	esi, esi
	jge	SHORT $LN8@CreateWide@2
	xor	esi, esi
	mov	DWORD PTR _rx$[esp+24], esi
$LN8@CreateWide@2:

; 656  : 	if(ry < 0) ry = 0;

	test	edi, edi
	jge	SHORT $LN7@CreateWide@2
	xor	edi, edi
	mov	DWORD PTR _ry$[esp+24], edi
$LN7@CreateWide@2:

; 657  : 
; 658  : 	mWideBorder = max(rx,ry);

	cmp	esi, edi
	mov	ecx, esi
	jg	SHORT $LN12@CreateWide@2
	mov	ecx, edi
$LN12@CreateWide@2:
	mov	DWORD PTR [eax+92], ecx

; 659  : 
; 660  : 	if (ry > 0)

	test	edi, edi
	jle	$LN22@CreateWide@2

; 661  : 	{
; 662  : 		// Do a half circle.
; 663  : 		// _OverlapRegion mirrors this so both halves are done.
; 664  : 		for(int y = -ry; y <= ry; ++y)

	mov	esi, edi
	neg	esi
	cmp	esi, edi
	jg	$LN21@CreateWide@2
	fild	DWORD PTR _rx$[esp+24]
	mov	ebx, edi
	imul	ebx, edi
	fstp	DWORD PTR tv175[esp+28]
	fild	DWORD PTR _ry$[esp+24]
	fstp	DWORD PTR tv178[esp+24]
	lea	ebp, DWORD PTR [eax+44]
	add	eax, 68					; 00000044H

; 665  : 		{
; 666  : 			int x = (int)(0.5 + sqrt(float(ry*ry - y*y)) * float(rx)/float(ry));
; 667  : 
; 668  : 			_OverlapRegion(mWideOutline, mOutline, x, y);

	mov	DWORD PTR tv184[esp+28], eax
$LL5@CreateWide@2:
	mov	eax, esi
	imul	eax, esi
	push	esi
	push	ecx
	mov	ecx, ebx
	sub	ecx, eax
	mov	DWORD PTR tv216[esp+32], ecx
	push	ecx
	fild	DWORD PTR tv216[esp+36]
	fstp	DWORD PTR [esp]
	call	_sqrtf
	fmul	DWORD PTR tv175[esp+40]
	add	esp, 8
	fdiv	DWORD PTR tv178[esp+28]
	fadd	QWORD PTR __real@3fe0000000000000
	call	__ftol2_sse
	mov	edx, DWORD PTR tv184[esp+32]
	push	eax
	push	edx
	mov	ecx, ebp
	call	?_OverlapRegion@Rasterizer@@CAXAAV?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@0HH@Z ; Rasterizer::_OverlapRegion
	inc	esi
	add	esp, 12					; 0000000cH
	cmp	esi, edi
	jle	SHORT $LL5@CreateWide@2

; 676  : 	}
; 677  : 
; 678  : 	return true;

	mov	al, 1

; 679  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
$LN22@CreateWide@2:

; 669  : 		}
; 670  : 	}
; 671  : 	else if (ry == 0 && rx > 0)

	jne	SHORT $LN21@CreateWide@2
	test	esi, esi
	jle	SHORT $LN21@CreateWide@2

; 672  : 	{
; 673  : 		// There are artifacts if we don't make at least two overlaps of the line, even at same Y coord
; 674  : 		_OverlapRegion(mWideOutline, mOutline, rx, 0);

	push	0
	lea	edi, DWORD PTR [eax+44]
	lea	ebx, DWORD PTR [eax+68]
	push	esi
	push	ebx
	mov	ecx, edi
	call	?_OverlapRegion@Rasterizer@@CAXAAV?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@0HH@Z ; Rasterizer::_OverlapRegion
	add	esp, 12					; 0000000cH

; 675  : 		_OverlapRegion(mWideOutline, mOutline, rx, 0);

	push	0
	push	esi
	push	ebx
	mov	ecx, edi
	call	?_OverlapRegion@Rasterizer@@CAXAAV?$vector@U?$pair@_K_K@std@@V?$allocator@U?$pair@_K_K@std@@@2@@std@@0HH@Z ; Rasterizer::_OverlapRegion
	add	esp, 12					; 0000000cH
$LN21@CreateWide@2:

; 679  : }

	pop	edi
	pop	esi
	pop	ebp
	mov	al, 1
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	8
?CreateWidenedRegion@Rasterizer@@QAE_NHH@Z ENDP		; Rasterizer::CreateWidenedRegion
END
END
